<!doctype html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="面试," />




  


  <link rel="alternate" href="/atom.xml" title="oodt's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="请不要放太多精力在这。如果放，就看那些板子的东西而不是看思路的东西。 请仔细看！">
<meta property="og:type" content="article">
<meta property="og:title" content="手撕／算法">
<meta property="og:url" content="http://oodtoodt.github.io/2019/10/09/%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="oodt&#39;s blog">
<meta property="og:description" content="请不要放太多精力在这。如果放，就看那些板子的东西而不是看思路的东西。 请仔细看！">
<meta property="article:published_time" content="2019-10-09T06:12:16.000Z">
<meta property="article:modified_time" content="2020-07-14T02:03:37.000Z">
<meta property="article:author" content="eco_oodt">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://oodtoodt.github.io/2019/10/09/面试/手撕／算法/手撕／算法/"/>





  <title>手撕／算法 | oodt's blog</title>
  














<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">oodt's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">自杀之路</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://oodtoodt.github.io/2019/10/09/%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="eco_oodt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/prpr.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="oodt's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">手撕／算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-09T14:12:16+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/09/%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/10/09/面试/手撕／算法/手撕／算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/10/09/%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/" class="leancloud_visitors" data-flag-title="手撕／算法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><del>请不要放太多精力在这。如果放，就看那些板子的东西而不是看思路的东西。</del></p>
<p>请仔细看！</p>
<a id="more"></a>

<h4 id="大数据问题"><a href="#大数据问题" class="headerlink" title="大数据问题"></a>大数据问题</h4><p>1、分治 一半非最优，但总是可行。包括归并<br>2、哈希 粗暴且有效，就是耗内存，一种用法是哈希后分到不同机器<br>3、bit 布隆过滤器就是bit的扩展<br>4、堆 topk问题的解决方案</p>
<p>另外考虑：<br>trie<br>bitmap<br>并查集<br>MapReduce<br>倒排索引</p>
<h4 id="LRU缓存模拟"><a href="#LRU缓存模拟" class="headerlink" title="LRU缓存模拟"></a>LRU缓存模拟</h4><p>抄个LRU的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CacheNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  CacheNode *pre, *next;</span><br><span class="line">  CacheNode(<span class="keyword">int</span> k, <span class="keyword">int</span> v) : key(k), value(v), pre(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span>;                     <span class="comment">// Maximum of cachelist size.</span></span><br><span class="line">  CacheNode *head, *tail;</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, CacheNode *&gt; mp;          <span class="comment">// Use hashmap to store</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  LRUCache(<span class="keyword">int</span> capacity)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">size</span> = capacity;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    tail = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, CacheNode *&gt;::iterator it = mp.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      CacheNode *node = it -&gt; second;</span><br><span class="line">      <span class="built_in">remove</span>(node);</span><br><span class="line">      setHead(node);</span><br><span class="line">      <span class="keyword">return</span> node -&gt; value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, CacheNode *&gt;::iterator it = mp.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      CacheNode *node = it -&gt; second;</span><br><span class="line">      node -&gt; value = value;</span><br><span class="line">      <span class="built_in">remove</span>(node);</span><br><span class="line">      setHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      CacheNode *newNode = <span class="keyword">new</span> CacheNode(key, value);</span><br><span class="line">      <span class="keyword">if</span> (mp.<span class="built_in">size</span>() &gt;= <span class="built_in">size</span>)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>, CacheNode *&gt;::iterator iter = mp.<span class="built_in">find</span>(tail -&gt; key);</span><br><span class="line">      	<span class="built_in">remove</span>(tail);</span><br><span class="line">	mp.erase(iter);</span><br><span class="line">      &#125;</span><br><span class="line">      setHead(newNode);</span><br><span class="line">      mp[key] = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(CacheNode *node)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node -&gt; pre != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      node -&gt; pre -&gt; next = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      head = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      node -&gt; next -&gt; pre = node -&gt; pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      tail = node -&gt; pre;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setHead</span><span class="params">(CacheNode *node)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    node -&gt; next = head;</span><br><span class="line">    node -&gt; pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      head -&gt; pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">    head = node;</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      tail = head;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="快排代码"><a href="#快排代码" class="headerlink" title="快排代码"></a>快排代码</h4><p>先是partition专属</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r + <span class="number">1</span>;</span><br><span class="line">    T v = nums[l];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[++i] &lt; v) &amp;&amp; i != r) ;</span><br><span class="line">        <span class="keyword">while</span> (v &lt; nums[--j]) &amp;&amp; j != l) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">select</span><span class="params">(T[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt; l) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) &#123;</span><br><span class="line">            r = j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r &lt;= l)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">	sort(nums, l, j - <span class="number">1</span>);</span><br><span class="line">	sort(nums, j + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="堆排代码"><a href="#堆排代码" class="headerlink" title="堆排代码"></a>堆排代码</h4><p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。<br>复杂度O(N)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T[] heap;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i]&lt;heap[j];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T t = heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">            swap(k / <span class="number">2</span>, k);</span><br><span class="line">            k = k / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(k, j))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable v)</span> </span>&#123;</span><br><span class="line">        heap[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function">T <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T <span class="built_in">max</span> = heap[<span class="number">1</span>];</span><br><span class="line">        swap(<span class="number">1</span>, N--);</span><br><span class="line">        heap[N + <span class="number">1</span>] = null;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(nums, k, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">1</span>, N--);</span><br><span class="line">            sink(nums, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prekmp</span><span class="params">(<span class="keyword">char</span> x[],<span class="keyword">int</span> m,<span class="keyword">int</span> kmpnext[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    j = kmpnext[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">-1</span> != j &amp;&amp; x[i] != x[j]) j = kmpnext[j];</span><br><span class="line">        <span class="keyword">if</span>(x[++i] == x[++j]) kmpnext[i] = kmpnext[j];</span><br><span class="line">        <span class="keyword">else</span> kmpnext[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> kmpnext[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp_count</span><span class="params">(<span class="keyword">char</span> x[],<span class="keyword">int</span> m,<span class="keyword">char</span> y[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//x是模式串，y是主串。</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    prekmp(x,m,kmpnext);</span><br><span class="line">    i = j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">-1</span> != j &amp;&amp; y[i] != x[j]) j = kmpnext[j];</span><br><span class="line">        i++;j++;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            j = kmpnext[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="manacher"><a href="#manacher" class="headerlink" title="manacher"></a>manacher</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">110010</span>;</span><br><span class="line"><span class="keyword">char</span> Ma[Maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> Mp[Maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    Ma[l++] = <span class="string">'$'</span>;</span><br><span class="line">    Ma[l++] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Ma[l++] = s[i];</span><br><span class="line">        Ma[l++] = <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Ma[l] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>,id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Mp[i] = mx &gt; i ? <span class="built_in">min</span>(Mp[<span class="number">2</span>*id-i],mx-i) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(Ma[i+Mp[i]] == Ma[i-Mp[i]]) Mp[i] ++;</span><br><span class="line">        <span class="keyword">if</span>(i+Mp[i] &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = i + Mp[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输入一堆三角形，相连的三角形形成一个岛，求有几个岛"><a href="#输入一堆三角形，相连的三角形形成一个岛，求有几个岛" class="headerlink" title="输入一堆三角形，相连的三角形形成一个岛，求有几个岛"></a>输入一堆三角形，相连的三角形形成一个岛，求有几个岛</h4><p>不会</p>
<h4 id="用两个栈实现一个队列"><a href="#用两个栈实现一个队列" class="headerlink" title="用两个栈实现一个队列"></a>用两个栈实现一个队列</h4><p>就是全弹的那种。</p>
<h4 id="给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道-号表示，两球碰撞之后会消失，求所有碰撞时间。"><a href="#给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道-号表示，两球碰撞之后会消失，求所有碰撞时间。" class="headerlink" title="给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道 -号表示，两球碰撞之后会消失，求所有碰撞时间。"></a>给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道 -号表示，两球碰撞之后会消失，求所有碰撞时间。</h4><p>这什么东西？很明显N^2必定可以，这个思想在于只求时间而不在意碰撞的地点。那么如何优化？不会<br>用map来存&lt;time,序号&gt;，来维护动态的最小值。每次用首的time碰撞，序号和序号右边的值消除，右边的右边更新左值，序号的左边更新右值，map里新加入新的一对值。<br>写到这意识到还需要维护某个值左边和右边的值是谁，不过这个蛮好维护的。<br>猜的 具体是不是另说。</p>
<h4 id="一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车"><a href="#一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车" class="headerlink" title="一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车"></a>一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车</h4><p>规律在于必定是相邻的两车相遇，不论速度方向。<br>所以求一遍所有相邻的差就行了</p>
<h4 id="一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标"><a href="#一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标" class="headerlink" title="一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标"></a>一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标</h4><p>要求O(1)</p>
<h4 id="带括号的字符串压缩"><a href="#带括号的字符串压缩" class="headerlink" title="带括号的字符串压缩"></a>带括号的字符串压缩</h4><p>就是3(C2(AB)) = CABABCABABCABAB</p>
<p>重点还是在括号匹配上。首先记录数字和字符串，维护一个栈用来存放每个括号内的信息，遇到左括号就把当前位置扔进栈里，右括号出栈。当数字后面接的是字母时直接字母倍算，括号则标志后等待出栈之后处理，维护两个字符串，一个维护结果串，一个维护要被倍算的串。注意倍算后栈的位置也要进行变化。</p>
<h4 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h4><p>1）如果遇到操作数，我们就直接将其输出。</p>
<p>2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。</p>
<p>3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。注意，左括号只弹出并不输出。</p>
<p>4）如果遇到任何其他的操作符，如（“+”， “*”，“（”）等，从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止。弹出完这些元素后，才将遇到的操作符压入到栈中。有一点需要注意，只有在遇到” ) “的情况下我们才弹出” ( “，其他情况我们都不会弹出” ( “。</p>
<p>5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。 </p>
<p>如：a+b * c+d<br>a输出，+进栈，b输出， * 进栈，c输出，读到+，因为栈顶 * 优先级高，所以弹出 * 并输出，同理下一元素+与+一样所以弹出并输出，然后再读到+压入栈中，d输出，栈不空弹出输出。</p>
<h4 id="来一个死锁！"><a href="#来一个死锁！" class="headerlink" title="来一个死锁！"></a>来一个死锁！</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mutex;   <span class="comment">//代表一个全局互斥对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex.lock();</span><br><span class="line">    <span class="comment">//这里操作共享数据</span></span><br><span class="line">    B();  <span class="comment">//这里调用B方法</span></span><br><span class="line">    mutex.unlock();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex.lock();</span><br><span class="line">    <span class="comment">//这里操作共享数据</span></span><br><span class="line">    mutex.unlock();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时会由于在A、B方法中相互等待unlock而导致死锁。</span></span><br><span class="line"></span><br><span class="line">mutex;   <span class="comment">//代表一个全局互斥对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex.lock();</span><br><span class="line">    <span class="comment">//这里操作共享数据</span></span><br><span class="line">    <span class="keyword">if</span>(.....)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex.unlock();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">//由于在if的执行体内直接retun，而没有调用unlock，导致另一个线程再调用A方法就出现死锁。</span></span><br></pre></td></tr></table></figure>

<h4 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h4><p>注意是数据流，所以要动态维护。这里维护一个最大堆一个最小堆，奇数次向最小堆，偶数次向最大堆</p>
<p>为了保证大顶堆比小顶堆都小（试想两个金字塔，交汇即中位数），插入小顶堆时候先放进大顶堆然后拿出里面最大的给小顶堆。</p>
<p>这里可以用mutiset操作</p>
<h4 id="二叉树中两点间路径的最大长度"><a href="#二叉树中两点间路径的最大长度" class="headerlink" title="二叉树中两点间路径的最大长度"></a>二叉树中两点间路径的最大长度</h4><p>要么带根就是左右之和，要么不带，那就是左或者右里面带或者不带的最大值，递归即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDist</span><span class="params">(Tree root)</span> </span>&#123; </span><br><span class="line">	<span class="comment">//如果树是空的，则返回 0 </span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>) &#123; </span><br><span class="line">		root-&gt;lm = maxDist(root-&gt;left) + <span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>) root-&gt;rm = maxDist(root-&gt;right) + <span class="number">1</span>; </span><br><span class="line">	<span class="comment">//如果以该节点为根的子树中有最大的距离，那就更新最大距离 </span></span><br><span class="line">	<span class="keyword">int</span> sum = root-&gt;rm + root-&gt;lm; </span><br><span class="line">	<span class="keyword">if</span>(sum &gt; <span class="built_in">max</span>) &#123; </span><br><span class="line">		<span class="built_in">max</span> = sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root-&gt;rm &gt; root-&gt;lm ? root-&gt;rm : root-&gt;lm; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树中最大路径和"><a href="#二叉树中最大路径和" class="headerlink" title="二叉树中最大路径和"></a>二叉树中最大路径和</h4><p>其实首先想到的肯定还是lca，感觉上lca也是对的。不过没写。</p>
<p>然后我有一个印象就是先求离根最远的一个点，然后从这个点开始跑所有的点，求出来的理应最优</p>
<p>但是我当时在leetcode搓了几个小时没搓出来，让我对这个思路产生了怀疑。可能是里面的负边权有着很大的影响。举个例子，求这个「最远的」点，势必要跑一遍dfs，如果边权全为负，那么跑出来的结果注定是根本身。根本来说只要这条带根的路径是负的，就求不出那个最远的点。</p>
<p>解法：递归</p>
<p>转自leetcode：</p>
<p>二叉树abc，a是根结点（递归中的root），bc是左右子结点（代表其递归后的最优解）。<br>最大的路径，可能的路径情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  a</span><br><span class="line"> &#x2F; \</span><br><span class="line">b   c</span><br></pre></td></tr></table></figure>

<p>b + a + c。<br>b + a + a的父结点。<br>a + c + a的父结点。<br>其中情况 1 ，表示如果不联络父结点的情况，或本身是根结点的情况。<br>这种情况是没法递归的，但是结果有可能是全局最大路径和。<br>情况 2 和 3 ，递归时计算 a + b 和 a + c ，选择一个更优的方案返回，也就是上面说的递归后的最优解啦。</p>
<p>另外结点有可能是负值，最大和肯定就要想办法舍弃负值（max(0, x)）。<br>但是上面3种情况，无论哪种，a作为联络点，都不能够舍弃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> left = maxPathSum(root-&gt;left, val);</span><br><span class="line">	<span class="keyword">int</span> right = maxPathSum(root-&gt;right, val);</span><br><span class="line">	<span class="keyword">int</span> lmr = root-&gt;val + <span class="built_in">max</span>(<span class="number">0</span>, left) + <span class="built_in">max</span>(<span class="number">0</span>, right);</span><br><span class="line">	<span class="keyword">int</span> ret = root-&gt;val + <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">max</span>(left, right));</span><br><span class="line">	val = <span class="built_in">max</span>(val, <span class="built_in">max</span>(lmr, ret));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = INT_MIN;</span><br><span class="line">	maxPathSum(root, val);</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树转双向链表"><a href="#二叉树转双向链表" class="headerlink" title="二叉树转双向链表"></a>二叉树转双向链表</h4><p>不管转什么链表吧，核心就是看展开的链表跟二叉树啥关系：是前序中序之类的。那么根据这个序我们也可以写出相应的展开，以中序为例：</p>
<blockquote>
<p>思路：采用中序遍历的方法，visit函数需要完成的功能为：<br>1、当前节点的左子节点指向上一次访问的节点；<br>2、将上一次访问节点的右子节点指向当前节点；<br>3、最后更新上一次访问节点为当前节点。<br>在第二步时需要判断上一次访问节点是不是为NULL，如果是，则第二步改为链表的头结点指向当前节点。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(BSTnode * pCurrent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pCurrent-&gt;left = pList;<span class="comment">//*当前节点的左子节点指向上一次访问的节点；*//</span></span><br><span class="line">	<span class="keyword">if</span> (pList != <span class="literal">NULL</span>)</span><br><span class="line">		pList-&gt;right = pCurrent;<span class="comment">//将上一次访问节点的右子节点指向当前节点//</span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		pHead = pCurrent;</span><br><span class="line">	pList = pCurrent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BSTnode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		inorder(root-&gt;left);</span><br><span class="line">		visit(root);</span><br><span class="line">		inorder(root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，前序和后序如果要in-place的话需要倒过来用另一个遍历法</p>
<p>栈也是可以考虑的一种解法。</p>
<h4 id="lca"><a href="#lca" class="headerlink" title="lca"></a>lca</h4><p>LCA（Lowest Common Ancestors），即最近公共祖先<br>在一棵树上，两个节点的深度最浅的公共祖先就是LCA （自己可以是自己的祖先）</p>
<p>Tarjan算法的基本思路：<br>1.任选一个点为根节点，从根节点开始。<br>2.遍历该点u所有子节点v，并标记这些子节点v已被访问过。<br>3.若是v还有子节点，返回2，否则下一步。<br>4.合并v到u上。<br>5.寻找与当前点u有询问关系的点v。<br>6.若是v已经被访问过了，则可以确认u和v的最近公共祖先为v被合并到的父亲节点a。</p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>1.多次询问两点距离<br>dist[u,v]=dist[1,u]+dist[1,v]-2*dist[1,lca(u,v)]</p>
<p>2.树上差分（好像不如熟练剖分？）<br>1、修改路径上的结点值<br>2、查询单个结点权值<br>3、查询一个结点子树的权值和<br>对于操作1，显然用树上差分，用val[i]表示结点i的差分数组值，则i结点的真正改变值为以i为子树的所有结点的val数组和，如要修改(x,y)路径上的所有结点值+z，则val[x]+=z，val[y]+=z，val[lca(x,y)]-=z，val[fa[lca(x,y)]-=z；类似区间上的差分操作，对于结点fa[lca(x,y)]（表示x,y的最近公共祖先的父节点）以上的结点的子树的val和都是不变的，只有[x,y]路径上的结点的子树val和加上了z,不在该路径上的都没变。</p>
<p>操作2，单点权值=差分数组前缀和+原本值，树状数组即可实现</p>
<p>操作3，结点i的子树的权值和与结点深度有关，维护关于结点深度 * 修改值的树状数组</p>
<h5 id="树上倍增"><a href="#树上倍增" class="headerlink" title="树上倍增"></a>树上倍增</h5><p>倍增，是根据已经得到了的信息，将考虑的范围扩大，从而加速操作的一种思想<br>使用了倍增思想的算法有<br>归并排序<br>快速幂<br>基于ST表的RMQ算法<br>树上倍增找LCA等<br>FFT、后缀数组等高级算法</p>
<p>不用想了虽然这个思路非常吊但是都可以剖分</p>
<p>不过说实话lca最好的写法真就是倍增。<br>用dfs记录每个点的深度，求LCA时先调至统一深度，再一起向上跳<br>其实树上倍增运用的就是这个思想！只不过时间复杂度降至了飞快的O(log2n)<br>对于两个节点u和v，我们先把u和v调至同一深度<br>若此时u=v、，那么原来两点的LCA即为当前点<br>如果depth[u]=depth[v]但u≠v，就说明LCA(u,v)在更浅的地方<br>我们同时把u和v向上跳2^k步，直到u=v<br>明显这种方法肯定能求出LCA，因为u和v一定会相遇<br>倍增比那种脑残方法优的是，脑残方法一步一步向上跳，倍增一次跳2^k步！<br>如何把u和v调至同一深度？<br>其实是一样的，先把较深的那个点调浅就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;edge[maxx*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxx],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[tot].to = v;</span><br><span class="line">    edge[tot].next = head[u];</span><br><span class="line">    edge[tot].w = w;</span><br><span class="line">    head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEG = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxx][DEG];</span><br><span class="line"><span class="keyword">int</span> dis[maxx][DEG];</span><br><span class="line"><span class="keyword">int</span> deg[maxx];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">    deg[root] = <span class="number">0</span>;</span><br><span class="line">    fa[root][<span class="number">0</span>] = root;</span><br><span class="line">    dis[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    que.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; DEG; i++) &#123;</span><br><span class="line">            fa[tmp][i] = fa[fa[tmp][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            dis[tmp][i] = dis[tmp][i<span class="number">-1</span>] + dis[fa[tmp][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[tmp]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(v == fa[tmp][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            deg[v] = deg[tmp] + <span class="number">1</span>;</span><br><span class="line">            fa[v][<span class="number">0</span>] = tmp;</span><br><span class="line">            dis[v][<span class="number">0</span>] = edge[i].w;</span><br><span class="line">            que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deg[u] &gt; deg[v]) swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> hu = deg[u],hv = deg[v];</span><br><span class="line">    <span class="keyword">int</span> tu = u,tv = v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> det = hv - hu, i = <span class="number">0</span>; det ; det&gt;&gt;=<span class="number">1</span>, i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(det &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans += dis[tv][i];</span><br><span class="line">            tv = fa[tv][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tu == tv) <span class="keyword">return</span> tu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = DEG<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[tu][i] == fa[tv][i])<span class="keyword">continue</span>;</span><br><span class="line">        ans += dis[tv][i];</span><br><span class="line">        ans += dis[tu][i];</span><br><span class="line">        tu = fa[tu][i];</span><br><span class="line">        tv = fa[tv][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tu != tv)&#123;</span><br><span class="line">        ans += dis[tu][<span class="number">0</span>];</span><br><span class="line">        ans += dis[tv][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[tu][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag[maxx];</span><br></pre></td></tr></table></figure>

<h4 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h4><p>静态树全都可以剖</p>
<h4 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h4><p>动态树<br>例如添、删树边操作等<br>LCT≈splay+树剖<br>核心思想就是借鉴树剖的 轻重边 等概念，用比线段树灵活的splay来维护一棵树（森林）</p>
<h4 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h4><p>64匹马，有8个赛道，问几次比赛能决出1234名</p>
<p>首先分成8组A1-H8每组分出排名，然后第一们跑一圈就知道1是谁，按1排个序，离1最近的两个就是第二名，左上的三角就是34名可能的位置</p>
<p>注意到两个赛很蠢，所以里面可以放一些，但是8个是有限制的，如果5个就能立出23名。8个只能出了2后立出34</p>
<p>情况会变得非常复杂，可以不考虑</p>
<h4 id="滑雪问题"><a href="#滑雪问题" class="headerlink" title="滑雪问题"></a>滑雪问题</h4><p>本质就是一个dp，没啥</p>
<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><h5 id="区间最大子段和"><a href="#区间最大子段和" class="headerlink" title="区间最大子段和"></a>区间最大子段和</h5><p>对于每一个每个区间，保存一个Node，记录这个区间的sum(总和)，maxsum(最大子段和)，lmax(最大前缀和)，rmax(最大后缀和)，有了这四个标记，就可以随意转移，为所欲为了。。。<br>这里我们把核心代码拉出来讲一讲</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ans.sum = lo.sum + ro.sum;<span class="comment">//sum直接相加</span></span><br><span class="line">ans.maxsum = <span class="built_in">max</span>(<span class="built_in">max</span>(lo.maxsum, ro.maxsum), lo.rmax + ro.lmax);<span class="comment">//左右两半的最大子段和，合并起来的最大子段和</span></span><br><span class="line">ans.lmax = <span class="built_in">max</span>(lo.lmax, lo.sum + ro.lmax);<span class="comment">//左边的最大前缀和，左边整段+右边最大前缀</span></span><br><span class="line">ans.rmax = <span class="built_in">max</span>(ro.rmax, ro.sum + lo.rmax);<span class="comment">//右边的最大后缀和，右边整段+左边最大后缀</span></span><br></pre></td></tr></table></figure>

<p>给出一个一维的数列，怎么找出连续的，小于等于w个的数，它们的和最大。这个问题可以用线段树O(nlogn)地解决，在将一个数a放到x这个位置的同时，放一个相反数-a在x+w的位置，然后求出整个区间的最大和就是答案。注意，应该先插入-a，再插入a。</p>
<h5 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h5><p>我居然看懂并且理解了。</p>
<p>就是按一个坐标排序之后，给每个矩形上面给一个+权值，下面给一个-权值，遍历这个排序之后的线，维护离散化后的下边值，可以用线段树优化（区间加，区间减）。如果只是求矩形面积而言很简单。</p>
<p>简而言之，就是将每个矩阵拆成两条平行的线段（以平行于y轴的线段为例，记录它的x轴坐标，以及它在y轴上所代表的区间），按x轴排序后再一路扫过去（线段与线段之间即为若干个可求解的矩形，依次计算即可），同时，再利用线段树维护y轴上的区间（算是优化吧）。</p>
<p>面积并<br>　　扫描线的那部分就不讲了，主要讲讲线段树<br>　　对于y轴上的一段区间，需要记录<br>　　　　len:区间内被覆盖的长度<br>　　　　cnt:整个区间被覆盖的次数<br>　　由于所有修改之后，cnt的值必定为0，对于区间的修改，可以不考虑下放标记。则：</p>
<ol>
<li>cnt＞０　　　len＝区间长度，否则转2</li>
<li>为叶子节点 　 len＝0 　　　，否则转3</li>
<li>不为叶子节点　 len＝左右孩子len之和</li>
</ol>
<p>周长并：暴力两次算了，复杂度没区别<br>线段的长度即：这次和上次线段长度差点绝对值</p>
<p>不过变形真的还蛮难理解的。</p>
<p>首先扫描点（矩阵范围内点的最多个数）：</p>
<p>对于每个点(x, y)，我们维护一个右上方的矩阵【(x, y) -&gt; (x+w, y+h)】<br>对于每个点(x, y)，你另外添加一个点(x+w, y)。从左到右扫描：遇到(x, y)，区间[y, y+h]加1，遇到(x+w, y)，区间[y, y+h]减1。<br>区间更新 用线段树维护。对于每次更新求 区间最大值即可。</p>
<p>覆盖k次的面积：令人窒息的pushup根本看不懂。努力一小时放弃。反正就是「由于每次查询都是整个区间的覆盖次数，即只看线段树根结点的信息，因此结点的懒标记不用下放，只需要通过左右儿子以及当前结点的懒标记来更新当前结点的信息。」</p>
<p>虽然是个板子题但是理解上有些困难，放了放了。</p>
<h4 id="依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？"><a href="#依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？" class="headerlink" title="依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？"></a>依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？</h4><p>本质是求一个数的因数个数。为奇数则开。因数成对出现，除非平方数的根。所以求1-100中的完全平方数即可。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/24/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E7%BB%8F-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88/%E9%9D%A2%E7%BB%8F-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88/" rel="next" title="面经-从零开始（">
                <i class="fa fa-chevron-left"></i> 面经-从零开始（
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/13/lua/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86(1)/" rel="prev" title="lua笔记整理(1)">
                lua笔记整理(1) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2019/10/09/面试/手撕／算法/手撕／算法/"
           data-title="手撕／算法" data-url="http://oodtoodt.github.io/2019/10/09/%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/prpr.jpg"
               alt="eco_oodt" />
          <p class="site-author-name" itemprop="name">eco_oodt</p>
           
              <p class="site-description motion-element" itemprop="description">---自虐一点 开心一点</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">83</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#大数据问题"><span class="nav-number">1.</span> <span class="nav-text">大数据问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU缓存模拟"><span class="nav-number">2.</span> <span class="nav-text">LRU缓存模拟</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快排代码"><span class="nav-number">3.</span> <span class="nav-text">快排代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排代码"><span class="nav-number">4.</span> <span class="nav-text">堆排代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kmp"><span class="nav-number">5.</span> <span class="nav-text">kmp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#manacher"><span class="nav-number">6.</span> <span class="nav-text">manacher</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入一堆三角形，相连的三角形形成一个岛，求有几个岛"><span class="nav-number">7.</span> <span class="nav-text">输入一堆三角形，相连的三角形形成一个岛，求有几个岛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用两个栈实现一个队列"><span class="nav-number">8.</span> <span class="nav-text">用两个栈实现一个队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道-号表示，两球碰撞之后会消失，求所有碰撞时间。"><span class="nav-number">9.</span> <span class="nav-text">给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道 -号表示，两球碰撞之后会消失，求所有碰撞时间。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车"><span class="nav-number">10.</span> <span class="nav-text">一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标"><span class="nav-number">11.</span> <span class="nav-text">一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带括号的字符串压缩"><span class="nav-number">12.</span> <span class="nav-text">带括号的字符串压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中缀转后缀"><span class="nav-number">13.</span> <span class="nav-text">中缀转后缀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#来一个死锁！"><span class="nav-number">14.</span> <span class="nav-text">来一个死锁！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据流的中位数"><span class="nav-number">15.</span> <span class="nav-text">数据流的中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树中两点间路径的最大长度"><span class="nav-number">16.</span> <span class="nav-text">二叉树中两点间路径的最大长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树中最大路径和"><span class="nav-number">17.</span> <span class="nav-text">二叉树中最大路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树转双向链表"><span class="nav-number">18.</span> <span class="nav-text">二叉树转双向链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lca"><span class="nav-number">19.</span> <span class="nav-text">lca</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#应用"><span class="nav-number">19.1.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树上倍增"><span class="nav-number">19.2.</span> <span class="nav-text">树上倍增</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树链剖分"><span class="nav-number">20.</span> <span class="nav-text">树链剖分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCT"><span class="nav-number">21.</span> <span class="nav-text">LCT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#赛马问题"><span class="nav-number">22.</span> <span class="nav-text">赛马问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#滑雪问题"><span class="nav-number">23.</span> <span class="nav-text">滑雪问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线段树"><span class="nav-number">24.</span> <span class="nav-text">线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#区间最大子段和"><span class="nav-number">24.1.</span> <span class="nav-text">区间最大子段和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#扫描线"><span class="nav-number">24.2.</span> <span class="nav-text">扫描线</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？"><span class="nav-number">25.</span> <span class="nav-text">依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eco_oodt</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"oodtoodtgithub"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  














  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("9nyYGut00EwMsBkAM79MHdVT-gzGzoHsz", "S2d0pfqMODa7ipkySemFGTdl");AV.useAVCloudUS();</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
