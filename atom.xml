<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oodt&#39;s blog</title>
  
  <subtitle>自杀之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://oodtoodt.github.io/"/>
  <updated>2020-07-29T09:01:23.756Z</updated>
  <id>http://oodtoodt.github.io/</id>
  
  <author>
    <name>eco_oodt</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码相关</title>
    <link href="http://oodtoodt.github.io/2020/07/20/%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/"/>
    <id>http://oodtoodt.github.io/2020/07/20/%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/</id>
    <published>2020-07-20T02:16:00.000Z</published>
    <updated>2020-07-29T09:01:23.756Z</updated>
    
    <content type="html"><![CDATA[<p>代码相关。</p><a id="more"></a><hr><h1 id="小tip"><a href="#小tip" class="headerlink" title="小tip:"></a>小tip:</h1><ul><li>很多操作时带了getData和setData的，比如如果你从一个Proveider里面取出一个内容，你几乎必然立刻把取出来的这个内容用setData扔进ctx里，文中很多地方没有写ctx相关的内容，并且以后也不打算写。因为ctx无非就是个中间变量，我们取出来，放进一个方便使用的ctx里而已。</li><li>provider设计模式的核心概念是入口程序将某个对外提供的服务接口转嫁到不同的provider去实现,而被选择的provider并不是通过继承服务接口去实现服务,而是通过另外的独立的继承途径去实现.相比接口继承实现模式,provider模式提供了更多的可扩展性和灵活性.</li><li>数据存在ctx里，这个ctx全名OperationContext操作上下文，可以setData(把指定的数据类型的数据存进去，还可以getData取出来)</li><li>封装了流式操作，用ExecutorFactory。(表示链接在一起的步骤链，将按注册顺序执行，如果需要，可以返回最后一步结果的Future，以便与vertx正常链接（compose/map 链接）)</li><li>ValidationUtils中的valitdate是用来确认是否实现了validatable接口，然后根据这个接口来判断新的错误(两层thorw吧应该就算)</li><li>注意waitfor可能有多种实现，看到逗号分隔的式子时先看前面的waitfor之类的参数<br>比如一个参数的是操作本身<br>两个的话第二个会收到第一个的返回值</li><li>waitif和thenif的最大区别时wait的实现是异步的，而then是需要等待的（同步的），我看代码的时候没有特别在意这一点，可以回过头来最后研究一下同步和异步的关系，最后补充进笔记中。<br>我又重新看了一遍executor,感觉非常奇怪，既然写了wait，那么应该是要等待前面的那个执行完成的。<br>所以这里的异步大概可以理解为都是注册了回调的future，然后异步的和其他的东西一起跑，比如说场景和角色、怪物等等。跑到需要同步的地方就会等待前面的异步都执行完，然后进入队列最后再扔回异步里，当然这个过程应该是放在vertx里的，我回头问一下苏老师我这样的理解是不是正确的吧。</li><li><del>经验总结的话，失败是Future.succeededFuture()，有点…有点奇怪。</del></li><li>recover是直接变化前面的future状态！！懂了吗，前面的状态！因为可以获得一个cause，所以在特定的Exception的情况下，可以交给logger让他记录一下，future改成一个succeededFuture，如果没有记录就是正常跳出，仍然变成一个failedFuture！<br>这是个特性，可以用来跳过一些判断，比如有一个「如果登陆失败，应当作无事发生」，就可以logger一下，但是仍旧当作succeed继续跑。</li><li>所有accountProvider.xxx()的操作都是数据库操作。</li><li>有一说一，很多函数（方法）大量出现，要找到规律（即用法）和不太相同的注释。有一点问题是我每次都不写接口或者类，只写调用的方法名，其实有些难理解的，比如上一条tip提到的，如果写出来的话会好很多。<br>//TODO+1</li><li>fireAndForget:发后即忘，发送方和接收方彼此隔离。不会阻塞地等待消息</li></ul><hr><h1 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h1><h2 id="authAnonymous"><a href="#authAnonymous" class="headerlink" title="authAnonymous"></a>authAnonymous</h2><p>第一个中函数，create a session在服务器上或者创建一个新的账号，这个账号还会和B.net账号link。<br>首先都在Executorfatory上做</p><ul><li>先验证error各种null/empty的情况</li><li>找到账号。若无则创建一个，创建用createAnonymousAccount</li><li>检验该账号是否被ban</li><li>若无B.net账号，创建一个(匿名anonymous的)<ul><li>检查一下创建的sessiondetail，然后加进ctx里，顺便给ctx里的account赋一下这个bnetA</li></ul></li><li>更新账号link(link,devices)</li><li>更新gld版本</li><li>生成session</li><li>//==sujun==//session存到redis中<ul><li>用sessionprovider.saveSession，需要把session转为SessionCacheInfo</li></ul></li><li>run()</li></ul><h2 id="authFirstParty"><a href="#authFirstParty" class="headerlink" title="authFirstParty"></a>authFirstParty</h2><p>出现了不认识的authFirstParty</p><p>然后这个throws好恐怖啊<br>我就是想知道这个validate到底是确定什么jb的。</p><p>auth+GameCenter/GooglePlay/Gplus/Kakao/Nintendo<br>都用到了authFirstParty，长得都一样，用到函数的参数不太一样，后面提。</p><p>link+GameCenter/GooglePlay/Nintendo<br>用linkFirstParty，在自己信息的基础上，还要3个String bnet账号/密码/登陆token<br>作用是link a user with credentials</p><p>linkBnet不同，是用linkBnetMasterAccount，还要带gamesenter/googleplay/nintendo的参数</p><p>linkForce+GameCenter/GooglePlay/Nintendo<br>用linkForceFirstParty，同上</p><p>linkForceBnet同上，多两个异常判定</p><p>Force：发生冲突时，通过将账号与提供的用户id关联解决。<br>与第一方关联的所有外部账户从源账号转移到目标账号<br>Bnet account 和 两个blades account link，解决了选择账号</p><hr><h2 id="refershToken"><a href="#refershToken" class="headerlink" title="refershToken"></a>refershToken</h2><p>ExecutorFactory起手。<br>userinfo gldversion判断空<br>token必须经过2/3的生命周期才可以refresh，容易倒推得：tokenExpirationSeconds是应当死亡的时间（token到期时间） - 1/3 * 已经存活的时间 &lt; 当前时间，则报错too soon（说明还没到2/3存活时间）<br>accountProvider.requireAccount，扔给ctx（上面也有过，就是找到账号）<br>处理账号link问题<br>获取Bnet权力，避免一直refresh而获得不到的情况<br>更新ban状态<br>更新gldversion</p><p>refreshSession，注意<br>生成session如果gld是新的,避免token带有旧版本gld<br>//==sujun==<br>session存到redis</p><hr><h2 id="createAnonymousAccount"><a href="#createAnonymousAccount" class="headerlink" title="createAnonymousAccount"></a>createAnonymousAccount</h2><p>创建一个匿名Blades账号。会创建一个匿名B.net账号然后link到blades账号上</p><p>好，爷又不会了。就离谱，我才反应过来这里的大部分东西都是接口变量，那他到底用谁的实现呢。<br>上面根本找不到就离谱。<br>上面找到的是ctx，ctx就算资源的一种了，那再想知道是谁在调用根本就是天方夜谭，怎么会有这种设计<br>我再想想。<br>可能就是不想让人知道是谁在调用吧，很成功.jpg。用的人必须注意不能用错。<br>这里有一个奇异的设计，就是用list来存某一个数据，对，是一个数据。叫ExternalAccountId</p><p>fireAndForget现存的用到的地方有些有限，存疑。</p><hr><h2 id="tryCreateAnonymousBnetAccount"><a href="#tryCreateAnonymousBnetAccount" class="headerlink" title="tryCreateAnonymousBnetAccount"></a>tryCreateAnonymousBnetAccount</h2><p>试图创建匿名Bnet账号<br>调用CreateAnonymousAccount函数<br>这里问题又来了。<br>还是一样的该死的问题，为什么用接口变量.函数?那么用的到底是哪个函数？<br>懂了，全都是在初始化的时候干的，这就是接口的用处了。根据初始化时候使用的变量来调用。</p><p><del>里面有个future.recover，文档写的是「返回另一个future的结果来处理这个future的失败」，里面是出错(logger.error)的时候返回了succeededFuture(null)，外面用的是e-&gt;Future.failedFuture(e),老实说，存疑吧。</del><br>（后面注释是失败也当无事发生，意思就是创建会做，控制一下返回值。<br>懂了，写在tip了。</p><hr><p>很关键，被苏老师强调的函数。<br>FirstParty翻译待定/甲方、第一方/首次参与（大概率前者），这里用第一方翻译。</p><h2 id="authFirstParty-1"><a href="#authFirstParty-1" class="headerlink" title="authFirstParty"></a>authFirstParty</h2><pre><code>在由第一方凭据标识的用户的后端服务上创建会话</code></pre><p>直接executorfactory</p><ul><li>先确认error</li><li>waitfor Validate signin details</li><li>waitfor 取blade账号(account),用associated的第一方账号<ul><li>从ctx中取出externalAccountId(用一个waitfor赋给后面的操作)<ul><li>用id检查账号不存在/创建被禁止 跳error</li><li>account放进ctx</li><li>//===add By Sujun<br>区分账号的类型是Gplus还是kakao（否则设空？）</li></ul></li></ul></li><li>waitif 处理账号link问题</li><li>waitif 处理ban问题</li><li>waitfor 登陆BNET账号，失败也当无事发生(这里就是recover,控制一下返回值)</li><li>如果找不到account，尝试通过master buid找到ExternalAccountId(bnetid)，反向找到account(如果存在这样的联系的话，即第一方凭据绑定bnet master buid，这个id绑定一个存在的account)，注意到取不出来(没有这种联系)或者登陆失败都会返回一个Future.succeededFuture()<br>这里没有做处理，我感到奇怪。</li><li>3 * waitfor 更新账号状态（创建如果需要(应该就是之前的处理了),更新link，更新devices</li><li>2 * waitfor 获取权限（获取Bnet权力），增加ea资格:master account(tryUpdateAccountEntitlement)、early access</li><li>waitfor 更新gld</li><li>//===Modified by sujun sessioncache更新</li></ul><hr><p>吐槽:怎么函数变得一个比一个长了…</p><hr><h2 id="tryProvideReceiptEarlyAccess"><a href="#tryProvideReceiptEarlyAccess" class="headerlink" title="tryProvideReceiptEarlyAccess"></a>tryProvideReceiptEarlyAccess</h2><p>提供early access entitlement基于receipt（订单)</p><ul><li>确认有ios receipt且处于gating</li><li>ExecutorFactory启动</li><li>waitif get entitlements associate to account(如果玩家无master且无联系)</li></ul><p>以下大量recover警告！</p><ul><li>waitfor get 绑定在receipt的下载id<ul><li>如果已经有了gating early accss,无需check，return succeedFuture(new AppleDownloadIDResult(null,false))</li><li>否则用appleReceiptProvider.getDownloadId(receipt).recover，后面就是神奇的recover</li><li>我懂了，就是如果是服务器请求Apple问题的话，当作无事发生继续运行。</li></ul></li><li>waitfor 检查备用终点(if needed)<ul><li>checkEndPoint</li><li>Logger记录一下receipt第一部分(长度11)</li><li>recover getDownloadId备用host是否连通</li></ul></li><li>waitfor 如果找到有效的未分配gate，给user entitlement<ul><li>如果gate有user了，就不给。如果空闲但是不匹配就是hack行为，不给</li><li>注意给account新增entitlementId的方式和格式，给完了recover一下。</li></ul></li><li>waitfor 如果entitlement给出了，更新gate并绑定相应user<ul><li>更新gate注意方式。最后save一下，带recover</li></ul></li></ul><hr><h2 id="linkFirstParty"><a href="#linkFirstParty" class="headerlink" title="linkFirstParty"></a>linkFirstParty</h2><p>将第一方或B.NET主帐户与经过身份验证的用户相关联。<br>凭证可能已经与另一个Blades帐户相关联。 在这种情况下，将返回冲突以及两个帐户的用户ID。<br>如果未检测到冲突，则将帐户链接在一起（blades服务器帐户和B.NET帐户），并返回合并帐户的会话。</p><p>ExecutorFactory启动</p><ul><li><p>validate * 3 确认一波信息</p></li><li><p>waitfor 确认登陆细节</p></li><li><p>waitfor 检查有无冲突问题。先用函数查到冲突的账号，id加进accountLinkresult中</p></li><li><p>waitfor fixBnetAccountStatus（检查账号link问题</p></li><li><p>waitif 无冲突，新的一层ExecutorFactory</p><ul><li><p>waitfor 取account、ExternalAccountId，向前者add audit note，saveAccount</p></li><li><p>waitfor 获取bnet session token</p><ul><li>第一个参数内:</li><li>取account，如果玩家现在有一个bnet<strong>匿名</strong>账号，设bnetSessionDetailsFuture为bnetAccountProvider.authAnonymous()</li><li>如果有一个bnet FULL_ACCOUNT，用账号密码，就用账号密码通过，空bnetLoginToken就bnetAccountProvider.loginGameAccount，否则.auth</li><li>bnet account是no_account/GAME_ACCOUNT则无link必要，session remain null(succeededFuture())</li><li>返回bnetSessionDetailsFuture.recover</li><li>第二个参数内:</li><li>验证参数中传递的凭据是否与当前经过身份验证的帐户（currentMasterBuid）相同的Bnet帐户。用Account.findExternalAccountId()和bnetSessionDetails.getMasterAccountBuid()</li></ul></li><li><p>waitif 用external account credentials登入Bnet game account，if gameAccountLoginexecutor!=null，.run().recover()即可</p></li><li><p>then 确认第一方账号没有link到不同的bnet master account中。<br>事实上就是用当前ctx中的BnetSessionDeatils(中间轴件)与取出来的Account.findExternalAccountId的Master accountbuidid比对一下。</p></li><li><p>waitif <strong>link game account if required</strong>.总是required，不过bnet不允许link匿名account into game account，另外可能因为服务失败一直无法创建bnet</p><ul><li><p>if 检查各项需要的:selected_session_details,!isBnetAnonymous(),BnetSessionDetails,getMasterAccountBuid</p></li><li><p>selectedSessionToken=((BnetSessionDetails) ctx.getData(SELECTED_SESSION_DETAILS)).getSessionToken</p></li><li><p>rejectedSessionToken=BnetSessionDetails.getSessionToken</p></li><li><p>linkResolveGameAccount(Link a game account with a master account. Force keep the game account identified by the selected session token.)</p></li><li><p>最后保存session details</p><p><del>如果你仔细看，就知道这里就有了SELECTED_SESSION_DETAILS和bnetsessiondetail的区别了,hhh</del></p></li></ul></li><li><p>then <strong>add audit note确认账号已link，更新bnet account state</strong></p></li><li><p>waitfor <strong>Commit link to Blades account提交link</strong> updateAccountLink（这里很奇怪，因为经验是之前都会绑定和device一起update）</p></li><li><p>waitfor <strong>Get entitlements from BNET (works only if user has master account)</strong> BnetAccountManager.tryUpdateAccountEntitlement（即获取权限，或者说获取Bnet权力）</p></li><li><p>waitif <strong>Refresh刷新 the login token</strong> bnetAccountProvider.getLoginToken</p></li><li><p>then <strong>generate生成 session</strong> authenticationHandler.generateSession;accountLinkResult.setSession(session);accountLinkResult.setLoginToken(loginToken);</p></li></ul></li><li><p>then ()-&gt; accountLinkResult</p></li><li><p>run()<br>(后面主要是调用不同的接口了，没有什么很迷惑的地方，我就直接贴了。)</p></li></ul><hr><h2 id="linkBnetMasterAccount"><a href="#linkBnetMasterAccount" class="headerlink" title="linkBnetMasterAccount"></a>linkBnetMasterAccount</h2><p>link a master Bnet 账号和一个已认证过的用户。我们希望用户有一个game/anonymous account linked to blade account。<br>如果用户有第一方游戏账号，客户端提供第一方credentials以使我们获得游戏账号session token for linking resolve<br>可能credentials已经被另一个账号绑定，冲突会返回二者的id<br>无冲突就link，返回session。</p><p>斜体表示和上面不同的<br>BetAccountStatus有这几种：<br>NO_ACCOUNT：没有和blades account绑定的account<br>ANONYMOUS：blades account 和一个匿名B.NET account link<br>GAME_ACCOUNT：blades account和一个external(外部?)B.NET game account link<br>FULL_ACCOUNT：blades account和一个master B.NET account、一个或更多的game account link</p><p>ExecutorFactory启动</p><ul><li><p>validate * 3 确认一波信息</p></li><li><p>waitfor 确认登陆细节</p></li><li><p>waitfor <strong>检查有无冲突问题</strong>。先用函数查到冲突的账号，id加进accountLinkresult中</p></li><li><p><em>wait if <strong>如果冲突，set login token</strong> bnetAccountProvider.getLoginToken().recover()</em></p></li><li><p>waitfor fixbnetAccountstatus</p></li><li><p>waitif 无冲突，新的一层ExecutorFactory</p><ul><li><p>waitfor 取account、ExternalAccountId，向前者add audit note，saveAccount</p></li><li><p>waitfor 获取bnet session token</p><ul><li><p>第一个参数内：<em>直接返回，无需用bnetsessiondetailfuture做recover</em></p></li><li><p>取account，如果现在有一个bnet匿名账号，return .authAnonymous</p></li><li><p><em>如果是一个game_ACCOUNT，则按传进来的平台扔loginGameAccount()</em></p></li><li><p>其他情况均succeededFuture，<del>值得一提的是，这里的注释和之前一样，但是实际代码有些区别。</del>后面的注释就正确了。</p></li><li><p>第二个参数内：</p></li><li><p><em>这里直接赋值给了selected_session_details，没有其他的任何操作。而linkFirstParty却是先判定null，中间还有个throw，最后才赋值。</em></p></li></ul></li><li><p>waitif <strong>link game account if required，仅当user当前有master account时运行</strong> <em>区别是没有recover</em></p></li><li><p>then <strong>add audit note确认账号已link，更新bnet account state</strong> 完全一致</p></li><li><p>waitfor <strong>Commit link to Blades account提交link</strong> 完全一致</p></li><li><p>waitfor <strong>Get entitlements from BNET (works only if user has master account)</strong>  完全一致</p></li><li><p>waitfor <strong>由于可能更改了session details，需要generate 新的login token</strong> getLoginToken.recover</p></li></ul><p>  <em>区别：不用ctx里的selected_session_details，而是用ctx的bnetsessiondetails</em> 老实说我不知道搞这种活有什么用</p><ul><li><strong>generate session</strong> 完全一致</li><li>run</li></ul></li><li><p>then ()-&gt;accountLinkResult</p></li><li><p>run</p></li></ul><hr><h2 id="linkForceFirstParty"><a href="#linkForceFirstParty" class="headerlink" title="linkForceFirstParty"></a>linkForceFirstParty</h2><p>将给的用户和外部账号link。发生冲突时，通过将账号与提供的用户id关联解决。<br>与第一方关联的所有外部账户从源账号转移到目标账号<br>Bnet account 和 两个blades account link，解决了选择账号</p><p>ExecutorFactory启动</p><ul><li>validate * 3</li><li>then <strong>一个可用的buid required to perform a first party link</strong> validateBuid(userInfo)</li><li>waitfor <strong>Validate signin details</strong></li><li>waitfor <strong>检查冲突问题</strong> <em>不同之处在于这里如果没有冲突账号会throw error”FIRST_PARTY_LINK_NO_RESOLVE_REQUIRED”，否则存下冲突账号</em></li><li>waitfor fixbnetAccountstatus</li><li>waitfor <strong>获取bnet session token</strong> 这里和linkFirstParty几乎一模一样，区别是<em>当遇到no_account/game_account时， “throw an error as these are invalid states”</em></li><li>waitif <strong>登入BNET游戏账号if using 第一方credentials</strong> gameAccountLoginExecutor.run</li><li>then <strong>接上</strong> accountForceLinkHandler.setup 第一个参数是target，第三个是source。初始化就是第一个用ctxAccount，第三个用刚才存下的冲突Account</li><li>waitfor * 2 <strong>save audit notes to both accounts</strong> saveAccount把刚才那俩都给存起来</li><li>waitfor <strong>把source的account links转移到target中</strong> transferExternalAccounts()，后面遍历link挨个存到数据库里</li><li>waitif <strong>Link B.NET accounts if required</strong> if shouldlink，linkResolveGameAccount.这里的link和正常的link区别是判断特别少，取双token也是从目标和源各取一个sessiontoken，建议自己对比一下。</li><li>waitfor * 2 又更新一遍数据库….”<strong>Save our updated accounts in Dynamo DB now that the B.NET account has passed</strong>“</li><li>waitfor <strong>Get entitlements from BNET</strong> target的，其他一致</li><li>waitfor <strong>Update the gld version of target(kept) account with the source(ditched) account’s GLD version if it is newer</strong> 说白了用目标往源里更gld（注意顺序吧</li><li><strong>Refresh the login token</strong> 完全一致，这里就用的ctx了</li><li><strong>Generate session for selected account</strong> 如注释。</li></ul><hr><h2 id="linkForceBnetMasterAccount"><a href="#linkForceBnetMasterAccount" class="headerlink" title="linkForceBnetMasterAccount"></a>linkForceBnetMasterAccount</h2><p>找茬开始了</p><p>这里就不写流程了，直接找不同。</p><p>前面一样</p><ul><li><em>在get b.net session token的时候，如果获取到的是game——account，3检查。最后如果是full、no则throw</em></li><li><em>不需要gameAccountLoginExecutor.run()</em></li><li>transfer都一样，之后就出现了区别<em>会存了之后再link bnet，而之前是先link再存</em></li><li><em>refresh the login token的时候没有判断，不是用SELECT而是用ctx.BnetSessionDetails</em>注释写道:<strong><em>Since we might have changed our session details we need to generate a new login token</em></strong>这里倒是跟之前那个一样。</li></ul><hr><p>fixBnetAccountStatus<br><strong>此方法处理account验证是否时可用的bnet state，fix it if necessary</strong></p><ul><li>取externalAccountId(betn_master_account)</li><li>检查BnetAccountStatus.GAME_ACCOUNT是否等同于account.getBnetAccountStatus且有externalAccountId<ul><li>如果等于，就说明是FULL_ACCOUNT，account.set，.addaduitnote。</li><li>return accountProvider.saveAccount</li></ul></li><li>return succeededFuture(account)</li></ul><hr><p>checkLinkingConflictOrProblems</p><p>ExecutorFactor.create()</p><ul><li>waitFor()</li><li>waitFor()</li><li>then<br>欠债ing</li></ul><hr><p>苏老师可真是出了个大难题<br>看Executor的代码<br>Executor通常由空Factory进行动作，实际由实现了Executor这个接口的BaseExecutor进行动作。<br>其中，通过一个<code>List&lt;ExecutorStep&lt;?&gt;&gt;stepList</code>进行步骤安排。ExecutorStep是实现了Validatable的抽象类，自带一个<code>&lt;TResult&gt;</code>作为这个步骤返回值的类型，核心是apply，意义是执行当前步骤或以前一步骤的值作为参数执行当前步骤。代码逻辑的核心是给previous.setHandler<br>.setHandler:<br>失败则给当前future继承fail(p.cause())，成功则用抽象方法apply = executeStep(previous)，trycatch一下，然后把当前的future绑定到apply上。<br>返回当前future</p><p>核心就是executeStep，有多种实现，分别对应比如链步骤、等待步骤等6种。</p><p>说白了就是在每两个Future中间插进一个apply来完成不同种类的Executor动作，比如Waitif。即使只有一个要插在前面一个apply。<br>以waitstep的实现举例，给定previous(就是当前future)，若无waitstep建立一个TPrevious变量，其值为previous.result()，返回waitStepWithPrevious执行此值，否则执行waitstep<br>推翻了我的结论，令我感到困惑。且不管‘异步步骤’这个类，为什么作为.sethandler(a)，a是previous？明明handler后面是要等待前面的future完成后才会跑的。<br>回过头看BaseExecutor的run过程，发现先给出chainIterator，while next,nexeStep=Iterator.next()，尝试确定可行性后就是current=nextStep.apply(current),current=null就直接apply。</p><p>这样就好了，无参数即run序列的Chain中第一个，执行的是executeStep(null).<br>make sense。即apply执行一个null的future(虽然不知道能不能，能跑就行.jpg)跑完了就可以直接跑第一个序列了。<br>第二个时，第一个和第二个是相关联的，此时apply是executeStep(previous)，即取的第一个执行完的future的future，第一个跑完了、完成了apply，就可以跑第二个了。刚才困惑是以为executeStep里绑定的是当前future。</p><p>有了上述内容就可以看waitif、waitfor和then了<br>双参数和三参数本质没有区别，三参数执行WaitWithCallbackStep，双参数执行WaitStep<br>waitif(condition,operation):新建变量<code>stepToexecute=new WaitStep&lt;Void,Tresult&gt;(opertion)</code>,waitStepWithPrevious = opertion<br>stepList里add <code>ConditionalStep&lt;TResult&gt;(condition, stepToExecute)</code></p><p>然后其实ExecutorStep是用不到的，用到的是它的子类的子类们。比如第一层子类BaseConditionalStep，第二层ConditionalStep，其核心逻辑很简单，super(condition),this.step = step.第一层则会用不同的方法实现executeStep，先检查condition，如果有则先执行condition，然后根据这个bool判断是否执行下一步。注意即使是条件没过，也可以继续执行。</p><p>嵌套层数过多，需要画图。</p><p>不过我已经懂了。现在来看.then<br>我们需要的是带previous的版本，ChainStep。现在我们有前面一个future和当前的future，现在run。<br>由于apply只是个外部的临时变量，所以不会在list里面，current就是之前的里的，nextStep就是.then。<del>先给出前面的值，.result()，result作为结果量，.complete(连带着参数从.then传进来的（之前的值）作为参数跑，</del>注意nextStep用的是ExecutorStep，所以要用对应的apply，当然，会用对应的executeStep。<br>给前面的future.setHandler()，中间量apply是executeStep执行出参数的future值，<del>apply执行完就可以跑当前的future啦。</del><br>apply根本就不是什么中间量，而是用当前future的结果执行下一个Step的future！于是说ret才是个空值，那么有人会问为什么return ret？</p><p>我也不懂啊！断点走起来</p><p>懂了 大佬给future都重写了一遍，绑定了mdcHolder，你看到的那个就是默认的空future，</p><p>setHandler也改过了，经过一番难以言喻的函数，本来里面是个{Future{unsolve}} 就变成了 {Future{result=null}}</p><p>正常的经过sethandler就可以变成result=null，而且也会走正常流程，sb的就直接过去了，step into进不去我人傻了。</p><p>进去了，走waitstep</p><hr><p>以下用到provider用p.代替，用到detailsprovider用dp.代替<br>Guild用G代替<br>Details用D代替<br>Cache=Ca<br>And=A<br>update=u<br>guild=g<br>response=res<br>require=req<br>Member=Mem<br>Message=mes<br>master=mas<br>Characters=Ch<br>Collection=Co<br>validate = v<br>Applications=App</p><p>GP是连接bnet/snqu<br>而GDP是连接数据库的<br>applications - 申请<br>response分有无current两种<br>有current：Details、members、application<br>response的组成:details、members、是否超出最大申请数</p><p>Guild - Controller<br>很明显的可以感受出来，这边就是把各种方法结合在一起实现某种功能，大部分接口都是Provider或者什么实现出来的。</p><ul><li>getGuild 用提供的guildID</li></ul><ul><li>p.requireGuild() 取得工会</li><li>getGMemWithUserIds 添加成员</li><li>p.getApplicationCount</li><li>dp.getGuildDetails</li><li>GuildResponse()</li></ul><p>getCurrentGuild<br><strong>如果玩家在guild里就返回公会成员列表，否则返回此玩家的公会申请//如果被ban了，则返回一个APPLIED的申请但是对工会不可见</strong></p><ul><li>p.getCurrentGuild</li><li>dp.getGuildDetails</li><li>取得成员</li><li><strong>如果找到了guild，立刻创建guild response</strong></li><li><strong>如果找到，检查此玩家是否有申请</strong> gP.getCurrentGApp()<ul><li>无申请，response设一下</li><li>有，还大于1，warn一下，返回第一个</li></ul></li></ul><p>updateGDACa<br>尝试在DB中对GD进行多次读-更新-写操作,用的操作很奇怪，FutureUtils.executeWithRetries(,gdp.uGD,responseRef::set)<br>gP.uGDCa</p><p>leaveG</p><ul><li>判断是否为Grandmaster</li><li><strong>获取玩家的rank</strong>reqGMem</li><li><strong>保证guild PVP score更新完成，Grandmaster影响这个更新</strong></li><li><strong>给Grandmaster找下家</strong></li><li>gMesBoardP.postMes()</li><li>deleteUserGExchanges</li></ul><p>grandMasLeaveG</p><ul><li>会内无人</li><li>会内仅1人候选</li><li>会内好多人候选</li><li>getGMemWithUserIds()-&gt; addall(),找到所有等级最高的成员</li><li><strong>如果会内无人，则删掉guild，不过不删掉guild message board，方便可能的会话</strong></li><li>一人直接给</li><li>多人，找到pvp奖励最多的人中资历最老的成员</li><li>给此人权限，让原会长leave。</li></ul><p>uGrandmasSince<br><strong>更新会长任命时间戳</strong></p><p>uGpvpTrophiesOnGmLeave<br><strong>保证guild pvp score更新完成。和grandmas时间戳</strong><br>与上面的区别在于会取一个gpvpT…handler.removeGMem</p><p>uGpvpT…Onleave<br>与上面的区别是不需要更新会长任命时间戳</p><p>getGMemWithUserIds</p><ul><li>gP.getGMem</li><li><strong>bnet 返回只含buid，我们必须加进userid</strong>     aP.getAIds()</li><li>通过map映射添加</li></ul><p>deleteuserGExchanges<br><strong>删除guild exchanges(交流?交换?交易?)</strong></p><ul><li>cP.getCh</li><li>为该玩家的每个角色都删掉GExchanges</li></ul><p>searchG</p><ul><li>gSearch.setLimitMax</li><li>gSearch.setNameATagWithSeparator(?)</li><li><strong>这是唯一用到BNET中的guildDetails的地方，其他的都用数据库的内容。（存在缓存主要是为了允许对其字段进行自定义字段搜索，但是可以在搜索结果中显示它）</strong> gP.searchG</li><li>GCoRes</li></ul><p>kickUser<br><strong>封装了从系统中踢出一个用户，增加了目标buid不正确时恢复的功能</strong></p><ul><li>Function = gP.deleteGMem</li><li>执行动作with成员解决方法(?)</li></ul><p>banUser<br><strong>封装了从系统中ban一个用户，增加了目标buid不正确时恢复的功能</strong><br>与上者不同的就是gP.banUser</p><p>vUGReq<br><strong>确认更新guild的request</strong><br><em>放一放，一会看</em><br>先看request类型是否是AdminUGReq，不是的话就要后面做侮辱性语言检查，称做亵渎检查<br>确认guild 名称、短描述和长描述问题<br>…亵渎检查长短描述。</p><p>getGMemSlotsLeft<br><strong>G中还能加入多少成员(插槽)</strong></p><ul><li>guildGLD.getMaxMem-gP.getGMemCount</li></ul><p>getGGrandMasUserInfo<br><strong>检索会长的玩家信息</strong><br>取buid、通过buid取得account，然后validate一下，就可以返回了</p><p>generateTagId<br><strong>给提供的公会名生成TagId</strong><br>这里用到TagIdGenerator，看着参数搞就行</p><p>approveAsManyApplicationsAsPossible<br><strong>就跟名字一模一样的用处（</strong><br>逻辑很简单。getGApplicationsWithUserIds,getGMemSlotsLeft,然后根据申请日期给申请排序，遍历所有申请每次容量-1，如果无位置剩余就拒绝申请，有就接受，注意每次接受与否都会做两个动作:<br>gP.approve/denyApplication<br>gMesBoardP.postMes()</p><p>拒绝所有申请<br>就这么简单，比起上面不需要容量的限制，只需要遍历即可。</p><p>getGApplicationsWithUserIds<br><strong>检索该工会的所有申请</strong></p><ul><li>gP.getGApp</li><li>aP.getAccountIds</li><li>GAppCoRes.updateUserIds()</li></ul><p>reqFirstCh<br><strong>req 一个玩家的角色列表，返回第一个。</strong><br><em>Guild support only one character per user currently</em> <del>存疑，这里之后问一下苏老师</del> 问过了，一个user只有一个character</p><p>uAppOnTypeU<br><strong>依赖公会type更新申请</strong><br>type:开放、需要申请、关闭<br>如果之前需要申请，之后开放/关闭，按对应方式处理所有申请即可</p><p>执行动作with成员解决方法<br><strong>这个是用来解决这样一个问题的：匿名用户加入到公会中，升级到第一方后其”匿名buid”会转化为”game buid”，但是公会仍然引用匿名buid，但是很多操作因为系统使用ganmebuid而会失败。此方法通过从bnet检索行会成员列表来匹配其userid来进行用户的反向查找，而不是依赖于用户账户上的buid(第一方buid)来进行禁止/踢动作的正常工作。</strong></p><ul><li>注意recover可以用来做恢复</li><li>整体逻辑看下来，只有做recover的时候，才会用到这个反向查找。<br>这里稍稍存疑。</li></ul><p>Controller=C<br>GMan:<br>getCurrentG<br>return gC.getCurrentG</p><p>getG<br>validate之后gC.getG</p><p>createG</p><ul><li>validate非法</li><li>取徽章icon，取地区</li><li>确认名称、长短描述的长短、codepoint有无错</li><li>如果需要仓库，存取一下仓库。取下钱包</li><li>pay一下</li><li>亵渎检查（wtf，为什么先支付再亵渎检查，也无妨，后面才更新</li><li>生成tag,gC.generateTagId</li><li>取得角色</li><li>业务验证(角色是否有资格进入公会)</li><li>remove该玩家的所有guild申请</li><li>创建guild//sujun添加区域参数<ul><li>uGDOnCreateG</li><li>更新仓库钱包</li></ul></li><li>return 这个guild</li></ul><p>看完这个我觉得一个东西迫在眉睫，就是什么是character，什么是user。</p><hr><p>character</p><p>苏老师nb啊，每个character只有一个user（说反了）<br>说得通说得通。<br>这样很多逻辑就很显然，甚至非常容易了。</p><hr><p>uG</p><ul><li>validate参数非法</li><li><strong>需要获取当前guild来得到guildid、gmesboard的准备信息</strong><ul><li>gP.reqCurrentG 此时有oldGuild和update的req</li><li>gC.uAppOnTypeU (就是根据type更新申请)</li></ul></li><li><strong>更新guild和其details，然后postmessage</strong><ul><li>gP.uGWithoutName</li><li>uGDOnUG</li><li>gMesBoardP.postMes()</li></ul></li><li>return ugRes</li></ul><p>leaveG</p><ul><li>validate</li><li>gP.reqCurrentG</li><li>gC.leaveG</li></ul><p>kickGMem<br>逻辑就是</p><ul><li>取一堆信息:gP.reqCurrentG,gC.reqFirstCh,aP.getAccount</li><li>gC.kickUser()</li><li><strong>fireAndForget of 公会pvp分数update，使其不会干扰当前call</strong> fireAForget</li><li>gMesBoardP.postMes</li><li>gC.deleteUserGExchanges</li></ul><p>banUser()<br>改中间函数即可</p><p>searchG<br>validate后gC.searchG</p><p>getGApp<br>validate,gP.reqCurrentG,gC.getGAppWithUserIds()</p><p>joinG<br><strong>加入不需要申请的公会</strong></p><ul><li>validate</li><li>cP.getCh</li><li>检查加入的公会是否存在(名字如此，检查的却是最大值)</li><li><strong>remove该玩家的所有申请</strong></li><li>gP.joinG()</li><li>fireAForgetUGPvpTrophiesOnJoin</li><li>gMesBoardP.postMes</li></ul><p>applyG<br><strong>注意申请也是有上限的</strong></p><ul><li>validate</li><li>cP.getCh</li><li>gP.getGAppCount</li><li>确认最大值</li><li><strong>reomve该玩家所有申请</strong></li><li>gP.applyG</li><li>aP.getAccount</li><li>app.setUserId</li><li>return net GAppRes(app)</li></ul><hr><p>approveApp</p><ul><li>validate+三连(gP,aP,gC取当前G，当前Account，Ch)</li><li><strong>取出还有多少空位(slots)</strong><br>gC.getGMemSlotsLeft</li><li><strong>如果无空位此时denyall</strong></li><li>gP.approveApp</li><li>fireAndForgetUGPvp…</li><li><strong>post 批准</strong></li><li><strong>批了之后满员也denyall</strong></li><li>response</li></ul><hr><p>denyApp<br>欠债ing</p><hr><p>明日规划：inventory-market-fulfillment-<del>globalshop</del>-characterManager-<del>shop</del><br>建议先看shop</p><p>关于guild-s2s</p><hr><p>今天我必整理格式</p><hr><h1 id="shop"><a href="#shop" class="headerlink" title="shop"></a>shop</h1><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>Speical = Sp(sP=shop provider)<br>get = get<br>generation/generate = g<br>Shop = S<br>character = ch<br>catalogs = ca<br>Handler = H<br>Response = Res<br>request = req<br>Provicder = P<br>Purchase = Pur<br>invnetory = i<br>wallet = w</p><h2 id="各项内容含义"><a href="#各项内容含义" class="headerlink" title="各项内容含义"></a>各项内容含义</h2><h3 id="catalogs"><a href="#catalogs" class="headerlink" title="catalogs"></a>catalogs</h3><p>id,templateId,<br>bundles:catalogs包含的包的列表,经过确认，这里只包含数量，价格是在购买的时候从gld里获取的。<br>wallet:卖家用来买玩家的资源(?我怀疑写反了，就是玩家的各种资源和货币的类)<br>start,expirations:起止时间</p><h2 id="getSpS"><a href="#getSpS" class="headerlink" title="getSpS"></a>getSpS</h2><p><strong>取得sp shop，生成必需的catalogs</strong><br>用到:SpCaGH<br>chP,sP,caP</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li>validate参数</li><li>cP.getCh</li><li><strong>get sp S or create it</strong><br>sP.getSpS<ul><li>如果不存在 Sp.createDirty()</li></ul></li><li><strong>get all ca 当前与shop关联</strong><br>cP.getCa</li><li><strong>清理过期的ca</strong><br>SpCaGH.clean</li><li>生成新的sp offer ca<br>cP.createCa -&gt;<br>ca.addAll(),s.addCa()</li><li>SpSRes()</li></ul><hr><h2 id="getShop"><a href="#getShop" class="headerlink" title="getShop"></a>getShop</h2><p><strong>get 一个或者生成一个</strong><br>CommonH townH = new CommonH<br>buyback<br>CaGH  </p><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ul><li>区分需要生成ca和不需要生成且连接用户不是shop拥有者</li><li>sP.reqS,getBuybacks</li><li><strong>如果Ca不为null,取cP.getCa，否则说明shop刚刚被upgrade</strong><br>getCa,设一下Ca</li><li><strong>ca需要生成的场景：1.过期。2.build gets upgraded，town manager reset shop ca</strong><br>两种的话处理是类似的，都要用tP.reqTown取一下城镇设一下TownBuilding，cP.createCa，然后Shop.reset,Shop.setCaId,设一下Ca最后sP.uS</li><li>如果”不需要生成且连接用户不是shop拥有者”，sP.getS,用getOrCreateSocialContactSCopy覆盖Shop，注意购买执行之前不会创建数据库条目</li><li>SRes</li></ul><hr><h2 id="purSpBundle"><a href="#purSpBundle" class="headerlink" title="purSpBundle()"></a>purSpBundle()</h2><p>SpPurH<br>有个参数叫TownXP,有理由怀疑每个城镇有自己的经验。</p><h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ul><li>validate参数</li><li><strong>取出对应内容，即每次get都会setData</strong><br>cP.getCh，iP.getI,wP.getW,sP.reqSpS,sP.reqS,caP.reqCa</li><li>检查isTownXPRewarded(是否有购买会奖励XP)，如果有则取出town，tP.reqT</li><li>SpPurH.purchase(刚才取粗后来的一堆参数)</li><li>后面不写了，就是把之前取出来的东西再存回去，基本上依然是Porvider的操作，无非就是sava、update这种操作。注意Town会用一个getTownRemovedProps，最后Response会用到，character有个dirty才save的判断</li><li>SpPurRes的参数就是刚才新存的那些。</li></ul><hr><h2 id="purB"><a href="#purB" class="headerlink" title="purB"></a>purB</h2><p>socialPur = shop不是你开的 或 shop不是你开的（user和ch双重判断）<br>PurH = PurH(用来判断玩家是否支出宝石)<br>…TownXP</p><ul><li>validate，取值同上</li><li>如果不是你开的shop，sP.getS,setData(Shop,getOrCreate…)</li><li><strong>Ca只会为shop owner存在，owner shop和connect的user shop 都 link to it</strong>  </li><li>PurH.pur(一堆参数)</li><li><em>与上面的区别在于没有saveSp,而是如果shop version==0,意味着我们只是创建了其他要pur的shop的copy，需要sP.createS</em></li><li>PurRes() <em>多一个socialPur</em></li></ul><hr><h2 id="getOrCreateSocialContactSCopy"><a href="#getOrCreateSocialContactSCopy" class="headerlink" title="getOrCreateSocialContactSCopy"></a>getOrCreateSocialContactSCopy</h2><ul><li>**如果connectedUserS存在且与ownerS有相同的Ca，（ownerS没过期且没被upgrade reset），返回connectUserS</li><li>否则用ownerS的sId和caId创建一个新的s</li></ul><hr><h2 id="sellItems"><a href="#sellItems" class="headerlink" title="sellItems"></a>sellItems</h2><p>SellH<br>buybacks</p><h3 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h3><ul><li>validate</li><li>取i,w,s,ca</li><li>SellH.process()(<strong>处理出售给商店的物品清单</strong>)</li><li>buybackP.createBuyBacks</li><li>更新w,s,i</li><li>SellRes</li></ul><hr><h2 id="buyback"><a href="#buyback" class="headerlink" title="buyback"></a>buyback</h2><ul><li>我都懒得写了…一模一样吧</li><li>最后会有一个buybackP.deleteBuyback</li></ul><hr><p>成了，下一个，<br>CaOverrideM-&gt;CaOverride-&gt;?<br>怎么就no usage了</p><p>下一个</p><h1 id="GSM"><a href="#GSM" class="headerlink" title="GSM"></a>GSM</h1><h2 id="缩写-1"><a href="#缩写-1" class="headerlink" title="缩写"></a>缩写</h2><p>Manager = M<br>Global = G<br>Generate = Gen<br>Shop = S<br>Handler<br>Provider<br>Purchase<br>Response<br>Override = O</p><h2 id="pur"><a href="#pur" class="headerlink" title="pur"></a>pur</h2><h3 id="流程-4"><a href="#流程-4" class="headerlink" title="流程"></a>流程</h3><p>好家伙，上来就看到了caOverrideP::getGSOverrides,可惜，遗憾，是P，那就跟那些没太有关系。</p><ul><li>如上，load 全局s overrides</li><li>用这个overrides<ul><li>getGLD取GSProductsCaGLD</li><li>搞一个Map，是用CaOH.getActiveGSPO建的</li><li>搞一个GSProduct = GSPurH.resolveProductO</li><li>GSPurH.validateActive</li><li>setData(GSProduct)</li><li>用每个用户是否最大判断mustSavePur</li><li>TownXp也给判断一下</li></ul></li><li>如果提供了期望的价格，那么如果不匹配实际价格则拒绝购买</li><li>取角色</li><li><strong>验证是否可以从临时商品中进行购买</strong> 函数不写了</li><li>如果必须购买 gSPurP.getGSPur,then,setData(GSPur),GSPurH.validateUserQ(确认没有购买到最大值)</li><li>取i,w,xp,GSPurH.purchase</li><li>存town,i,w,如果必须买，gSPurP给一个createOrUpdate(也是更新吧)</li><li>dirty就更新角色</li><li>GSPurH.buildPurRes</li></ul><h2 id="getPur"><a href="#getPur" class="headerlink" title="getPur"></a>getPur</h2><p><strong>获取全局shop购买为那些已经有用户最大(?)或者是执行奖励的角色</strong></p><ul><li>gSPurP.getGSPur</li><li><u> 用获得的purchases,new GSPurStatusRes </u></li></ul><h2 id="applyOfferLastChance"><a href="#applyOfferLastChance" class="headerlink" title="applyOfferLastChance"></a>applyOfferLastChance</h2><p><strong>更新全局商店offer以表明它已经显示了最后机会，并且将在最后机会持续时间之后过期</strong></p><ul><li>validate</li><li>取角色</li><li><u> GSLastChanceH.uOfferExpiryForLastChance()</u></li><li>如果offer改变，saveCh</li><li><u> new GSOfferLastChanceRes </u></li></ul><p>整理笔记的时候，setData的部分记得添加一下。<br>今天爷发现了盲点，then是同步的，其他都是异步的动作，也就是我写的有些顺序是可以随便执行的，但是有些不能，我回头要把不能的全都标出来。<br>这也是整理的时候要做的事情。<br>今天晚上就可以做。<br>必须做。</p><hr><h1 id="FulfillmentM"><a href="#FulfillmentM" class="headerlink" title="FulfillmentM"></a>FulfillmentM</h1><p>这个是整个支付的系统…pass，之后看。</p><h2 id="缩写-2"><a href="#缩写-2" class="headerlink" title="缩写"></a>缩写</h2><p>Fulfill = F<br>Manager<br>Inventory<br>Wallet<br>Global<br>Shop<br>Purchase<br>Provider<br>Response<br>Request<br>Queue<br>Internal = Int<br>Character<br>Receipt = R<br>Validate = V<br>Account = A<br>Gplus全拼</p><hr><h1 id="MarketManager"><a href="#MarketManager" class="headerlink" title="MarketManager"></a>MarketManager</h1><h2 id="缩写-3"><a href="#缩写-3" class="headerlink" title="缩写"></a>缩写</h2><p>Market = Mar<br>Manager = M<br>Fulfill = F<br>Manager<br>Inventory<br>Wallet<br>Global<br>Shop<br>Purchase<br>Provider<br>Response<br>Request<br>Queue<br>Internal = Int<br>Character<br>Receipt = R<br>Validate = V<br>Account = A<br>Offer = O<br>Town = T<br>create = c</p><h2 id="cO"><a href="#cO" class="headerlink" title="cO"></a>cO</h2><p>COH</p><h3 id="流程-5"><a href="#流程-5" class="headerlink" title="流程"></a>流程</h3><ul><li>v</li><li><strong>获取城镇等级，确认market可用</strong><br>这个动作是先通过P获取需要的那个东西，比如town,或者offer,然后-&gt;{cOH.sett/setActiveO;cOH.vMAvailability/vOCount}其实就是扔进H里然后看确认内容</li><li><strong>获取活跃的o,然后确认这里有空位可用</strong></li><li>iP.getI</li><li>oP.cO</li><li>iP.uI</li><li><u> CORes.create() </u></li></ul><hr><h2 id="cancelO"><a href="#cancelO" class="headerlink" title="cancelO"></a>cancelO</h2><ul><li>v</li><li>取O</li><li>删O</li><li>取I</li><li>准备且u i</li><li>return i u result to client</li></ul><hr><p>欠债ing</p><p>明日规划 challengeM characterM SocialChM FriendM<br>非常的容易，可以多来点:支付可以搞一下，然后如果有空就把这个Presence()看一下，反正很短，把短的都干掉就好了。能干多少干多少。</p><p><span style="border-bottom:2px dashed yellow;">所添加的需要加下划线的行内文字</span></p><hr><h1 id="ChallengeM"><a href="#ChallengeM" class="headerlink" title="ChallengeM"></a>ChallengeM</h1><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><strong>取得当前challenge，必要时生成一个</strong></p><ul><li>v</li><li>cP.getCH,取得的ch用来做 ChallengeSeasonChH.uChallengeSeason</li><li>取chal，用来给chalHF.getGenChalH</li><li>取chal的配置，用来赋值</li><li>如果需要生成一个，取i,t</li><li>chalP.putChal(一堆参数)</li><li>isdirty存ch，需要生成存配置</li><li>ChalStatusRes,注意取之后要设一下下次生成时间</li></ul><h2 id="abandon"><a href="#abandon" class="headerlink" title="abandon"></a>abandon</h2><p><strong>抛弃一个活动的挑战，将不会给玩家奖励</strong></p><ul><li>v</li><li>取chal,扔给abChal,chalP.putChal</li><li><strong>生成下一个挑战的category，应该在更新挑战状态之后生成，以使我们部分失败时只影响客户端不知道下一个category是什么，也不能显示本地通知</strong>  <ul><li>取角色，chal配置</li><li>decrementChalPoolRuleCounts <strong>减少与挑战配置相关的挑战池规则计数。一个规则的计数会减少如果该规则和chal category生成同时重复。目的是让玩家在无法获得该分类(category,注意与Catalog相区别!)的新挑战时，更多的尝试为该分类生成挑战。</strong>(?)</li><li>然后生成下一个ChalCate,添加下一个Cate</li><li>saveChalConfig</li></ul></li><li><strong>我们只需要保存ch如果生成下一个挑战分类导致修改了角色(因为我们在一个新的挑战season里面)</strong><br>啰嗦一堆，判断就是dirty</li><li>AbChalRes</li></ul><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><ul><li>v</li><li>取chal</li><li>uChalH.update</li><li>return chalP.putChal</li></ul><h2 id="complete"><a href="#complete" class="headerlink" title="complete"></a>complete</h2><p><strong>完成一个挑战，会确认挑战可以被完成，奖励玩家</strong>  </p><ul><li>v</li><li>取Chal,completeChalH.complete</li><li>取ch,i,用chalRewardH.collect()准备奖励</li><li><strong>生成下一个挑战分类因为他会在切换挑战季度时修改角色。然而直到我们保存chal状态我们都不会取保存它。</strong>  <ul><li>取Chal配置，</li><li>取Chal Pool</li><li>生成下一个ChalCate，添加下一个Cate</li></ul></li><li>更新i,w,ch,chal,chal更新:chalP.putChal</li><li>saveChalConfig （写了一段跟之前一样的注释,生成下一个挑战的category，应该那段，挺奇怪）</li><li>准备res,CompleteChalRes(一堆参数)<h2 id="seasonRankUp"><a href="#seasonRankUp" class="headerlink" title="seasonRankUp"></a>seasonRankUp</h2></li></ul><p><strong>增加挑战季节的排名并提供任何相关奖励</strong>  </p><ul><li>v</li><li>取角色，确认ch可以给chal season RankUp</li><li>取i,w</li><li>应用rankup注意用到玩家是否订阅,seasonRankUpH.rankup()</li><li>保存奖励和ch<h2 id="seasonPremiumReward"><a href="#seasonPremiumReward" class="headerlink" title="seasonPremiumReward"></a>seasonPremiumReward</h2></li></ul><p><strong>提供角色的高级订阅奖励</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码相关。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/categories/java/"/>
    
      <category term="frame" scheme="http://oodtoodt.github.io/categories/java/frame/"/>
    
      <category term="vertx" scheme="http://oodtoodt.github.io/categories/java/frame/vertx/"/>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/tags/java/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
  </entry>
  
  <entry>
    <title>项目相关</title>
    <link href="http://oodtoodt.github.io/2020/07/20/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    <id>http://oodtoodt.github.io/2020/07/20/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/</id>
    <published>2020-07-20T02:16:00.000Z</published>
    <updated>2020-07-29T09:00:28.641Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">我是....？</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="31ee08225a25cc34458efd93ae2a4b6d81384e2d80e924afbc4e4889120a7add">437f4270d68a76bddf0c471be302b867863b275e263280a8ebcf190f1bf0cb790c6b87715788a1381a9f0d62fbe32ee46f68156088423e64aad1e928fffcd0cf888ff87bb8e1074d0ccaa7363b640abd6b959a68f6dd86c16857fcab98dc84e8521f0a57cc428bde30bf5e03ea8960e53109768e9e3adea0e0ec1fd1821736230a46af33f03b2ed00b5a50b2abc50f2f0ce736233b5360657822b72b23191e0dc25f6f1475b6871e65b99bfcccb49251dd24e254110937b1feb00f933791940a1eeb328cfe43188a57183110a26a6456002895d79254430b68dfc6ba9e426480adb1b46b3f14ba827df3a4294418cccc585295295b574d47e3e4894465fa82dd367b3d0280b0c7732ee8ac459b3ad1b7fdc744773a2019ae02f647c56237a62058b3e53ebd9a6eeaeabb10ce82b9fe017a4b7bf40737ff1e7c5e70fd51ce4372ce8820e47fa0322a50d28393abc84f79857036272f5399c1cf6c95bcd39d75b3d9ff8510efa4cfb3e049bee816cb9fde6a27994bef1f6293604d7ae936bb6cef84961e2652a7e01ebbcebf7849b102f745368f3f5c85207138cbb2482048f3bb1d086d03ce58933f7afcf7dfec6ed87c087e0993705343d94d5fabc0bf74cb91fad759778e9a01b4b9d07a92d3ff204011a7fd202eb67e5b6f61ece4ed37d85fac2f8d699a831d3ea00ce4e2f2b3ab70805da908d3255578b3b8fb27db0788db92bb6ee1ed99685192e91b4b30e654eeab24649680e1f71986c3f9cbc164ebc8e26a1941b0368c5a0365cdb4afb7f15425a70f650ace6fa9cfe917a5a904576c05755678cd8dd884fcef295f35acb588c0dc9ae2da04796ff422e603a1af62121f7ff5c77f97c26adf244c052f0a450908356abbc66ece5647118ab23432030fad79f38de5afb9b471ea24fb8f3996dd9f85fc866968a6e7fcdc1284e627ef61344bf6b99809084cfc678eace986d6ea0197298d8501967a857128a96fd7e1428a547d2aff4e3437924e794e0dc7d04a4656a60eb4da1fdf58948cd6b1fe6d0ea9681a80e4065776fd350016dd9c91195ef983b076365d8a5991844837ca46b7c07518cbb41031bee640153a23ca2644860220edb38969f4b289713710d4d91c078dbd49395e9a3931d6bdadd1917ddb9489bbf445ed8ce5bce5c844371861cab47ea5f4aec6daff179c7b8e1177c13abb315b2163ff4285fac2e83b3cd5fc409470776839680d2f943c61c8431d2bf21f03b934f47bee14fe2d96010882b102d56079b33a31f3fd6829241be9a846c353a2eb20fdaa7182805c96a8c5b10ff234e6b8925f5de731839a9d3403aeb22baeb29d67fd7f532fea232dd38ed7342bb1e106b6985a75ca6a1b7329ec5683531f52fb0a40ef509bf5fa55c80c0f8029daede5cac9ea8ed76d2cc056c1c46d5391925d67098dc3762af2027179331beba7917e626be3fc99bd832b1728a55a02eb626a8a1538417a2dcf36e51826f4b0069a9e9ae08d1ddf28dc4564b770bf0b10fe23b0133a7651e61f66c11d11f80021bc73bfe97e115a819b80cdc2e9f4ee9b301bf0455542e7ba5deb26c0c64e547de3045558e0994c3c0dd09ac6b6a2b9d3304ef63c09a959ed4c01baefff79fc2c2fc1aae10df3ee642cf7c833c2f66624d70462039d350f432c257c394d557bed9cea30066d5cf01a1186c8392f49ad23db0b2511c8757bdd3f3db7a5082d4aba3727c3f1f51d39079f3ddbb255fe03a73da10cfc68de8f9c02fb0ce1bfe1b9f6a52a9f9d83be03a2b65d3e18f91b74518578e04d65ec07d423ab863dac8e82c0bfded309848c26e6b825fe3f570f74c3302ee5ecf5435177c099ce831cc1fa5011bffd32d8844a0d47f3f0442ae019da9f625a1459b86fa9683e46f587eaa3139f3f77ce46992cd7cc6e9dd9f23ce765f161412940eb44a1596668ed0ac6240920706582d35a8f3b186a0c20cbbf2b69c79c12c50df61d8633c71c8a93b0523fee1c714d1321384a321b8cce97bd3ac3d9ba149d3c7514ef1b92528344cd1bae35f5a9dffe5084bb98b12e87156986235cbc0b7b8e8a1da4e6f7bd2da870df5508c98a9d53f996553e21101642350ef44535ca7c6414d68d9a26ada1ed59bf92d20e72818b42f20dada0cc805a05cc8d344b65fa6a00d121b4f41102e348d53f77e7570f3cc7819881bc28da4bafdbf3478b4a65b42de7c0ab2f1f090b99987f7c5eb904807bd2d0d49b15e8cbb768f668d33be73c25fe031d300bb2bfeeffa0350ec161bfbacfce2928dd817c0d4e3981ba4a4b611d648b56c556e2dce1fee2efed4c8a741e91dba34e4d401665da62dcb59b834cb7e68b2c816d7f6b28f3c008f133bdd2d1fc8262e1197d537a728e2334b6681f11730224136f7decc173b89e7659cb3749dc5d11480d67b58525254815e5b0ebcc6e7c326e3feec06c9956515aa94bf9d88fd4d1229f6595f8865c6782d812b494942e22b0eef4d1f4fd9c548280d2293908b364e95df3c674444f3d1d6be84949f4037106a004f0efdbf3cd5bae37158c01d5de00a7059913dc16218dabafda3e3d852e152aed58540a6b101ce9fe8aae2a5ddeb966782f7ac23d2d4c00de9d897d0cc02c98eb1739afd157f89b4fc2e06eed7625512a67b05c578958cf9455e081a35132b28c24b903477ce876882db8d32d967889bfad753214eff8803c5804a73768dbf8ddac305dbbb5b1dfc62527eb886c35076e1ac0dccbb018264f5ce06ecc4bf477adcb3d6171988350e5f358e6dde4b00d643c3450145bada78184d6c3d335af193588bbd28d31f2f034194dc9efe3c53b230c7e4745b877f6901a0e56eb8223e8729f31077ff08e95d5585617fd29db3854f52f583288fc3a20d86c64a3f5d3a0c8e154b27f8223f171fd50a58d4ed00239556117867651644c376e323f0c7ba231d0ced66dca99aacb5d2f616a848948b1d8aae742c1bba3b7d6ce8932f893433bc6cc7f6663df231d4f08e16dc93f4152e059c2cafc691df13bd44072b3f471e064c0be365a097d0c90d0922f53848f878c1c004078c90858d53dc39354f3ee1c0d76a4985afb8e2b147eea26e0e9aaef8b45e41d9520a7c14546f363cfcb1c86b289dbc657b7b7834defa0cf4950f47e78e696ecd241b58fb903bdae9673eea76f8e942507cddfb823b3a4374e7928370ef44eab8cca0a8ff8743f501ff8a5cd51875fdca7a24f64872acaeb0f7c857b93500e8a286480413de5f1e8d59ea537bd90b2e190ed7c2429037b3b8434d0a00ed7c3141f4353babe52d700a77016be1f07f3961aa08d7f162efcc8eb4849577dc274b824c6355d61fb360bbbb04eccbf6dc3a113361e912a24a3954d011a061c17dd4504a42171a726f86969a68b66823a4cc1f95d591d3ebd66a53295948927e3cc38cbd677b293bb1fb03fb2e5e0c80f8c2f5e346db922f27f85510a1ffeb449d702dc71778ad3ef384d95ba164c1087e418749793302d77cf9e80fc91dfd2ccc496b8a105ffc59255211638d2551f5e459fdf23fb45717d6a8cc1593e68412ec244339d1d9bdeee626590ce2de15e1275897d25ae885786301e02b6b75c6b605921356069f68b523de81e5a411920e6aadc0611c0d698a316cb0acec2aaa675be9a3756943211d1529e54db7fa3effd9f8326cdbad6f8063e242a5b8cc7ba775094ea23a4a8202f3ba6aa56c6b18f988384a34bf56f1db2820bbe07d137d3f0fe5b5ffb7e767594fef2fa7bf5cc9426f2c12e3ef395595de3cb7927c2763f14abdd893f8a6b16be059316cffdf106efc0b4c3a3480dd351e31486054fc0a05692fc42f82e4fd8505df5190e80fe9846f3370e9f7a5768bf4c404fbba7c235ca98faa6a847669a8f8e8138bf1105173b24e3e17c1ef63a2e51f30aec1323ac9ea110c580e0cd2595ee56c2e9bb998175a731be840def6a1f2c83a81e811ea95da2fbeba78a88dd705893a94d483ed8a1dc7ef48e99ffa3061ce62b1ff9f4cc229a2f09bcf51241266fd0153acddab24f05910f452ea4f6382b1a468d3aec730d879538bd66423445d177ceaa125f60155b1d024fd007486b48c426dbe534d86ce9a7d83bedba8bd6a7294277df9c73f872e70dcbdae906235c53657bb9d3cd38d5510f72aa7ac6a77224e08926c93364f881cc85abb435d0a8506ec3bc43022b1df0bbe7ee92443fd47a46a070f2096e134539bf006db64f621e217cff0ad6c67f8dc799cda2f439d99f2711f155c7cab2770264a5011ca8f4bfec2a42441671268c47216111285de5f1fad0d84aa27a1afac241608412b0e62d3afdb6e8fd57af6f263fb24374e33f0e0b0802fba3dd5be70cdca01d05a0cfdf939d3bde9ef848188556ee85e75012d00870e3dafe59072e390e2cf8319272d23cf738ac377d5867fbca6ead637e859760aad7e58a5db5353a083b7883cb7b7ad3048f5d0ae359c096c1191b006b04a792296326cee3435a25335bab1aad2c2d7e329e81525f1934110bf58f027685b18ab65a278dc8db06c219d2ddaefa2a782587511fad46cd60e173ce2caf58be7bca580a415c8ab9dfc243522f18a8086b7ad2cd934af3a98dd731018f8367b3d21378b167109e11d4bcfa3a92ef1c05b3520c868ff9766c9715db2c51199dd8a4d503ceb65e262bee5fcabd8cdd94f911607505c7884d80f92aed5cdef31c655b179c0e8f0125c16ffc61e7fa871f0ff8217c19881bef2005d86bf441387205377766a8f284a402c7dcefe4378d0400a0222dbc4fbd077f361d70ef5ea99aa0da208e03e8dc24c6db766de92718daba60ff884ee725f7ce741c8d795900ec2d7d89785e786fa3cc8478c1a892679b5120ed731a1456741cdc80e9b751b2d30f6586ca22bd16cbf10eaec7e041f302a3314b5d69c6ce0e8953d96a5cd6dbaf700d9265dd88d4e8657dc525dcf931e545c4d0f0225720c923419381479fc2c6e6128883d4c5cea56bd3ddd5233fe7adb93dad481261677319db647ad2e70fd6c4f4fc6a623b4e0d8f141f19ace05fa5059e19ec8bad328a12f0a7380fb8a0acfe9fefa325297883f887c806e33ed5a82f61fad9c3b0dddab3d4d165d04c73260a93e9e6223338194872de67f661067bec3fc99bb563cac78c4a28a665c878d9a653190a65550069d95e468c02c663f99d6823d51e5d46ab254c0f120208402b1a3ac0ee7e00153cb32dad83d4baa19e3a6225d62187355980f7adf273fd114e934e9ad492361f97d6a2ef8f1b72e366869ae25113be8c719be687738c319b23069a642ad68088ed76bfdf8683fa57493fbc1d11d8e78abd68cf1df3cc32e4943c9b2d36ab497e7f5566d42abfadb8b0cb8ccf111de8dc761ef0f280fe03e2f7e2c5bfb38d8c69ccb42bfc45ff7a307ee47e2c6a39bfaa59e39d6b814fdac0280910b28561506f1e37bbeee29af65cf650c5dfd74e88e075931ab5d3fe8626d9b81c6583ec0611b33cd5a6fc3dc9fe1bf767d56c724fe51b61fbb75cbb8b2fb98fbdc414eca6d1bd3971d94d6a3bed5b433bd35b31c1e55f789b96c4aad194b0275f74b285889d2c4d9acc2d1e826d1a85933fd4932b7d906019df3425a9db46b01ac71e9f5e9ee77315c4477073cb0529296205fb5a18c64df3676418c16624c431f2e65211dee47312d2c5918169399265173b48187ba9ce326c2f1c864eec2cdd7f25bd4e8675f074aa9d88fc7ccf2ec7cfb758e8a06b61405d71052be2f10ed5c497a91ce4b1711348a1527f17c2b03d90cb70f956f337201dc57e6946f5eb058bbabcce1ff07d12f32528a022978981115a8e0197857eb376213f3fc242f2f2b75a7ca8d74afccd8460553c3932244c918675aec12723bf93b59bd42cc93215a6adc3e3f4941d91f84c72153ae9bd547bf5af3e7569909a361f98d1ddbcebd1a6a555c0102b7710591b9079e9472514c46471a97c6afd186db560760981173e841d582fb68b2d6d132c18492bfaef97614f58d4ed7dc7bf66c8fb9f73b0f3e678d2e1354c162594206ff7569d9eef020715fc02bc413a6fab57e7856519eb78955eccaa9f01a22f3fef7c1220428665eb453e5d441cc19fc9a33e4c89707de333e7d69882968204c84d284cbea6f0be69ec4bc53a5a27f577d12a42285127f28b785067945f426bda203f43f910c039110ea4cb24954cb6fcf2d804a84fc15d1e83902b762cf60cb8584f54fa5ab6eaf293b4093e1455515b3ab1f89fa06d5215c1b98773e2ea060c1701d8f4d1a72cfa509b9a75ec4b850b25583306075814ad643cff55e29ea5e14d2ab7398705f487857635ead291eed4a084296bc9a9291df04fa2dfe91fb362ef0dcfa16b87c481fe6ed84cdb3c07be5b2cfc64ad0df2745426d4ca9edf250cfd475935aebcff262726593cbc7fb062a343fcc254417867e8405b513daf26e58d5f7c10002f64f964992d5808059e243f4f3f91b2d29d480a071d26388b5e49b042f44ef5c45ba141b9f93d8e548f30208931a28d211cc574f3a32e8250837670c61edb6db61c603653f97e824d806786af1e6de5e0a205ad42b3d18b0ccb593010dde7e0b0fa0e07b25118703b6b3ed940867c3a45e7c8001986dedd6f15cbf82fa763063ccf887d3d67f4327f3049155b40b6db5095ff50d090c700d3af3734a2b70884e261770c085d7133a203d5868b0f06c7c0e260e671c4fa320d7acb46a19be6c8f7c02afbb511e86cca4f254f96166796de7928992607cbdd11d2d1f6b00e4569fb084f2e8cb5eb7deba1886083f13e1dc2118bf8fe7dca618b038d7c722ec2a2b25254eef6386d2d0da128fdbab1c6442ba73eff65ecad7bd379b055bd28665300d4c010aeabe2c51066a933a3e86e764ccbd0aa6abc0ceb22475854441a76b0518d446bd0e7cbc1bc9e9c7a8968b8bd1afe07e5c4a1a86a686603864e0ad14ad7c6280953a63661a64d824b9cb6b8ce0e36e81306c747bf37ea567c82f20688af3897cbdbb3b46d7d6a621fac28492b00a0c3c22a322e695609a8e956a4a04f05f7d7410b7ba8fec5e0b6cd3f9494d547c42434e54190695f7406d98cb126654ddaa85616642138df14f9aa87291de62776bd4fb5dc5232c80c847c5f4a06f33da326d71771ec93c2467f79c11fb9da83c85899f354d66ab853283279c870aef7fc093753fb46382eb4237910eefea65296df9bc2633215d3229a380f99d78393a1aa8d65c7e29f5e9745d6d8b61464c81440184c0d5e18cbb1409cfbd3d53ca9c6bcdc52fb33a3fb55b573aa4b1ecf7bcf184743df3d60355bf7f8ff4db5387a96f8f9e96037eda270a9039f178a2c17a0755f9998921c0fc47cba78f14d4580f0960911ab3806c1da180a78bde74358aea5fb07965afd5368eefa96ab6d468e08c729c6b6942c395e9d352948ce4f796c3b2a2138ebcd05cc27fb919737bee9688805241f0e322efe3e451ad1b7df970d0a1d1e8cd00261905a604ee36b8f9effc21906bd958c8c63bf5b959ab449575fb2a2a951c083ecf9dabfe65414115eb7d6e45b585f60dba47e27d67f00e1d0882c2f4572967833e79da6ec8fd445b4252c77236648c71d0f01b2af33093c8b9d48c11b56ed413f148e2691d0ca64e9526dcd64ac28c520dcf97d2420e59105e702ab0d762c68f84dff5d8dcceba6d12b87671d2ade7a69d04e468f1462e1c2b4bd6493e31b892ac32152ff2f890424f36e3821750b4026db33442573cec34f8a7028eb16aa259a27495a4c23b4a68e6de7902beabf67d95c3635a3b154f72ec8c70097fbe3024d092e141406f904d81150a8cdec9ff96b1e33be44a10384400c8cb024dc6e434e5b2a429d15f2f353bd14db8e80565d757e0e007fa01240001962a67ca684a9a84964c30388b3bfa8029cf5917605d060f0ed69344e371ae31516f8ead41a33867281bdeb46b613a6e2a2be99e1b561cd1193f751ab0e7341fd621410ea7551682868e6af6e3f7415430a192599b381c7b1a64dcddd09964639c5d84897697294220924ef9bde8fb94eb7538d7b611c9ffcba6a1d50a4a10d46b88470763428727bdb99356580f7fa51644d22b89e7e57ddd5e4a46c1ea57f6e11cfb636e0f20662135e5f3d884c136ab538359df625b50a3e7d4e29d6e62488109722151fd9fd7e74c706c6816e8c6d11901e34ea5e77d4aeebbdb5a3d5edc217c304378d4bfd07fe0a09cd3a67e8da3f2111355ffa4bf740445f7cb8538499b780086658184aef53dc9836b927ae447e691a2a8b05a24c7bbb66a8758e429c8408477a0927fc512cd9cafb54480300b2021c0fd4acb73ae9608aa556d9f081d54514f4f86c256369cab77ff8fa926c9a994868b31159e7cf6dfc5d743720d9754554dcb9fb1392827bc97ba47ee98dcf95aa86a9d9d24bc35d6c2575b69a592f2ed890beb443261ec659e76a0ff8c8690bb1bf4b3f8269492ddf5a8cb420f2542fac417b7da99948389f701af6db7f2640da2d62d6c05dfaad1b92efd7dc94495adc4ef95f4bc5d0c74d54dd81806ab737371f3622527418342bddc996cb23a9b921fa720769f2720f01c3cde5075e4c96c22f8e98ed8e1800908909db3c776d61094fa57b53e7aee2c21b569a647ffde9b8d4f1e93554229999681806b3e6f8183c126ec4f1ed49dfd45495772049d7536d15fbf193d2b3a2ba28e5390aa7bf4b5ca2b8c0ec9bbc08b4df6571adf76bd1ff73e2262c5364a031d4aed2e2e53148f1ee5104e074e6d3b51ac2f9c05e1ad86d3790c439d9e84934c04a3eb62547365b9ab4b932932d5179f9bd9c7c2b359d5f91a1527fef8ee29cfc041e3aa5ce5d3d421f2640ca5c880f63cb5411ab479c30490c8bb04a79d494d195c4c3a7c2b1062c633e6511fe5631626c4369144fcebb0a124649966902677d84c67de6b4672ed8ae8b6e203180fb22d946bfb9d7a8716e55e2f1f01369969f3fe95c1fe41bbcd7ea2c2af1377290e3aebe4d532871ab7b292ed9ae04bfd3d089b4adc92cfe8f574ea434e42d6129a9861138e9dc04d5ead8356e500102b7bbed2200de39192571fe08b47c0a020592ae7d9c3f388476832609b26c0c03d75efd4175388064cdb042fc9c8862b3fe962312374ec11aa03d3a5d7d2e6ed3488f9e6adf2024ee9aa41abc68ea5bcdd3b689e4590b1e9a32e8ee63e54e3675383beb48c1572dbee36f18fa3af3311a679979428d5a488870399cd2dd2242b25b59e84adfef6afe8732057ca8674f64d8d8334461fad6c727ceda540198d2c579c217c5f71217994d4c8ef26272cd12e89570555d56cd833ae6912f6ab5c68ac3a7cb71ece8d1a5e2706ef45281239f745020e41ef9d6458a65abd5f1da5e5c86f2608b586339625bb17f00138291b7d540236b46f38f468b00481bc296d7f6749e3e03a2d46ee5e12a158454f1c8976b55306235786882021f35932a043b4b42aecefe560389ad651a58dbbc22b5aac0371049bb0ddee4822ffea618a1f1a62cf876be2ae879155a2c059414be45c8e496e7b468d52546b1210962848fae36dadd2783b92af0b8e6f81ef2b9c840e38507cb27efabf36fec7a2380d85dde71b19b3d85b3392dc342b9fbd01af65276e380da34a0a113ee18a4bfeb00b3edda4caf8fd77a6eaa25a2d441030a2091a18088281f6f38f0e8065090466b2a270572452b2035a5bb6638ed512673c38bf21329f877d8b8e6613f08ede39df07c1d999426284ab262096dd12567b296ed9a5d4b1de6abe953c92254834bedcb02f58bf44a09697b02f8fb71daffbd1dc1ccc4779b33f80dd719312974792d67f5363adc60d9ad1672aff33e80c59d965c31a48290e8d1d17dd430cac778c18b6f2d3d7c9d8bbd000aad5b3a78decbd055cabc95197b093cf368a29b5632dabe2609fbe5be2513b7b7ab644c83c53ae544cfb67bedca91d84c395d155243d5442741b634aa3d92ff28c76972e830b0678ce7d57173390cf019b83fc17d60eeec10e53eea8f6ccc0fd7863e68694abb60ff65bce996e1effdace84bba98d0c1d0c6173cd061f4e8fe835fb826ad9a6884c4e6e5fa46c7ae1e596e196d57fee56efcc7cbac9f7ded39286a972f711f33f22ff2b8412c5118ff8fafe7584e6d215462eca5d28accb40d072c4faac2f644a5465029365c73e61333ac2aab8c59e607f3b8c2cdba92682fa503038b07e142179f1bb45d9f4c318c65dc4ab7c2ca8aa5a8e2be36842b7834bdfecb2095eab836aaea659f38726305436bf45e08739f93ef5aad961599aa0de94646a7679076befc248a2e28618cfcdc7bb7e6d6d38b80d9967439c8e08dc67bcd5c1888fe69750d8e2240b4fdff818a10ab9037a39d21f8480ca766700201b426f9cfc93d367fe84758f27fa2cf0a3274107d5c3b9ab88b6293133495fa0e002ef94ed0d32c3ce37f245af70b902535b915cea8d3b938aae5319b957070f2e2468c22f05f215627000a59218da938d5bb7d44aa6527162feb3cac7c2cb8782ab0ec2507700a4875df7109131e21a276098f076b261763346c44c529ff0b6c17b30283d83ce7944a5fffb4e64eff6b9485efcc301398353f310a0cdfb05430af08061bb92f01568822ed477428506ae05a5f12571eba831efa92171a28f2d70ce356903777e3b49e26f23f209a7ad6baa65f4d310cbb431faa433eaa773611adbe11ac5993d58e15e7670e7df409ad5f86fac4ee58cfee9dceaaee98b36b0f87f3d7c1aa05707d8f0b6a971db839ccaa020b6b6747f868d3d5e91577008a136686424b848afd577ef1518fc4723e4658360f0f05b2ce42fab7106a023978a33e1816ab11bbb859ba2f1d0da823fb2577d7875043a59ff85988f8d0f44c67b6b6838e80023dfa458822d8160caf0be0975f3458ae702a572ff3999a8a9d68ac3c192e6e54f79cea16ebfa1c1e5a6a23aa71f899c64ec99b10e368ec2db873f2a1746b7fd8ee10d316d18a8300a1075dc796f60cb1df0c2e229f27e2efc178f43c243759f0e72b146a26c9d3478c41468ae35334c1bd9cf626e312787d8660a5724b630fdebb1921d5b8c2a51248b4c0ad629c0f69ecf467b982bd40a32786ea19e6b057d02ab959804792d02b7ad2590958f056b72f3e077de9d582d3fdedc7d4f1da9c8f2d0a7fc4993f177934f599b56e04e2e4ce02656fd752b93c4b8139aae1437e37f6ee474aa1307e98c734cc7fcc6bb1c503dfa79f2bf333a0aa5af10b385db720d96eca7ccf65b19f583031c6f78cbfdb594faed274544c5a9af4038ed1aebbfb3a9f602da62177fe9d2a28b00d2bccfddbb3c1a6bd3e3c7184ef0ed6988cecd94cc2db84e9ebb5c39f485d7309a650d8292e4f8a19c033e2739a6891a14953341e8f19cd15b392ecdd0e9ace7f8f5247b200c04ac3bb985826f01cad21e767c7d6cf791b90729391f1b0dede6c5de91751c0e48318d82d8a7b562fdddd71cd2a2d43fc5b25d5480e4161a445d6041d1daac03d149da53930220bdf98ff6b6dc9fd355682658bcd9b874b33d99255073eabeffbc24ab4d5583734f3bc2c4cae07e1895e3cce7ef76a7afffcd13b2feb01fb619500c7b1a02e554eebe8a9152e0fbda2d7654893d7b00def75f46c4fa879ea9d2c9d4b9f2cd329f5f472395516f2ae83e4d8dcdc82cc8b99b93a710929a72cd7b4db96b4fc99ccf09687910b5a9f4175b8aab9bf0ebb6cedbba5f8aeafc8f03b6852d5dfea16be3a2dd86e39805f2651cf90822e60c187140160eff12ae45db30e30a500789b1edf3aee992b13f9e23ad6288659e0ccc8f37db5e7d72a00884b1a91d8a836acd2be53d20fea9cbf7ffbb79a1697b494d6eb75053383dd020e7ca562b2d5de99c1e393a6d56e49d65b6c6985fe7a81b41f376af7ac5750b5a8731be89616818e3eeb9a74bfa149caf8589a267ed362592aaeed95c373b44bd44b85e4b907482c1bf22d9b1464dd878af340d81e7442dc6ce66fa61c187b5e9f168af191e8d31a93c1f217aef4281563c24f52d81f5bc5ae94b64cea8bad869d4c19b4fcc046fe9f18be2a4b462e2ea10c7e6f69e4f3e0ba078da7385315757abe688eec6888dc392af271e9d6193635edc21802c7e3806aa7bc04be70348261d8a378abc188e2065e5accabf479b72840722f91559a4bd02097d13580616c483641d5cd45e1968e82c94ef4781af497010e40be49cff775f831c04569abaede06f4ff35f113d19d5deb06861a755df702e2265096abb30fad3f1ca1b3dc232e80051b8a780fa2e13dc589407dbfb2d053b8bdabd122586786b925a0ed5e69744553f94bc9b49cd02e8df94684f4d4eb4ad2e90e24a3e9bf90460ee7ba9dc1ff8c38805c915060ccc506ab9bd49a4abb5980379204f6cd6c268caac9d8ff1e60d6481d4f2cf8aa5527d0f3aa041436fd2e998491cdb4c09e402840f5008dd57bf9e618c8962a84b75f16e88613dee3a63ee256980599773bec8f99fd24db157e94e9be773c1489dd44d275315e9031310648f210970b21946ed8e2a8a73bb680087b9beb4e474d1034a6659c370369186a76b13edca8b4a3d2700dd17b1b870c1d32e9dced2ce478131142f933ddfd34eed8ed0e8c0807811a2e4f67237cb98df9307d5a374965e9f549b41364bed40b6c44b88bab9c52ed4289823a9124433c1ded2abd9f05655cb36ca6aa661b26527cffa0c37910c2ec27f81849aaaeede047fd748c721341a5a3686dd45a5a1ff768a4b2b8072d3e152a824ea83495f2dd64c29d058fa4248912198c57d67432a392628ab03356ab726b94795c0116563e2fd999d816bcf67bbdc0642c77fbb0935418811ddbe1601cf774b63dfa79d658311d910afdd288ad16472310553ab18565672e28ab8d246a7a62ed3307eb794ea62e18b708b2862778df210430a40c6cc27855f0c33e7e9911515cbdd01b589587ee4f84703a1c2dc4eaced16e19fceaa0be2e7ae659b57e0dfc6978befdda6a85c829349631b74356945be2515f106b856f29fb45e860cbd5cf0e72a1d1d3120c19f188679f2a1f79e4560311f71ceaf67c390c08c7e6129f461ededd3173709f1fb37ed601830581d9261dd560d1f9f4b6534745e1d5474eba5109e1fec5e3132749ca375f2ad255a3680cc4e097a1a2a0ee6f729496151e23a6d1133329942326b64099981d7e04e8ebfe23158caa01b251fde1ce546c3406e0aebd54c015ff14628bd98310949a7c4c8c596e9bf5d878e5b33a3401dd56fc855fc015f57fee293acf299822dd7a1239d4eefb680274ab105d7141c71223a0daf49276a827f91afebf4e4aed9b93ece9ebb12934f7072ce00b6e79e5eb3c2430ae364f3759a3982a44465086d104831adee8fb9da68ef5de89ab044b1a3231df085f8cb113275b879bb344329fdc556867ec6ffa82ccb96c968c401984464bf54b79810a191a4905b2d91fa75e063ada3b7ee60d2148cd12e15a3c57281c4daf88cd135b1e9d9d698aa1fefa3055bae2c27f31d228941ad6c2e9043c03dbaa6b158881057314112bee9d4827e37fb55c8ea7d20eb25b17ff52389f40d55d6ada0f04768aa6791d932e16294b8f5b56c6ad1f046b2b2b57ee052335fe7cd989389e1cbc28340c1897db7741d6a2de915494b68c8a459dfb7203dfb942ca8f3f2472fa7b162f47d66d4a76726fa19f96bd10c2c17accdf10b10ee4dea0c2f427039beced7eb79771999a3685983dcebe9a847c70534a37e844e7749bbbe6dfbc1c5b88b00708558828b0c41cb94c748041169fee1b33a7db83a7be1f8619602fb66497b789154f985ee23bbc3c998ca71d5d4e545f4973a48cc6ae1bf6207022a33a8aa699c86f8e0a184e3109f9afdb2778d9cef26a2e3b774f8a591a6f51404884b6968093f636d0eca50c7cb51284976e655704a6e6ffaca3f1d4bc12ac0227a0f464b7d4742c693d02bef85228cd310e3a7930422d2221588795cf54c479080fde1f2cd047566d07db9654e158f2548dd773827edbfae6944c4ed7997c818ac7ac61b1759ccb5a436e1528916915772750ca22a7f2131477222adea4ef8dde90ae90e748c5abbd9d39faa49b5a3eaa4ca962f456b97b351e7eddb6233c75dd7b2a72484a03cc25004c4998ffeb127e8dcbcbca22c048c270ac9cfcb4003445ce753b1af2fbd49f8d70e4704f59efce3554bfdb90b5910356259ab8c129de9e8ba351c2121f714b36b1915e5499a63b707d969258213833fc7da05dc86133c2a6352ae4b622b7daa1bbea983013ff41a8361a1afef4103bb1ab063f08849e70c4eae6e51fe735a093e841ae0b462979b44759f6ff81460fbfd773805eb4ff0482a1ce6e90238f345ba2408f9c5a231675a48303b1bf9c5760d47c37ae380ecfaab34503341646d9da4f6e85485d97c5b94d520069a809317776d089d7bbb6e146bd99f173d619273f2364fa67a7e12504762994721a67bef2b3f013980a424223af3a777ba6aaeab913dbc0570f657e11551f2dc040da4addcd3293afd9a4ef8790593bf4469c3869e89d168086473c06bec3ed1e46c7cd3aa18686419dce58d627bc06659cba3222ffef340ad9b0e3efdac1e9fd2f41ae8a72d3a0611ae21e6460651f8c057474a3c8309a7fc91c1c5dd414b8e687a6ea638976fbf3f639008425ec023b0b74a38543eb204950d1543ee4853b9816cdc644b562d9cac62e0b029c19e2171a75e6de3b11e6c59f0ef07802fe2f8cc70e1f41d6050d7965235ed7b8970e8defff5b96962363bc37f7374d811b83cbdf7a250ff4fc9b8a8d229b12670e94902d8edae2c0b0409183de46f77c7d92239f30115a312ba29020384a171442832971e1cb361647bf0779187e27b0ba830e84783fcac2a00799f9adf19bb2ca2e117dd2b051c5471a83366da5c39bf72944ae99d392d99215f54bd256fca9358bdbede40d1cde15bfbe79d5b08bbad58d3a6bd32a09c04132ce361737eaab28214d1487ce455ad045baa3a207d7c8ebac0c3daf85355f07d3f46c71cae9da5a8d59bf9a3425da5b9d25e4abef115072fc9bff85a27c630d274a27642bdc5457cf557af53535ccbe06b1a9f424a0867f2343997a631221ec9367e7591a7c6f0cb9885cb2b75194819367631d10ae56baa0a467189593c3582cc16d01bbc6026faa58960e481b1203dda947f496764dd6d88d9d4030497ce4417c3833d517323aae052a4b51b474dfea689ee2d676fab8fb3b7b549f20959a11dd46bb2f45406109853a5128760b71c2d6f7512310519cd4f58e5d69788bc8924c53499c3df7b7885ef3f822cc3df4d96276b89c3c4a25d4d84fa1444d836e3e07f5c37bbf9d4b5b6678064c9329aaafac267331f0bd6d184e816fbc223e4bf366a5f440e7a69a62ddb32be827c0c0644a11c6ab57b3eeb36efaa06ae3ebb5b3abbb25554aa020f0a7fa8fd3698846d6c11b5796b6489e44ca6ff4b939208410e9214cd01700b3b68e7b803476f607d17f134593add938df49436c501486c266ee62437affbbb9dc16778c1be9e05a1b8647197d6c0f6b051f2646940475edca9d1aefa91cb106c891a6aab50de267646a1d7cb11b347961baf2939449b62a88dca831fe834afda9f6d4911c9a3809e52c1c2989cb6e2a76898bb2920b44f0cba7d1fedc968180351397b585d373931fb91f31d9fa54d20d68c697628ac69d38d677596f57933153c2b11107a3a4acbdb502b1407ce936f2f72391f2a0ec2c98721d3470a1cff99b0977c50ed79eff152680d839a118a3414f3189f1fde9490ba041dde1a6e7f0744e3ce37e5d7aaa218f1126b1ebfb02057dc690b62fdd736ec02d5d918238edf7b58efc5c2eb8127da575d798732abc91f0589bd19b1d18d5397edbb5b369bc69cbead8f69d6ee777bcbd31bd3136d0fa70ecc13b9a63f00825d9ec2cc3eeed93f7c4</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      只是日常自语而已。
    
    </summary>
    
    
    
      <category term="java" scheme="http://oodtoodt.github.io/tags/java/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="server" scheme="http://oodtoodt.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>sol2笔记-2</title>
    <link href="http://oodtoodt.github.io/2020/05/08/lua/sol2%E7%AC%94%E8%AE%B0-2/"/>
    <id>http://oodtoodt.github.io/2020/05/08/lua/sol2%E7%AC%94%E8%AE%B0-2/</id>
    <published>2020-05-08T03:24:06.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>时隔近半年，重回sol2学习</p><a id="more"></a><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次其实就是带着代码读一遍而不是简单的过一遍了。<br>主要是我能看懂这些lambda不至于慌神迷乱了。</p><h2 id="getting-started"><a href="#getting-started" class="headerlink" title="getting-started"></a>getting-started</h2><p>起手<code>sol::state lua;lua.open_libraries(sol::lib::base)</code>没问题。</p><h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> is_defaulted = lua[<span class="string">".."</span>][<span class="string">".."</span>].getor(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">auto</span> bark = lua[<span class="string">"config"</span>][<span class="string">"bark"</span>];</span><br><span class="line"><span class="keyword">if</span>(bark.valid()) &#123;&#125; </span><br><span class="line">sol::optional&lt;<span class="keyword">bool</span>&gt; is_a_boolean = lua[<span class="string">"config"</span>][<span class="string">"brak"</span>];</span><br><span class="line"><span class="keyword">if</span>(is_a_boolean) &#123;<span class="comment">/*the value is a boolean*/</span>&#125;</span><br></pre></td></tr></table></figure><p>写<br>写的时候注意嵌套</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lua[<span class="string">"bark"</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">lua[<span class="string">"some_table"</span>] = lua.create_table_with(</span><br><span class="line">    <span class="string">"key0"</span>, <span class="number">24</span>,</span><br><span class="line">    <span class="string">"key1"</span>, <span class="number">25</span>,</span><br><span class="line">    lua[<span class="string">"bark"</span>], <span class="string">"the key is 50 and this string is its value!"</span>);</span><br><span class="line">lua.script(R<span class="string">"(</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">print(some_table[50])</span></span><br><span class="line"><span class="string">print(some_table["</span>key0<span class="string">"])</span></span><br><span class="line"><span class="string">print(some_table["</span>key1<span class="string">"])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- a lua comment: access a global in a lua script with the _G table</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(_G["</span>bark<span class="string">"])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">)"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the key is 50 and this string is its value!</span></span><br><span class="line"><span class="comment">24</span></span><br><span class="line"><span class="comment">25</span></span><br><span class="line"><span class="comment">50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>同时写的时候注意不要进行太深的写，容易造成在不存在的table里写东西，这时候可以用一些lazy读写，最后查看其valid()。<br>如果一个值为nil(sol::lua_nil)，那么<code>sol::optional&lt;int&gt;</code>将在if中变成false。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="注册函数"><a href="#注册函数" class="headerlink" title="注册函数"></a>注册函数</h3><p>三种方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">std</span>::<span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"D"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sol::state lua;</span><br><span class="line">    lua[<span class="string">"a"</span>] = my_func;</span><br><span class="line">    lua.<span class="built_in">set</span>(<span class="string">"b"</span>,my_func);</span><br><span class="line">    lua.set_function(<span class="string">"c"</span>,my_func);</span><br><span class="line">    lua.script(<span class="string">"some_str = a(1, 'Da')"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> some_str = lua[<span class="string">"some_str"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_class</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    my_class(<span class="keyword">int</span> x) : a(x) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ++a; <span class="comment">// increment a by 1</span></span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">lua.set_function(<span class="string">"my_class_func"</span>, &amp;my_class::func, my_class());</span><br><span class="line">lua.set_function(<span class="string">"my_class_func_2"</span>, &amp;my_class::func);</span><br><span class="line">lua.<span class="built_in">set</span>(<span class="string">"obj"</span>, my_class(<span class="number">24</span>));</span><br><span class="line">lua.script(R<span class="string">"(</span></span><br><span class="line"><span class="string">    first_value = my_class_func()</span></span><br><span class="line"><span class="string">    second_value = my_class_func()</span></span><br><span class="line"><span class="string">)"</span>);</span><br><span class="line"><span class="comment">// first_value == 1</span></span><br><span class="line"><span class="comment">// second_value == 2</span></span><br><span class="line">lua.script(R<span class="string">"(</span></span><br><span class="line"><span class="string">    third_value = my_class_func_2(obj)</span></span><br><span class="line"><span class="string">    fourth_value = my_class_func_2(obj)</span></span><br><span class="line"><span class="string">)"</span>);</span><br><span class="line"><span class="comment">// first_value == 25</span></span><br><span class="line"><span class="comment">// second_value == 26</span></span><br></pre></td></tr></table></figure><p>模板是很难注册的，因为它是编译期内容，如果你需要，指定所有的参数类型才可以绑定和使用<br>可以用sol::overload重载函数<br>lambda会有很多奇怪的问题。记住，用my_table.set_function注册所有的lambda，我相信这里set_function和所有都是关键的点。然后没有指定返回类型的lambda会衰退(decay，std::decay就是对类型退化的意思，这里应该同理，去const reference)返回值，要显式捕获或返回引用，根据需要使用decltype(auto)或直接指定返回类型<br>问题的原因也很有趣，这里不展开了。</p><blockquote><p>Welcome to non-static-reflection hell</p></blockquote><h3 id="函数与参数传递"><a href="#函数与参数传递" class="headerlink" title="函数与参数传递"></a>函数与参数传递</h3><p>这里非常的复杂，至少我大部分没有看懂。留个心眼吧。</p><ul><li>所有参数都会被转发。意味着不会发生复制、移动，除非明确由用户或接收函数完成。</li><li>sol::table,sol::object,sol::userdata and friends(?)复制代价很低，并且简单的视为值，如果您不希望使用copy，那就要用const type&amp;或者type&amp;，注意用引用很危险，因为lua默认传引用，值很容易被更改。</li><li>函数绑定到lua时，指针参数都用作<code>T*</code></li><li>避免通过引用或值使用特殊的unique_usertype参数，因为许多类型只能移动，而lua没有移动的概念，通过引用是非常危险的。</li><li>函数有对nil/nullptr的期望就可以用<code>T*</code>,没有就用(const T&amp;/T&amp;)【注:没看懂】</li><li>尽量不要用<code>const char*</code>，除非你对Lua Stack了如指掌</li></ul><h3 id="从lua获取函数"><a href="#从lua获取函数" class="headerlink" title="从lua获取函数"></a>从lua获取函数</h3><p>使用sol::function或使用sol::protected_function这种更高级的包装器<br>前者很简单，如果不用的话其实auto也可以，或者干脆做右值，都行<br>后者可以绑定一个error_handler变量，捕获错误并处理他们</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        sol::state lua;</span><br><span class="line"></span><br><span class="line">        lua.script(R<span class="string">"(</span></span><br><span class="line"><span class="string">                function handler (message)</span></span><br><span class="line"><span class="string">                        return "</span>Handled <span class="keyword">this</span> message: <span class="string">" .. message</span></span><br><span class="line"><span class="string">                end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                function f (a)</span></span><br><span class="line"><span class="string">                        if a &lt; 0 then</span></span><br><span class="line"><span class="string">                                error("</span>negative number detected<span class="string">")</span></span><br><span class="line"><span class="string">                        end</span></span><br><span class="line"><span class="string">                        return a + 5</span></span><br><span class="line"><span class="string">                end</span></span><br><span class="line"><span class="string">        )"</span>);</span><br><span class="line"></span><br><span class="line">        sol::protected_function f = lua[<span class="string">"f"</span>];</span><br><span class="line">        f.error_handler = lua[<span class="string">"handler"</span>];</span><br><span class="line"></span><br><span class="line">        sol::protected_function_result result = f(<span class="number">-500</span>);</span><br><span class="line">        <span class="keyword">if</span> (result.valid()) &#123;</span><br><span class="line">                <span class="comment">// Call succeeded</span></span><br><span class="line">                <span class="comment">// Which would be not called here</span></span><br><span class="line">                <span class="keyword">int</span> x = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Call failed</span></span><br><span class="line">                sol::error err = result;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> what = err.what();</span><br><span class="line">                <span class="comment">// 'what' Should read</span></span><br><span class="line">                <span class="comment">// "Handled this message: negative number detected"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL_ALL_SAFETIES_ON 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sol/sol.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"assert.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses some of the fancier bits of sol3, including the "transparent argument",</span></span><br><span class="line"><span class="comment">// sol::this_state, which gets the current state and does not increment</span></span><br><span class="line"><span class="comment">// function arguments</span></span><br><span class="line"><span class="function">sol::object <span class="title">fancy_func</span><span class="params">(sol::object a, sol::object b, sol::this_state s)</span> </span>&#123;</span><br><span class="line"><span class="function">sol::state_view <span class="title">lua</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (a.is&lt;<span class="keyword">int</span>&gt;() &amp;&amp; b.is&lt;<span class="keyword">int</span>&gt;()) &#123;</span><br><span class="line"><span class="keyword">return</span> sol::object(lua, sol::in_place, a.as&lt;<span class="keyword">int</span>&gt;() + b.as&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.is&lt;<span class="keyword">bool</span>&gt;()) &#123;</span><br><span class="line"><span class="keyword">bool</span> do_triple = a.as&lt;<span class="keyword">bool</span>&gt;();</span><br><span class="line"><span class="keyword">return</span> sol::object(lua, sol::in_place_type&lt;<span class="keyword">double</span>&gt;, b.as&lt;<span class="keyword">double</span>&gt;() * (do_triple ? <span class="number">3</span> : <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Can also use make_object</span></span><br><span class="line"><span class="keyword">return</span> sol::make_object(lua, sol::lua_nil);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sol::state lua;</span><br><span class="line"></span><br><span class="line">lua[<span class="string">"f"</span>] = fancy_func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = lua[<span class="string">"f"</span>](<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// result == 3</span></span><br><span class="line">c_assert(result == <span class="number">3</span>);</span><br><span class="line"><span class="keyword">double</span> result2 = lua[<span class="string">"f"</span>](<span class="literal">false</span>, <span class="number">2.5</span>);</span><br><span class="line"><span class="comment">// result2 == 2.5</span></span><br><span class="line">c_assert(result2 == <span class="number">2.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// call in Lua, get result</span></span><br><span class="line"><span class="comment">// notice we only need 2 arguments here, not 3 (sol::this_state is transparent)</span></span><br><span class="line">lua.script(<span class="string">"result3 = f(true, 5.5)"</span>);</span><br><span class="line"><span class="keyword">double</span> result3 = lua[<span class="string">"result3"</span>];</span><br><span class="line"><span class="comment">// result3 == 16.5</span></span><br><span class="line">c_assert(result3 == <span class="number">16.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"=== any_return ==="</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result : "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result2: "</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result3: "</span> &lt;&lt; result3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的sol::this_state,sol::state_view值得玩味，因为文档里没有提他们的用途（到这为止），盲猜就是绑定了环境</p><h2 id="lua中的c"><a href="#lua中的c" class="headerlink" title="lua中的c++"></a>lua中的c++</h2><p>使用usertype或udt很简单。如果不调用任何成员变量和函数，直接传递即可。<br>如果要在lua的用户类型上使用变量和函数，就需要注册：可用<code>new_usertype</code>绑定方法和变量，这些方法都在table和state(_view)上，但我们只在state上使用它<br>另外new_usertype允许一些设置选项，详见文档。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (way_1) &#123;</span><br><span class="line">        lua.new_usertype&lt;ship&gt;( <span class="string">"ship"</span>, <span class="comment">// the name of the class, as you want it to be used in lua</span></span><br><span class="line">                <span class="comment">// List the member functions you wish to bind:</span></span><br><span class="line">                <span class="comment">// "name_of_item", &amp;class_name::function_or_variable</span></span><br><span class="line">                <span class="string">"shoot"</span>, &amp;ship::shoot,</span><br><span class="line">                <span class="string">"hurt"</span>, &amp;ship::hurt,</span><br><span class="line">                <span class="comment">// bind variable types, too</span></span><br><span class="line">                <span class="string">"life"</span>, &amp;ship::life,</span><br><span class="line">                <span class="comment">// names in lua don't have to be the same as C++,</span></span><br><span class="line">                <span class="comment">// but it probably helps if they're kept the same,</span></span><br><span class="line">                <span class="comment">// here we change it just to show its possible</span></span><br><span class="line">                <span class="string">"bullet_count"</span>, &amp;ship::bullets</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// set usertype explicitly, with the given name</span></span><br><span class="line">        sol::usertype&lt;ship&gt; usertype_table = lua.new_usertype&lt;ship&gt;( <span class="string">"ship"</span>);</span><br><span class="line">        usertype_table[<span class="string">"shoot"</span>] = &amp;ship::shoot;</span><br><span class="line">        usertype_table[<span class="string">"hurt"</span>] = &amp;ship::hurt;</span><br><span class="line">        usertype_table[<span class="string">"life"</span>] = &amp;ship::life;</span><br><span class="line">        usertype_table[<span class="string">"bullet_count"</span>] = &amp;ship::bullets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>在销毁sol::state之前，必须销毁所有对象，否则悬挂引用Lua State会造成可怕的爆炸<br>在这里，sol::object在状态超出范围前，必须清除所有源自sol::reference和sol::object的类型<br>这段代码很熟悉，但是不记得是在哪看过了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sol::state lua;</span><br><span class="line">lua.open_libraries(sol::lib::base);</span><br><span class="line"></span><br><span class="line">lua.script(R<span class="string">"(</span></span><br><span class="line"><span class="string">obj = "</span>please don<span class="number">'</span>t let me die<span class="string">";</span></span><br><span class="line"><span class="string">)"</span>);</span><br><span class="line"></span><br><span class="line">sol::object keep_alive = lua[<span class="string">"obj"</span>];</span><br><span class="line">lua.script(R<span class="string">"(</span></span><br><span class="line"><span class="string">obj = nil;</span></span><br><span class="line"><span class="string">function say(msg)</span></span><br><span class="line"><span class="string">print(msg)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">)"</span>);</span><br><span class="line"></span><br><span class="line">lua.collect_garbage();</span><br><span class="line"></span><br><span class="line">lua[<span class="string">"say"</span>](lua[<span class="string">"obj"</span>]);</span><br><span class="line"><span class="comment">// still accessible here and still alive in Lua</span></span><br><span class="line"><span class="comment">// even though the name was cleared</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> message = keep_alive.as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><blockquote><p>sol不会拥有原始指针的所有权：原始指针不拥有任何东西。sol不会删除原始指针，因为它们不（也不应该拥有）任何东西：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL_ALL_SAFETIES_ON 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sol/sol.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_type</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">sol::state lua;</span><br><span class="line"><span class="comment">// AAAHHH BAD</span></span><br><span class="line"><span class="comment">// dangling pointer!</span></span><br><span class="line">lua[<span class="string">"my_func"</span>] = []() -&gt; my_type* &#123; <span class="keyword">return</span> <span class="keyword">new</span> my_type(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AAAHHH!</span></span><br><span class="line">lua.<span class="built_in">set</span>(<span class="string">"something"</span>, <span class="keyword">new</span> my_type());</span><br><span class="line"></span><br><span class="line"><span class="comment">// AAAAAAHHH!!!</span></span><br><span class="line">lua[<span class="string">"something_else"</span>] = <span class="keyword">new</span> my_type();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是之前提到过的，lambda一定要指定返回值，其他的同理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL_ALL_SAFETIES_ON 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sol/sol.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_type</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">sol::state lua;</span><br><span class="line"><span class="comment">// :ok:</span></span><br><span class="line">lua[<span class="string">"my_func0"</span>] = []() -&gt; <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;my_type&gt; &#123; <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;my_type&gt;(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// :ok:</span></span><br><span class="line">lua[<span class="string">"my_func1"</span>] = []() -&gt; <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;my_type&gt; &#123; <span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;my_type&gt;(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// :ok:</span></span><br><span class="line">lua[<span class="string">"my_func2"</span>] = []() -&gt; my_type &#123; <span class="keyword">return</span> my_type(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// :ok:</span></span><br><span class="line">lua.<span class="built_in">set</span>(<span class="string">"something"</span>, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;my_type&gt;(<span class="keyword">new</span> my_type()));</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;my_type&gt; my_shared = <span class="built_in">std</span>::make_shared&lt;my_type&gt;();</span><br><span class="line"><span class="comment">// :ok:</span></span><br><span class="line">lua.<span class="built_in">set</span>(<span class="string">"something_else"</span>, my_shared);</span><br><span class="line"></span><br><span class="line"><span class="comment">// :ok:</span></span><br><span class="line"><span class="keyword">auto</span> my_unique = <span class="built_in">std</span>::make_unique&lt;my_type&gt;();</span><br><span class="line">lua[<span class="string">"other_thing"</span>] = <span class="built_in">std</span>::<span class="built_in">move</span>(my_unique);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽量使用std::nullptr_t或sol::lua_nil</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL_ALL_SAFETIES_ON 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sol/sol.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_type</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">sol::state lua;</span><br><span class="line"><span class="comment">// THIS IS STILL BAD DON'T DO IT AAAHHH BAD</span></span><br><span class="line"><span class="comment">// return a unique_ptr that's empty instead</span></span><br><span class="line"><span class="comment">// or be explicit!</span></span><br><span class="line">lua[<span class="string">"my_func6"</span>] = []() -&gt; my_type* &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// :ok:</span></span><br><span class="line">lua[<span class="string">"my_func7"</span>] = []() -&gt; <span class="built_in">std</span>::<span class="keyword">nullptr_t</span> &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// :ok:</span></span><br><span class="line">lua[<span class="string">"my_func8"</span>] = []() -&gt; <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;my_type&gt; &#123;</span><br><span class="line"><span class="comment">// default-constructs as a nullptr,</span></span><br><span class="line"><span class="comment">// gets pushed as nil to Lua</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;my_type&gt;();</span><br><span class="line"><span class="comment">// same happens for std::shared_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acceptable, it will set 'something' to nil</span></span><br><span class="line"><span class="comment">// (and delete it on next GC if there's no more references)</span></span><br><span class="line">lua.<span class="built_in">set</span>(<span class="string">"something"</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also fine</span></span><br><span class="line">lua[<span class="string">"something_else"</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用（protected_）function_result，load_result（尤其是多个加载/函数会导致一个C ++函数），stack_reference和类似基于堆栈的事物时，请务必小心，以他们为返回值前三思。<br>proxy依赖于Lua堆栈，从c++函数中返回它们完全不安全，而且没有什么好的解决办法。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL_ALL_SAFETIES_ON 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sol/sol.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"assert.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; code = R<span class="string">"(</span></span><br><span class="line"><span class="string">bark = &#123; </span></span><br><span class="line"><span class="string">woof = &#123;</span></span><br><span class="line"><span class="string">[2] = "</span>arf!<span class="string">" </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)"</span>;</span><br><span class="line"></span><br><span class="line">sol::state lua;</span><br><span class="line">lua.open_libraries(sol::lib::base);</span><br><span class="line">lua.script(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// produces table_proxy, implicitly converts to std::string, quietly destroys table_proxy</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> arf_string = lua[<span class="string">"bark"</span>][<span class="string">"woof"</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazy-evaluation of tables</span></span><br><span class="line"><span class="keyword">auto</span> x = lua[<span class="string">"bark"</span>];</span><br><span class="line"><span class="keyword">auto</span> y = x[<span class="string">"woof"</span>];</span><br><span class="line"><span class="keyword">auto</span> z = y[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrivies value inside of lua table above</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> value = z;</span><br><span class="line">c_assert(value == <span class="string">"arf!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can change the value later...</span></span><br><span class="line">z = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yay, lazy-evaluation!</span></span><br><span class="line"><span class="keyword">int</span> changed_value = z; <span class="comment">// now it's 20!</span></span><br><span class="line">c_assert(changed_value == <span class="number">20</span>);</span><br><span class="line">lua.script(<span class="string">"assert(bark.woof[2] == 20)"</span>);</span><br><span class="line"></span><br><span class="line">lua[<span class="string">"a_new_value"</span>] = <span class="number">24</span>;</span><br><span class="line">lua[<span class="string">"chase_tail"</span>] = [](<span class="keyword">int</span> chasing) &#123; </span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chasing; ++i) &#123;</span><br><span class="line">r *= r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">lua.script(<span class="string">"assert(a_new_value == 24)"</span>);</span><br><span class="line">lua.script(<span class="string">"assert(chase_tail(2) == 16)"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来没有proxy的内容，其实auto的xyz都是<code>sol::table_proxy&lt;...&gt;</code>代理类。它们惰性求值，并且被当做引用来使用。当然我们不建议使用proxy在类和类之间或函数和函数之间用惰性求值<br>更深的东西请查阅文档和api，这里不展开。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔近半年，重回sol2学习&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>EffectiveModernCpp-note</title>
    <link href="http://oodtoodt.github.io/2020/05/07/c++/EffectiveModernCpp-note/EffectiveModernCpp-note/"/>
    <id>http://oodtoodt.github.io/2020/05/07/c++/EffectiveModernCpp-note/EffectiveModernCpp-note/</id>
    <published>2020-05-07T07:31:23.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>真绝了，没想到我又回来了学c++了</p><a id="more"></a><hr><h2 id="item5：优先考虑auto而非显式"><a href="#item5：优先考虑auto而非显式" class="headerlink" title="item5：优先考虑auto而非显式"></a>item5：优先考虑auto而非显式</h2><p>auto好处多多</p><ul><li>可以简化语法，减少重复量</li><li>更适合存储闭包</li><li>必须初始化</li><li>避免依赖类型快捷方式的问题<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">unsigned</span> sz = v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">auto</span> sz = v.<span class="built_in">size</span>();<span class="comment">//better</span></span><br></pre></td></tr></table></figure>因为实际上，size的返回值是<code>std::vector&lt;int&gt;::size_type</code>，在32-bit和64-bit的windows上并不一定是相同的。auto保证了不会有问题</li><li>auto保证避免很难意识到的类型不匹配的错误<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::sring,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&amp;p : m) &#123;&#125;<span class="comment">//wrong！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; p : m) &#123;&#125;</span><br></pre></td></tr></table></figure>因为unordered_map的key是一个常量，所以应当是<code>std::pair&lt;const std::string,int&gt;</code>，但这真的很难发现，也真的很难避免，除非你无所不知（指知道）。</li></ul><h2 id="item6：当auto推导出非预期类型时应使用显式类型初始化"><a href="#item6：当auto推导出非预期类型时应使用显式类型初始化" class="headerlink" title="item6：当auto推导出非预期类型时应使用显式类型初始化"></a>item6：当auto推导出非预期类型时应使用显式类型初始化</h2><p>这个就很离谱，我用auto是为了什么？<br>那么问题的原因是什么呢，是一些代理类会占据auto使得一些令人困惑的事情发生，导致一些可能原先有的，指向某些东西的指针悬挂。<br>解决就是显式初始化。</p><h2 id="Item7：区别使用-和-创建对象"><a href="#Item7：区别使用-和-创建对象" class="headerlink" title="Item7：区别使用()和{}创建对象"></a>Item7：区别使用()和{}创建对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我这样放在一起，你应当会觉得它们都是初始化，但其实不是，后者会变成函数声明。<br>大括号则没有这种问题。<br>大括号还能禁止窄变换，就是隐式自动变换，<code>int sum{1.0+2.0}</code><br>大括号的问题是会被<code>std::initializer_list&lt;&gt;</code>劫持，认为整个大括号内的都是一套里的东西，这有点像auto去识别大括号。（当然，必须是<code>&lt;&gt;</code>中的实参可以转化的情况）<br>这里可以提一嘴：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure><p>前者是10个元素都是20的vector，后者是元素值分别为10和20的vector。</p><h2 id="Item8：优先考虑nullptr而非0-null"><a href="#Item8：优先考虑nullptr而非0-null" class="headerlink" title="Item8：优先考虑nullptr而非0/null"></a>Item8：优先考虑nullptr而非0/null</h2><p>因为NULL的实现细节有不确定因素，是除int外的整形。<br>nullptr的优点是它不是整形<br>也不是指针类型，但可以认为是通用类型的指针，真正类型是std::nullptr_t，在一个完美循环定义后，std::nullptr_t又被定义为nullptr（？这里我持怀疑态度）<br>因此nullptr可以避开函数重载导致的种种问题，以及模板的识别问题</p><h2 id="Item9：优先考虑别名声明而非typedefs"><a href="#Item9：优先考虑别名声明而非typedefs" class="headerlink" title="Item9：优先考虑别名声明而非typedefs"></a>Item9：优先考虑别名声明而非typedefs</h2><p>这一点其实很常规，但是有值得深究的理由<br>首先在模板中用using非常容易，用typedef你就得套一层struct然后实际使用起来还很麻烦：如果使用typedef声明一个持有链表的对象，对象又用了模板参数，你就不得不加上typename，这里涉及的类型依赖可以去查阅自己写的笔记以及挖坑不填的cpptt<br>所以就有了<code>std::remove_const&lt;T&gt;::type -&gt; std::remove_const_t&lt;T&gt;</code>的变化，怎么样，是不是串起来了？没错，标准委员会背锅。</p><h2 id="Item10：优先考虑限域枚举而非未限域枚举"><a href="#Item10：优先考虑限域枚举而非未限域枚举" class="headerlink" title="Item10：优先考虑限域枚举而非未限域枚举"></a>Item10：优先考虑限域枚举而非未限域枚举</h2><p>即传统的enum {}不如现代的enum class {}，具体说前者有这些问题：</p><ul><li>枚举名泄漏</li><li>枚举名会隐式转化为整形（/浮点型）</li><li>你可能不记得前置声明的事宜<br>第三个不算问题，只是提到了。这里我想贴一下他提到的这个传统enum用到的地方，以及如何优化限域枚举的表现：<br>假设我们有一个c++11的tuples保存了用户的名字、email、声誉点<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo = </span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>,</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; ;</span><br><span class="line">UserInfo uInfo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> val = <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(uInfo);</span><br></pre></td></tr></table></figure>作为一个程序员，你应该记住第一个字段代表用户的email吗？不。<br>可以使用非限域枚举关联来避免需求<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> UserInfoFields &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> val = <span class="built_in">std</span>::<span class="built_in">get</span>&lt;uiEmail&gt;(uInfo);</span><br></pre></td></tr></table></figure>因为枚举名被隐式转换成std::size_t了，没想到吧.jpg<br>如果你用限定的话就必须自己来动手<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure>作为一个程序员，你应当想到可以写一个函数传入枚举名并返回对应的std::size_t值。<br>std::get是一个模板，你给出的std::size_t值是模板实参(<code>即&lt;&gt;而非()</code>)因此枚举名变换会发生在编译期，所以这必须是constexpr模板函数<br>如果我们想要更泛化的使用它，泛化其返回类型，则可以通过std::underlying_type,最后可以在编译期接受任意枚举名并返回它的值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> <span class="built_in">std</span>::underlying_type&lt;E&gt;::type</span><br><span class="line">  toUType(E enumerator) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span></span><br><span class="line">      <span class="built_in">std</span>::underlying_type&lt;E&gt;::type&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在C++14中，<strong>toUType</strong>还可以进一步用<code>std::underlying_type_t</code>（参见Item 9）代替<code>typename std::underlying_type&lt;E&gt;::type</code>打磨：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt; <span class="comment">// C++14</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">underlying_type_t</span>&lt;E&gt;</span><br><span class="line">  toUType(E enumerator) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以再用C++14 auto（参见Item 3）打磨一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt; <span class="comment">// C++14</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span><br><span class="line">  toUType(E enumerator) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管它怎么写，<strong>toUType</strong>现在允许这样访问tuple的字段了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = <span class="built_in">std</span>::get&lt;toUType(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure><h2 id="Item11：优先考虑使用deleted函数而非使用未定义的私有声明"><a href="#Item11：优先考虑使用deleted函数而非使用未定义的私有声明" class="headerlink" title="Item11：优先考虑使用deleted函数而非使用未定义的私有声明"></a>Item11：优先考虑使用deleted函数而非使用未定义的私有声明</h2><p>在effective c++中，我们就提到过防止客户调用某些自动声明的函数的方法是把它们声明为私有成员函数，见原书item6<br>任何函数都能delete，包括非成员函数和模板实例，这些在private声明中做不到。</p><h2 id="Item12：使用override声明重写函数"><a href="#Item12：使用override声明重写函数" class="headerlink" title="Item12：使用override声明重写函数"></a>Item12：使用override声明重写函数</h2><p>…好像没什么好说的，就这么干就行<br>用成员函数限定 <code>&amp;  &amp;&amp;</code>来区分左值对象和右值对象</p><h2 id="Item13：优先考虑const-iterator而非iterator"><a href="#Item13：优先考虑const-iterator而非iterator" class="headerlink" title="Item13：优先考虑const_iterator而非iterator"></a>Item13：优先考虑const_iterator而非iterator</h2><p>c++98中const_iterator非常麻烦，是万恶之源（？）<br>c++11没有cbegin,cend,rbegin,rend…你也许要自己实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">cbegin</span>(<span class="title">const</span> <span class="title">C</span>&amp; <span class="title">container</span>)-&gt;<span class="title">decltype</span>(<span class="title">std</span>:</span>:<span class="built_in">begin</span>(container))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">begin</span>(container); <span class="comment">// 解释见下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Item14：如果函数不抛出异常就用noexcept"><a href="#Item14：如果函数不抛出异常就用noexcept" class="headerlink" title="Item14：如果函数不抛出异常就用noexcept"></a>Item14：如果函数不抛出异常就用noexcept</h2><p>优化性而言，是<code>noexcept&gt;throw()&gt;无</code><br>noexcept是函数接口的一部分，这意味着调用者会依赖它、<br>noexcept函数较之于非noexcept函数更容易优化<br>noexcept对于移动语义,swap，内存释放函数和析构函数非常有用（如何知道一个函数中的移动操作是否产生异常？答案很明显：它检查是否声明noexcept。）<br>大多数函数是异常中立的(译注：可能抛也可能不抛异常）而不是noexcept</p><h2 id="Item15：尽可能使用constexpr"><a href="#Item15：尽可能使用constexpr" class="headerlink" title="Item15：尽可能使用constexpr"></a>Item15：尽可能使用constexpr</h2><p>如果要颁一个C++11中最令人困惑的词的奖，constexpr可能会赢得这个奖<br>尽可能的使用constexpr表示你需要长期坚持对某个对象或者函数施加这种限制。</p><p>这里提到的基本上都是常规的constexpr，但是作者指出：如果constexpr被一个或者多个编译器不可知的值调用时，它会运行时计算它的结果。这跟编译期计算有点相悖，我们留个心眼在这里。或者回去看看其他的翻译版本</p><h2 id="Item16：让const成员函数线程安全"><a href="#Item16：让const成员函数线程安全" class="headerlink" title="Item16：让const成员函数线程安全"></a>Item16：让const成员函数线程安全</h2><p>这篇我就没看懂。虽然原子量和线程的东西确实是这样，两个操作量尽量用互斥锁，我懂了，但是和const成员函数有啥关系。。。<br>就是const里面如果有mutable还是会出现线程的危险</p><h2 id="Item17：理解特殊成员函数的生成"><a href="#Item17：理解特殊成员函数的生成" class="headerlink" title="Item17：理解特殊成员函数的生成"></a>Item17：理解特殊成员函数的生成</h2><p>Rule of Three：这个规则告诉我们如果你声明了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，你应该也声明其余两个</p><blockquote><p>两个拷贝操作是独立的：声明一个不会限制编译器声明另一个。所以如果你声明一个拷贝构造哈说，但是没有声明拷贝赋值运算符，如果写的代码用到了拷贝赋值，编译器会帮助你生成拷贝赋值运算符重载。同样的，如果你声明拷贝赋值运算符但是没有拷贝构造，代码用到拷贝构造编译器就会生成它。上述规则在C++98和C++11中都成立。<br>再进一步，如果一个类显式声明了拷贝操作，编译器就不会生成移动操作。这种限制的解释是如果声明拷贝操作就暗示着默认逐成员拷贝操作不适用于该类，编译器会明白如果默认拷贝不适用于该类，移动操作也可能是不适用的。</p></blockquote><p>Rule of Three带来的后果就是只要出现用户定义的析构函数就意味着简单的逐成员拷贝操作不适用于该类。接着，如果一个类声明了析构也意味着拷贝操作可能不应该自定生成，因为它们做的事情可能是错误的。在C++98提出的时候，上述推理没有得倒足够的重视，所以C++98用户声明析构不会左右编译器生成拷贝操作的意愿。C++11中情况仍然如此，但仅仅是因为限制拷贝操作生成的条件会破坏老代码。</p><p>Rule of Three规则背后的解释依然有效，再加上对声明拷贝操作阻止移动操作隐式生成的观察，使得C++11不会为那些有用户定义的析构函数的类生成移动操作。所以仅当下面条件成立时才会生成移动操作：<br>类中没有拷贝操作<br>类中没有移动操作<br>类中没有用户定义的析构</p><p>假设编译器生成的函数行为是正确的（即逐成员拷贝类数据是你期望的行为），你的工作很简单，C++11的=default就可以表达你想做的<br>然而用户声明的析构函数会抑制编译器生成移动操作，所以如果该类需要具有移动性，就为移动操作加上=default。声明移动会抑制拷贝生成，所以如果拷贝性也需要支持，再为拷贝操作加上=default：<br>问题就在于比如你如果不加，然后某一天突然加上了析构函数（或者其他什么）阻止了默认移动函数的构造，你仍能通过编译，并正确运行。但这时使用的是拷贝构造函数，完全没有移动的性能优势了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真绝了，没想到我又回来了学c++了&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vertx-hero-note</title>
    <link href="http://oodtoodt.github.io/2020/05/06/java-%E6%8A%80%E6%9C%AF%E6%A0%88/vertx-notes/vertx-hero-note/vertx-hero-note/"/>
    <id>http://oodtoodt.github.io/2020/05/06/java-%E6%8A%80%E6%9C%AF%E6%A0%88/vertx-notes/vertx-hero-note/vertx-hero-note/</id>
    <published>2020-05-06T02:20:31.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>ongoing</p><a id="more"></a><p>A Future表示可能已经或可能尚未发生的操作的结果。结果可能是null如果Future使用来检测操作的完成。Future对象后面的操作可能成功或失败。AsyncResult是描述操作成功或失败的结构。所以，Future是AsyncResult。在Vert.x中，AsyncResult实例是从Future类创建的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ongoing&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>blueprint-todo-note</title>
    <link href="http://oodtoodt.github.io/2020/04/30/java-%E6%8A%80%E6%9C%AF%E6%A0%88/vertx-notes/blueprint-todo-note/blueprint-todo-note/"/>
    <id>http://oodtoodt.github.io/2020/04/30/java-%E6%8A%80%E6%9C%AF%E6%A0%88/vertx-notes/blueprint-todo-note/blueprint-todo-note/</id>
    <published>2020-04-30T03:25:37.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>整蒙了，人傻了，困顿了</p><a id="more"></a><h2 id="关于避免回调地狱"><a href="#关于避免回调地狱" class="headerlink" title="关于避免回调地狱"></a>关于避免回调地狱</h2><p>回调地狱基本上是异步避免不了要面对的问题，最后就是怎么解决的问题。</p><p>比如我来上两段(三段)代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--hell</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    client.getConnection(conn -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(conn.succeeded()) &#123;</span><br><span class="line">            <span class="keyword">final</span> SQLConnection connection = conn.result();</span><br><span class="line">            connection.execute(SQL_CREATE, res -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!res.succeeded()) &#123;</span><br><span class="line">                    res.cause().printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概应该是这样的，因为我也是比着画瓢，实践的话太过麻烦了。我们发现最后这个<code>});}});}</code>应当可以称作最初的回调地狱了。<br>因为嵌套过多，也无法重用，所以其实没有看起来的那么香(但是我确实觉得这种逻辑非常好，符合人思考的方向).<br>我们来看看vertx.core中的Future可以如何做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Future&lt;Boolean&gt; result = Future.future();</span><br><span class="line">  client.getConnection(connHandler(result, connection -&gt;</span><br><span class="line">    connection.execute(SQL_CREATE, create -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (create.succeeded()) &#123;</span><br><span class="line">        result.complete(<span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.fail(create.cause());</span><br><span class="line">      &#125;</span><br><span class="line">      connection.close();</span><br><span class="line">    &#125;)));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt; connHandler(Future future, Handler&lt;SQLConnection&gt; handler) &#123;</span><br><span class="line">  <span class="keyword">return</span> conn -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (conn.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">final</span> SQLConnection connection = conn.result();</span><br><span class="line">      handler.handle(connection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      future.fail(conn.cause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好！现在代码可以重用了，而且可读性也没有降低什么，回调地狱的情况也随之减轻。<br>这里的代码应当还有很大的优化空间，因为这里用的Future版本应该比较老旧，如果使用compose等方法，我觉得这里可以更优化。但是因为代码逻辑的问题，我也不太想改它…<br>但是我们来看看更吓人的…rxjava2<br>不喜欢回调，那么对异步流处理最好的可能就是rx</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Completable <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> client.rxGetConnection()</span><br><span class="line">        .flatMapCompletable(connection -&gt; connection.rxExecute(SQL_CREATE).doOnTerminate(connection.close()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emm，你也许会反驳说着是封装，这根本不是简化，那确实我只能反驳反驳说上面其实也不过是封装。但是这确实吊啊。</p><h2 id="关于idea"><a href="#关于idea" class="headerlink" title="关于idea.."></a>关于idea..</h2><p>好多坑啊。<br>其实主要是maven导入的问题，总感觉idea会记住某些神奇的配置然后将错就错，哪怕你改了他也无动于衷，于是诸如「找不到主类」「找不到符号」此类的问题层出不穷，它们共同的特点就是甩锅，把矛头指向别的奇怪的地方。<br>具体来说，如果某个依赖自己依赖了其他的依赖，除非必要，尽量不要覆盖他</p><p>要先ctrl进去download source才能看到javadoc。</p><p>当一层里面套了两个已经Deprecated的回调的时候，第二层就不吃了，开始疯狂划线</p><h2 id="rxjava"><a href="#rxjava" class="headerlink" title="rxjava"></a>rxjava</h2><p>我其实真不会了…说一些要注意的点吧</p><p>map的层数和嵌套的问题，注意谁是谁的参数<br>idea有时会即时显示返回值，这还真挺好的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整蒙了，人傻了，困顿了&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>7周7并发模型-2</title>
    <link href="http://oodtoodt.github.io/2020/04/27/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/7%E5%91%A87%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/7%E5%91%A87%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-2/"/>
    <id>http://oodtoodt.github.io/2020/04/27/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/7%E5%91%A87%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/7%E5%91%A87%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-2/</id>
    <published>2020-04-27T05:48:08.000Z</published>
    <updated>2020-07-16T02:47:55.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="后面就没耐心看了，随便记记东西吧"><a href="#后面就没耐心看了，随便记记东西吧" class="headerlink" title="后面就没耐心看了，随便记记东西吧"></a>后面就没耐心看了，随便记记东西吧</h2><h2 id="抛弃可变状态"><a href="#抛弃可变状态" class="headerlink" title="抛弃可变状态"></a>抛弃可变状态</h2><p>可变状态因为被内部隐藏，所以可能会发生逃逸的状况，如果有一种不使用可变状态的方法，就可以避开这些风险。</p><p>clojure…</p><h3 id="写一个求和函数吧"><a href="#写一个求和函数吧" class="headerlink" title="写一个求和函数吧"></a>写一个求和函数吧</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [] numbers)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> accumulator = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:numbers) accumulator += n;</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那再看看clojure的</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> re-sum [numbers]</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">empty?</span></span> numbers)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">first</span></span> numbers) (<span class="name">re-sum</span> (<span class="name"><span class="builtin-name">rest</span></span> numbers)))))</span><br></pre></td></tr></table></figure><p>递归，无穷<code>)</code><br>不错，让我们看下更好的。运用reduce函数——化简函数、初始值和集合来调用，可以为集合的每一个元素调用化简函数</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> reduce-sum [numbers]</span><br><span class="line">    (<span class="name"><span class="builtin-name">reduce</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [acc x] (<span class="name"><span class="builtin-name">+</span></span> acc x)) <span class="number">0</span> numbers))</span><br></pre></td></tr></table></figure><p>这里用fn定义了一个匿名化简函数。<br>还可以继续改进</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> sum [numbers]</span><br><span class="line">    (<span class="name"><span class="builtin-name">reduce</span></span> + numbers))</span><br></pre></td></tr></table></figure><h3 id="wikipedia词频统计函数式版本"><a href="#wikipedia词频统计函数式版本" class="headerlink" title="wikipedia词频统计函数式版本"></a>wikipedia词频统计函数式版本</h3><p>先写一个串行版本，需要三个函数：</p><ol><li>接受dump，返回其中的页面序列</li><li>接受一个页面，返回页面上的词序列</li><li>接受一个词序列，返回含有词频的map。<br>我们只关注第三个函数，毕竟主题不是xml或字符串处理<br>函数式map，来！<br>get从map中查找，找不到返回默认值。assoc接受一个map和键值对，返回一个包含新键值对的新map(或覆盖)<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> word-fre [words]</span><br><span class="line">    (<span class="name"><span class="builtin-name">reduce</span></span></span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [counts word] (<span class="name"><span class="builtin-name">assoc</span></span> counts word (<span class="name"><span class="builtin-name">inc</span></span> (<span class="name"><span class="builtin-name">get</span></span> counts word <span class="number">0</span>))))</span><br><span class="line">    &#123;&#125; words))</span><br></pre></td></tr></table></figure>翻译过来就是：从counts取出word或0,，自增，向counts的word里添加该元素，这就是reduce会调用的fn函数。<br>好，其实clojure标准库里有一个类似的可以针对任何集合的frequencies函数，输出每个元素出现次数<br>再了解几个函数：<br>map函数接受一个函数f和一序列，并返回新的序列，对于输入序列中的每个元素都会调用一次f，并以元素值为参数，返回值作为新序列的对应元素<code>(map (fn [x] (* 2 x)) [0 1 2 3 4 5])</code>可以实现数组翻倍<br>partial函数接受一个函数和若干餐宿，返回一个被局部代入的函数<code>(map (partial * 2) [0 1 2 3 4 5])``（f(a,b,c)，partial(f,1)返回的是f(1,b,c)</code>这就叫局部代入<br>可以用正则来操作字符串：<code>(defn get-words [text] (re-seq #&quot;\w+&quot; text))</code><br>需要将二维序列输出为一维，有mapcat<br>好了我们可以开始了<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> count-wrds-seq [pages]</span><br><span class="line">    (<span class="name">frequencies</span> (<span class="name"><span class="builtin-name">mapcat</span></span> get-words pages)))</span><br></pre></td></tr></table></figure>没错，就结束了。</li></ol><h3 id="自习"><a href="#自习" class="headerlink" title="自习"></a>自习</h3><p>这次自习的内容很少<br>惰性序列指你不主动去遍历就不会计算其中元素的值的序列。</p><p>注意clojure不支持尾调用消除，因为clojure很少使用递归。重写recursive-sum用loop和recur替换递归</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> re-sum [numbers]</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">empty?</span></span> numbers)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">first</span></span> numbers) (<span class="name">re-sum</span> (<span class="name"><span class="builtin-name">rest</span></span> numbers)))))</span><br><span class="line"><span class="comment">;;----------------------------------------</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> Example [numbers]</span><br><span class="line">    (<span class="name"><span class="builtin-name">loop</span></span> [x <span class="number">0</span>] </span><br><span class="line">        when (<span class="name"><span class="builtin-name">seq</span></span> numbers)</span><br><span class="line">            (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">+</span></span> x (<span class="name"><span class="builtin-name">first</span></span> numbers))))</span><br></pre></td></tr></table></figure><p>我很想，但是这个数组布置之类的…我真的好急。<br>然后这真的有点…写起来别扭,然后我觉得差不多意思意思就行了，下一章！</p><h2 id="函数式并行"><a href="#函数式并行" class="headerlink" title="函数式并行"></a>函数式并行</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;后面就没耐心看了，随便记记东西吧&quot;&gt;&lt;a href=&quot;#后面就没耐心看了，随便记记东西吧&quot; class=&quot;headerlink&quot; title=&quot;后面就没耐心看了，随便记记东西吧&quot;&gt;&lt;/a&gt;后面就没耐心看了，随便记记东西吧&lt;/h2&gt;&lt;h2 id=&quot;抛弃可变状态&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/categories/java/"/>
    
      <category term="book_notes" scheme="http://oodtoodt.github.io/categories/java/book-notes/"/>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/tags/java/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="concurrent" scheme="http://oodtoodt.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>7周7并发模型-第一周</title>
    <link href="http://oodtoodt.github.io/2020/04/24/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/7%E5%91%A87%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/7%E5%91%A87%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-1/"/>
    <id>http://oodtoodt.github.io/2020/04/24/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/7%E5%91%A87%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/7%E5%91%A87%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-1/</id>
    <published>2020-04-24T11:31:59.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>起初还在想这么薄的书怎么能学七周呢，原来大部分内容都隐藏在作业里自学了。<br>第一周参上</p><a id="more"></a><!-- TOC --><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81">线程与锁</a><ul><li><a href="#%E4%BA%92%E6%96%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">互斥与内存模型</a><ul><li><a href="#%E4%BD%9C%E4%B8%9A">作业</a><ul><li><a href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">内存模型</a><ul><li><a href="#jsr-133">jsr 133</a></li><li><a href="#%E9%87%8D%E6%8E%92%E5%BA%8F">重排序</a></li><li><a href="#final">final</a></li><li><a href="#volatile">volatile</a></li></ul></li><li><a href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81">双重检查锁</a><ul><li><a href="#%E5%8F%8D%E6%A8%A1%E5%BC%8F">反模式</a></li></ul></li><li><a href="#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">对象初始化的线程安全</a></li></ul></li></ul></li><li><a href="#%E8%B6%85%E8%B6%8A%E5%86%85%E7%BD%AE%E9%94%81">超越内置锁</a><ul><li><a href="#reentrantlock">ReentrantLock</a></li><li><a href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F">条件变量</a></li><li><a href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F">原子变量</a></li><li><a href="#%E8%87%AA%E4%B9%A0">自习</a><ul><li><a href="#reentrantlock">ReentrantLock</a></li><li><a href="#reentrantlock">ReentrantLock</a></li><li><a href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92">虚假唤醒</a></li><li><a href="#atomicintegerfieldupdater">AtomicIntegerFieldUpdater</a></li></ul></li></ul></li><li><a href="#%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A">站在巨人的肩膀上</a><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a></li><li><a href="#%E5%86%99%E5%85%A5%E6%97%B6%E5%A4%8D%E5%88%B6">写入时复制</a></li><li><a href="#%E4%B8%80%E4%B8%AA%E7%BB%9D%E5%A5%BD%E7%9A%84%E4%BE%8B%E5%AD%90">一个绝好的例子</a></li><li><a href="#%E8%87%AA%E4%B9%A0">自习</a><ul><li><a href="#forkjoinpool">forkjoinpool</a></li><li><a href="#work-stealing">work-stealing</a></li><li><a href="#countdownlatch%E4%B8%8Ecyclicbarrier">CountDownLatch与CyclicBarrier</a></li><li><a href="#%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B">阿姆达尔定律</a></li><li><a href="#%E5%8F%A4%E6%96%AF%E5%A1%94%E5%A4%AB%E6%A3%AE%E5%AE%9A%E5%BE%8B">古斯塔夫森定律</a></li><li><a href="#%E6%AF%92%E4%B8%B8">毒丸</a></li></ul></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="线程与锁"><a href="#线程与锁" class="headerlink" title="线程与锁"></a>线程与锁</h1><h2 id="互斥与内存模型"><a href="#互斥与内存模型" class="headerlink" title="互斥与内存模型"></a>互斥与内存模型</h2><p>多线程的主要问题的就是竞态，即代码行为取决于各操作的时序。<br>解决方案是对count进行同步(synchronize)访问。一种是使用java原生的内置锁(互斥锁mutex、管程(monitor)或临界区(critical section))来同步调用。<br><strong>乱序执行是完全有可能发生的</strong><br>不论是c还是java，编译器都有静态优化，硬件上也会有乱序执行，jvm还有动态优化。<br>原则上，如果读线程和写线程不进行同步就不保证可见性（可见性就是..某个变量在这里赋值在另一边能不能取到）<br>死锁。哲学家吃饭先左后右直到所有人都把左手筷子拿起。<br>简单的避免是给锁添加一个全局顺序，比如每个人按筷子序号拿而非先左后右的顺序，则不会出现死锁。<br>不要调用外星方法：你无从知道外星方法会不会也持有一把锁。它可能会做任何事情。<br>避免的一种方法是在遍历之前对listeners进行保护性复制，再针对副本进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateProgress</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArrayList&lt;ProgressListener&gt; listenersCopy;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        listenersCopy = (ArrayList&lt;ProgressListener&gt;) listeners.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ProgressListener listener: listenersCopy)</span><br><span class="line">        listener.onProgress(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来就不会把整个方法编程synchronized，不仅在外星方法时无锁，还大大减少了代码持有锁的时间，甚至如果修复了在遍历时remove的错误。</p><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul><li><del>todo</del> 自学JSR 133的FAQ</li><li><del>todo</del> java内存模型如何保证对象初始化线程安全？是否必须加锁才能在线程之间安全地公开对象？</li><li><del>todo</del> 双重检查锁，反模式</li><li><del>todo</del> william pugh 的网站：java内存模型</li></ul><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>在处理器级别，一个内存模型定义应该实现的充分必要条件（necessary and sufficient conditions）是其它处理器写入内存的数据对于当前处理器是可见的，当前处理器写入内存的数据对其它处理器也是可见的。如果是一个强大的内存模型（a strong memory model），那么所有处理器在任何时候读取内存中任何位置，都能得到一样的值；而对于较弱的内存模型（a weaker memory model），只有在特殊情况下，通过调用内存栅栏（where special instructions, called memory barriers）将缓存数据刷新或者失效（flush or invalidate the local processor cache），这样才能获取其它处理器处理后的数据或者让其它处理器知道当前处理器处理的数据。这些内存栅栏（memory barriers）通常在加锁和解锁操作的时候执行；它们对于高级语言（a high level language）而言是不可见的。<br>当前处理器设计的趋势是鼓励弱内存模型，因为弱内存模型对于缓存一致性（多处理器同时涉及同一主内存）的放宽使得多处理器和大内存有更大的可扩展性<br>当前线程的写操作何时对其它线程可见，这个问题因为编译器的重排序而变得复杂。比如，编译器可能会觉得往后移动一个写操作会更加有效率；只要这个代码移动不会改变程序语义，这样做没有任何问题。如果编译器推迟了一个操作，只有到程序运行完成，其它线程才能看见数据的变化，这就是缓存的作用。(由于缓存的存在，指令重排序不会马上影响到内存中数据的变化，因为操作缓存数据即可)<br>Java 内存模型描述了在多线程代码中，哪种行为是合法的，以及线程之间如何通过内存交互。它描述了程序中变量之间的关系，以及在实际计算机的内存或者寄存器中存储和检索它们的低级细节。它可以通过各种各样的硬件和各种各样的编译器优化来实现</p><p>Java 内存模型是为了屏蔽不同硬件处理器架构以及指令重排序对程序的并发影响而提出的一套规范，保证正确应用这套规范的程序可以在任何硬件处理器上都能够执行正确的并发操作。</p><p>资料指出，包括了缓存导致的内存可见性（线程更新对象对其他线程不可见）和重排序的可见性；指令序列的重排序；数据依赖；</p><hr><p>pc寄存器 java虚拟机栈 本地方法栈<br>   java堆          方法区(Runtime Constant Pool)<br>—上面是java虚拟机内的内存<br>所有线程共享的数据 各个线程共享的数据 运行时常量</p><hr><p>可能有点小错误，不过概念部分问题不大[<a href="https://www.jianshu.com/p/76959115d486]" target="_blank" rel="noopener">https://www.jianshu.com/p/76959115d486]</a></p><ol><li>pc寄存器(程序计数器)<br>(线程私有)的存在是为了线程切换可以恢复到正确执行位置</li><li>java栈(虚拟机栈)<br>(线程私有)，描述的是java方法执行的内存模型。<strong>每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong><blockquote><p>栈帧: 是用来存储数据和部分过程结果的数据结构。<br>栈帧的位置:  内存 -&gt; 运行时数据区 -&gt; 某个线程对应的虚拟机栈 -&gt; ?<br>栈帧大小确定时间: 编译期确定，不受运行期数据影响。</p></blockquote></li></ol><p>平时说的栈一般指局部变量表部分<br>  是一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型(指向一条字节码指令的地址)。<br>需要注意的是，局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小。<br>3. 本地方法栈<br>是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。<br>4. 堆<br>堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制<br>所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。<br>  逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。<br>  它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代，再细致点还有Eden(伊甸园)空间之类的不做深究。<br>5. 方法区<br>方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。<br>用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。<br>方法区有很多实现，java8中废弃了永久代，使用了元空间。</p><hr><p>java线程-工作内存-（save和load）|是一体-&gt;(主)<br>java线程-工作内存-（save和load）|是一体-&gt;(内)<br>java线程-工作内存-（save和load）|是一体-&gt;(存)</p><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。<br>Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。</p><h5 id="jsr-133"><a href="#jsr-133" class="headerlink" title="jsr 133"></a>jsr 133</h5><p>JSR，Java Sepcification Requests，Java 规范提案<br>JSR 133： Java Memory Model and Thread Specification，Java 内存模型与线程规范<br>JSR 133 定义了一个新的内存模型，修复了之前内存模型的缺陷。为实现这一目的，final 和 volatile 的语义会有所变化。</p><h5 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h5><p>重排序指的是程序在编译，加载，链接，运行的过程中，随时都有可能程序指令被重新排列，同时，这一过程也会给上层显示有一种按序执行的假象。对于单线程程序，不需要关心重排序带来的影响；对于多线程程序，如果访问同一个变量，重排序可能会影响结果的正确性，所以需要同步。</p><p>新的内存模型在内存操作（写操作，读操作，加锁，解锁）和其它线程操作（start 和 join）中执行部分排序，就是说一些操作一定会在另一些操作之前，称之为 happens-before</p><p>这种排序规则如下：</p><p>当前线程的每一个动作都 happens-before 程序中后来的线程<br>对同一个监视器的解锁操作 happens-before 后续的加锁操作<br>对一个 volatile 变量的读操作 happens-before 后续对同一个变量的读操作<br>对一个线程的 start() 调用 happens-before 这个线程启动后的任何动作<br>当前线程的所有动作都 happens-before 其它线程（对当前线程执行 join() 操作）</p><p>保证进入同步块的线程操作对于其它阻塞在同一个监视器的线程可见。</p><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>final 字段的值可以在对象构造器中设置。假设对象被“正确”的构造，那么一旦对象构造完成，这个 final 字段的值将被所有线程可见，不需要同步操作。另外，final 字段引用的其它对象或数组改变后，final 字段的值也一定会改变</p><p>怎么样才是对象被正确的构造？简单的说，对象引用不应该在构造期间”泄露”。（举例：Safe construction techniques）换句话说，不应该放置构造期间的对象引用在另一个线程可能会看到它的地方；不要赋值给静态字段；不要将其注册为其它对象的监听器，等等。这些事情应该在构造完成后操作，而不是在构造期间。</p><blockquote><p>不要在构造器中使用 “this” 引用。如果无法避免，确保它不会对其它线程可见；<br>不要在构造器中创建非静态内部类；<br>不要再构造器中启动线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalFieldExample</span><span class="params">()</span> </span>&#123; <span class="comment">// bad!</span></span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line">  y = <span class="number">4</span>;</span><br><span class="line">  <span class="comment">// bad construction - allowing this to escape</span></span><br><span class="line">  global.obj = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样无法保证能够看到正确的final变量值，因为线程读取了this引用，通过指令重排序final变量就泄露了当前对象的引用。</p><p>如果字段是 final 修饰的，那么能够保证构造器结束后，代码能够看到该字段所指向的对象或者数组最新的值。所以，这种情况下，不需要担心其它线程看见了这个字段引用指向的数组，但是看不到数组最新的值。再次声明，这个 “正确” 指的是 “对象构造器结束时最新的值” 而不是 “最新有效的值”</p><p>正确构造后的 final 字段能够被所有线程可见，但是无法确定 final 字段引用的数组或者对象是最新的值，所以需要结合实际程序，在多线程情况下最好是执行同步操作。</p><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>在新内存模型中， volatile 变量仍旧无法被重排序，差异是 volatile 变量周围的正常变量也不会很容易被重排序<br>实际上，因为新的内存模型对 volatile 字段对其周围字段访问设置了更严格的约束条件，当线程 A 写入 volatile 字段 f 时，任何对线程 A 可见的变量也对写入字段 f 的线程 B 可见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//uses x - guaranteed to see 42.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，volatile 的语义基本上加强到同步的水平。对 volatile 字段的每一次读和写就像半个同步操作，即保证了可见性。</p><p><strong>final 和 volatile 不能同时使用，会产生编译错误</strong></p><h4 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h4><p>简单的说，单例模式下多线程同时可能造成多实例。所以要加锁，双重检查锁就是对单锁的优化（单锁性能开销过大了因为每次都要进synchronize方法判断）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;<span class="comment">//!!!! must have volatile</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> Singleton();   <span class="comment">// error</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查是否初始化，获取锁，再次检查是否初始化，这样只有在初始化的时候才会出现加锁的情况，而且避免了问题。<br>问题在于这里error的那行代码，也会有三步：分配内存空间、初始化对象、将对象指向刚分配的内存空间。这里的二三步是可能重排序的。<br>133的volatile解决了这个问题。</p><h5 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h5><p>该模式在某些语言在某些硬件平台的实现可能是不安全的。有的时候，这一模式被看做是反模式。<br>…………我tm觉得这个百度百科给出来的就很搞笑。</p><h4 id="对象初始化的线程安全"><a href="#对象初始化的线程安全" class="headerlink" title="对象初始化的线程安全"></a>对象初始化的线程安全</h4><p>初始化顺序：初始化类变量(并未赋值)，执行静态代码块和类变量定义式，初始化实例变量，执行构造代码块和实例变量定义赋值式，执行构造函数</p><p>在执行类的初始化期间，JVM会去获取一个锁，会造成隐蔽的线程阻塞</p><p>final可以公开对象，但正如上面所说，难以保证是最新的正确的值。</p><h2 id="超越内置锁"><a href="#超越内置锁" class="headerlink" title="超越内置锁"></a>超越内置锁</h2><p>J.U.C</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock可以中断，可以设置超时<br>交替锁。比如我们想要在链表中插入一个节点。我们只需要锁住链表的一部分即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSortedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> value, Node prev, Node next) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value; <span class="keyword">this</span>.prev = prev; <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSortedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node(); tail = <span class="keyword">new</span> Node();</span><br><span class="line">    head.next = tail; tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//insert方法是有序的 遍历列表直到找到第一个值小于等于新插入的值得节点,在这个位置插入</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    Node current = head;</span><br><span class="line">    current.lock.lock();</span><br><span class="line">    Node next = current.next;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        next.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (next == tail || next.value &lt; value) &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(value, current, next);</span><br><span class="line">            next.prev = node;</span><br><span class="line">            current.next = node;</span><br><span class="line">              <span class="comment">//!!!这里return要在两个finally都执行完后才会执行啊!!!但只是finally里的.不过要是return换成exit(0)就直接退出了</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; current.lock.unlock(); &#125;</span><br><span class="line">        current = next;</span><br><span class="line">        next = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; next.lock.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node current = tail;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current.prev != head) &#123;</span><br><span class="line">      ReentrantLock lock = current.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        current = current.prev;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node current = head;</span><br><span class="line">    <span class="keyword">while</span> (current.next.next != tail) &#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">if</span> (current.value &lt; current.next.value)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ConcurrentSortedList list = <span class="keyword">new</span> ConcurrentSortedList();</span><br><span class="line">    <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">          list.insert(random.nextInt());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CountingThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">          System.out.print(<span class="string">"\r"</span> + list.size());</span><br><span class="line">          System.out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> TestThread();</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> TestThread();</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> CountingThread();</span><br><span class="line">    <span class="comment">//注意一下这里的用法 这里先join再interrupted的用法</span></span><br><span class="line">    t1.start(); t2.start(); t3.start();</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">    t3.interrupt();</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">"\r"</span> + list.size());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (list.size() != <span class="number">20000</span>)</span><br><span class="line">      System.out.println(<span class="string">"*** Wrong size!"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!list.isSorted())</span><br><span class="line">      System.out.println(<span class="string">"*** Not sorted!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很有参考价值的代码。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>用一把锁，将竞争才能够对筷子的争夺换成对状态的判断：仅当哲学家左右邻座没有进餐时，才可以进餐。换句话说，一个哲学家饥饿时，他首先锁住餐桌。这样其他哲学家无法改变状态，然后查一下左右是否进餐，没有则自己进餐并解锁餐桌，否则调用await()以解锁餐桌。吃完了开始思考就先锁住餐桌然后通知左右餐桌可以吃了。如果左右正在等待，他们将被唤醒重新锁住餐桌判断进餐。<br>看上去复杂得多，但是并发度显著提升。几乎可以确定可以有多个哲学家在一起吃饭，而不是拿着一根筷子干等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> eating;</span><br><span class="line">    <span class="keyword">private</span> Philosopher left;</span><br><span class="line">    <span class="keyword">private</span> Philosopher right;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock table;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thinkCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span> <span class="params">( ReentrantLock table )</span> </span>&#123;</span><br><span class="line">        eating = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">        condition = table.newCondition();</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span> <span class="params">( Philosopher left )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span> <span class="params">( Philosopher right )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="keyword">true</span> ) &#123;</span><br><span class="line">                think();</span><br><span class="line">                eat();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( InterruptedException e ) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">think</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        table.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eating = <span class="keyword">false</span>;</span><br><span class="line">            left.condition.signal();</span><br><span class="line">            right.condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            table.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        ++thinkCount;</span><br><span class="line">        <span class="keyword">if</span> ( thinkCount % <span class="number">10</span> == <span class="number">0</span> ) &#123;</span><br><span class="line">            System.out.println( <span class="string">"Philosopher "</span> + <span class="keyword">this</span> + <span class="string">" has thought "</span> + thinkCount + <span class="string">" times"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep( <span class="number">1000</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        table.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ( left.eating || right.eating ) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            eating = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            table.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep( <span class="number">1000</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h3><p>原子变量时<em>无锁非阻塞算法</em>的基础。可以不用锁和阻塞来达到同步的目的。无锁比有锁的代码更复杂。<br>volatile是一种低级形式的同步，它并不能解决Counter的问题(指不能保证count++的操作似乎原子的)。他保证的是变量无法被重排序，但是竞态是无法避免的，两个线程还是可能同时访问这个变量然后出现问题。现在已经有了很多低开销锁，尽量不要用volatile。</p><h3 id="自习"><a href="#自习" class="headerlink" title="自习"></a>自习</h3><p>他又来了！</p><ul><li>ReentrantLock创建时可以设置一个描述公平性的变量。什么是公平的锁？</li><li>什么是ReentrantReadWriteLock？和我们提到的那个有什么区别？</li><li>什么是「虚假唤醒」？</li><li>什么是AtomicIntegerFiledUpdater?</li></ul><h4 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>fair - true if this lock should use a fair ordering policy<br>哈哈，忘了吧（。<br>公平表示所有线程会不会以fifo的顺序来获取锁。公平锁一般用来防止「饥饿」的产生。</p><h4 id="ReentrantLock-2"><a href="#ReentrantLock-2" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><blockquote><p>ReentrantReadWriteLock按照字面意思是读写锁，如果你把它理解为对IO的控制，那就大错特错了（其实大多数人的直觉是这样）。其实你只要把它理解成一个数据库的事务锁就对了。众所周知数据库事务锁的特点就是，读写分离。而ReentrantReadWriteLock是类似最高级的事务级别Serializable可串行化（严格讲比这个还更严谨）。什么意思呢，意思就是，对一条数据的更新操作只影响其它对该条数据的更新操作，而读操作是不影响的。   而并发锁Lock也好，synchronizy也好，是直接把读写都锁住的。就是说，该代码块一但锁住之后，既不能读也不能写。 但这样是有问题的，有些线程只是想读取一下数据，我又不改数据，你锁它干嘛呢？（类似事物吧） 所以ReentrantReadWriteLock把锁拆分成了读锁和写锁。  写锁之间的互斥的，但读锁不互斥（大家一起读数据么，压根就没冲突）。 但是有一点要注意。就是你想获取写锁，是除当前线程外，不能存在其它的读锁的。  好比就是说，我要改里面的数据了，那些获取了读锁的线程，必须通通退出来，否则会出现读到老数据的问题（类似事物里面的脏读） ，获取到写锁之后，其它线程也不能再获取到读锁了。</p></blockquote><p>升级的意思就是，读锁在获取写锁之前，一定要先释放读锁。</p><h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><p>线程可能在没有嗲用过notify或notifyAll的情况下醒来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</span><br><span class="line">  <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!wasSignalled)&#123;<span class="comment">//must be while!!!!</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          myMonitorObject.wait();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//clear signal and continue running.</span></span><br><span class="line">      wasSignalled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      wasSignalled = <span class="keyword">true</span>;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Windows API和posix Thread在signal thread时，可能会一次唤醒多个thread，这种看似bug的实现，因为概率极低不影响效率演进为一种通用并发模式<br>详见effective java item69<br>即使从等待线程的角度看似已经发出了条件变量的信号之后，等待的条件仍可能为假。原因之一是虚假的唤醒。也就是说，即使没有线程向条件变量发出信号，线程也可能从等待状态中唤醒。为了正确起见，然后有必要在线程完成等待之后验证条件确实为真。由于虚假唤醒可能会重复发生，因此可以通过在条件为真时终止的循环内部等待来实现。</p><h4 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h4><p>这个类是一个基于反射的使用的工具类，可以对指定类的指定的被volatile修饰的int型字段进行原子更新。<br>这个类设计用于同一节点的多个字段独立进行的原子更新的原子数据结构<br>类似于我不要求你这整个类操作具有原子性，我只要求你里面一个字段操作具有原子性。</p><p>注意：这个类中的CAS操作弱于其他的原子类，因为没法确保这个字段的所有访问和操作都是基于原子操作的，只能提供对同一个Updater的compareAndSet和set方法的保证</p><p>有些规则：字段必须是volatile类型的，在线程之间共享变量时保证立即可见等等。</p><h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><p>J.U.C中包含了一些「通用高效bug少」的并发数据结构和工具。我们应该更多的使用他们。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>如果为每个连接创建一个线程，当请求连接的速度高于处理连接的速度时，系统的线程数也会随之快速增长，服务器将停止服务甚至崩溃。这就给了拒绝服务攻击可乘之机。为每个连接都创建线程的代价也无法忽视。<br>我们可以使用线程池避免这些问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池的大小设置为可用处理器数的2倍</span></span><br><span class="line"><span class="keyword">int</span> threadPoolSize = Runtime.getRuntime().availableProcessors() * <span class="number">2</span>;</span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(threadPoolSize);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  Socket socket = server.accept();</span><br><span class="line">  executor.execute(<span class="keyword">new</span> ConnectionHandler(socket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入时复制"><a href="#写入时复制" class="headerlink" title="写入时复制"></a>写入时复制</h3><p>记得我们放过一个保护性复制吗？外星那里。java标准库提供了优雅的现成方案：CopyOnWriteArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---皆是方法</span></span><br><span class="line"> <span class="keyword">private</span> CopyOnWriteArrayList&lt;ProgressListener&gt; listeners;         <span class="comment">//使用一个写入时拷贝对象。当原对象要发生写入的时候，对其做一份克隆，然后对克隆对象操作。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Downloader</span><span class="params">(URL url, String outputFilename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    in = url.openConnection().getInputStream();</span><br><span class="line">    out = <span class="keyword">new</span> FileOutputStream(outputFilename);</span><br><span class="line">    listeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;ProgressListener&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(ProgressListener listener)</span> </span>&#123;</span><br><span class="line">    listeners.add(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(ProgressListener listener)</span> </span>&#123;</span><br><span class="line">    listeners.remove(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateProgress</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ProgressListener listener: listeners)</span><br><span class="line">      listener.onProgress(n);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//---</span></span><br></pre></td></tr></table></figure><h3 id="一个绝好的例子"><a href="#一个绝好的例子" class="headerlink" title="一个绝好的例子"></a>一个绝好的例子</h3><p>解决一个世纪的小问题：Wikipedia上出现频率最高的词是什么？<br>看上去似乎并不难。我们先从基本的开始：<br>一个简单的串行程序统计前100000页的词要花多久？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Iterable&lt;Page&gt; pages = <span class="keyword">new</span> Pages(<span class="number">100000</span>, <span class="string">"enwiki.xml"</span>);</span><br><span class="line">    <span class="keyword">for</span>(Page page: pages) &#123;</span><br><span class="line">        Iterable&lt;String&gt; words = <span class="keyword">new</span> Words(page.getText());</span><br><span class="line">        <span class="keyword">for</span>(String word:words)</span><br><span class="line">            countWord(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">    Integer currentCount = counts.get(word);</span><br><span class="line">    <span class="keyword">if</span>(currentCount == <span class="keyword">null</span>)</span><br><span class="line">        counts.put(word,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        counts.put(word,currentCount+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先解析并构造一个page，然后「消费」这个page，对page中的内容统计词频<br>——于是我们归结出生产者消费者模式，我们可以创建一个生产者，一个消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> BlockingQueue&lt;Page&gt; queue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Parser</span><span class="params">(BlockingQueue&lt;Page&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Iterable&lt;Page&gt; pages = <span class="keyword">new</span> Pages(<span class="number">100000</span>, <span class="string">"enwiki.xml"</span>);</span><br><span class="line">      <span class="keyword">for</span> (Page page: pages)</span><br><span class="line">        queue.put(page);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> BlockingQueue&lt;Page&gt; queue;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Integer&gt; counts;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Counter</span><span class="params">(BlockingQueue&lt;Page&gt; queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                 Map&lt;String, Integer&gt; counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    <span class="keyword">this</span>.counts = counts;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        Page page = queue.take();</span><br><span class="line">        <span class="keyword">if</span> (page.isPoisonPill())</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        Iterable&lt;String&gt; words = <span class="keyword">new</span> Words(page.getText());</span><br><span class="line">        <span class="keyword">for</span> (String word: words)</span><br><span class="line">          countWord(word);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    Integer currentCount = counts.get(word);</span><br><span class="line">    <span class="keyword">if</span> (currentCount == <span class="keyword">null</span>)</span><br><span class="line">      counts.put(word, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      counts.put(word, currentCount + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">ArrayBlockingQueue&lt;Page&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Page&gt;(<span class="number">100</span>);</span><br><span class="line">HashMap&lt;String, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">Thread counter = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Counter(queue, counts));</span><br><span class="line">Thread parser = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Parser(queue));</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">counter.start();</span><br><span class="line">parser.start();</span><br><span class="line">parser.join();</span><br><span class="line">queue.put(<span class="keyword">new</span> PoisonPill());</span><br><span class="line">counter.join();</span><br></pre></td></tr></table></figure><p>存放网页的队列可以采用ArrayBlockingQueue。它提供了高效的并发put()和take()，这些方法会在必要时阻塞：当对一个空队列take程序会阻塞直到队列非空，put()同理。之所以采用阻塞队列，是因为如果生产者的速度比消费者快很多，很容易就占用大量内存空间(指非阻塞的ConcurrentLinkedQueue)<br>毒丸对象(PoisonPill)：　“毒丸”是指一个放在队列上的对象，其含义是：“当得到这个对象时，立即停止”。自己可以定义一个毒丸对象，用于告诉消费者可以停止了。<br>运行一下，发现变快了。生产消费者模型优势显现出来：可以并行生产消费、并可以有多个生产消费者。显然整体运行时间会降到生产和消费两者中较长的时间，统计的部分。要进一步优化，就要对统计过程进行并行化，建立多个消费者。</p><p>首先我们想到由Collection包的synchronizedMap提供的<em>同步</em>的map，遗憾的是这类同步的集合并不提供原子的读-改-写的方法，所以不能使用它们，如果使用HashMap，就必须自己实现对访问的同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Integer currentCount = counts.get(word);</span><br><span class="line">      <span class="keyword">if</span> (currentCount == <span class="keyword">null</span>)</span><br><span class="line">        counts.put(word, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        counts.put(word, currentCount + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//---------启动多个消费者</span></span><br><span class="line"></span><br><span class="line">    ArrayBlockingQueue&lt;Page&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Page&gt;(<span class="number">100</span>);</span><br><span class="line">    HashMap&lt;String, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_COUNTERS; ++i)</span><br><span class="line">      executor.execute(<span class="keyword">new</span> Counter(queue, counts));</span><br><span class="line">    Thread parser = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Parser(queue));</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    parser.start();</span><br><span class="line">    parser.join();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_COUNTERS; ++i)</span><br><span class="line">      queue.put(<span class="keyword">new</span> PoisonPill());</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    executor.awaitTermination(<span class="number">10L</span>, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><p>使用了线程池，方便管理多个线程。必须使用适当数量的毒丸，保证消费者的线程都可以退出。<br>结果不如人所愿，变慢了！慢了一倍之多。<br>这是因为<strong>过度竞争</strong>————过多地线程尝试同时使用一个共享资源。在我们的程序中，消费者花费大量时间等待被其他消费者锁住的counts，等待的时间比实际运算的时间还要唱，最终导致惨烈的性能下降。<br>好在无敌的J.U.C还提供了支持原子读-改-写，使用高级并发访问（锁分段，lock striping）的<code>ConcurrentHashMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Integer currentCount = counts.get(word);</span><br><span class="line">    <span class="keyword">if</span> (currentCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (counts.putIfAbsent(word, <span class="number">1</span>) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (counts.replace(word, currentCount, currentCount + <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line">ArrayBlockingQueue&lt;Page&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Page&gt;(<span class="number">100</span>);</span><br><span class="line">ConcurrentHashMap&lt;String, Integer&gt; counts = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Integer&gt;();</span><br><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_COUNTERS; ++i)</span><br><span class="line">  executor.execute(<span class="keyword">new</span> Counter(queue, counts));</span><br><span class="line">Thread parser = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Parser(queue));</span><br></pre></td></tr></table></figure><p>使用了putIfAbsent()和replace()来取代原来的put()方法，可以查阅相关APIs的文档<br>再次进行消费者数量提升时的时间统计，发现没什么太大问题了——但是在4个以上的消费者时，提速开始下降了。<br>我们注意到消费者对counts有一些不必要的竞争。与其所有消费者都共享一个counts，还不如每个消费者各自维护一个计数map，再对计数map进行合并</p><p>如果看的细致一点，就是1点1点的多线程计数还是count+count的多线程计数。还是共享一个counts的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      Page page = queue.take();</span><br><span class="line">      <span class="keyword">if</span> (page.isPoisonPill())</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      Iterable&lt;String&gt; words = <span class="keyword">new</span> Words(page.getText());</span><br><span class="line">      <span class="keyword">for</span> (String word: words)</span><br><span class="line">        countWord(word);</span><br><span class="line">    &#125;</span><br><span class="line">    mergeCounts();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  Integer currentCount = localCounts.get(word);</span><br><span class="line">  <span class="keyword">if</span> (currentCount == <span class="keyword">null</span>)</span><br><span class="line">    localCounts.put(word, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    localCounts.put(word, currentCount + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeCounts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e: localCounts.entrySet()) &#123;</span><br><span class="line">    String word = e.getKey();</span><br><span class="line">    Integer count = e.getValue();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Integer currentCount = counts.get(word);</span><br><span class="line">      <span class="keyword">if</span> (currentCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts.putIfAbsent(word, count) == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (counts.replace(word, currentCount, currentCount + count)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成了</p><h3 id="自习-1"><a href="#自习-1" class="headerlink" title="自习"></a>自习</h3><ul><li>阅读ForkJoinPool的文档，fork/join框架与线程池有什么区别？</li><li>什么是work-stealing？适用于什么场景？J.U.C提供了什么工具实现它？</li><li>CountDownLatch和CyclicBarrier有什么区别？分别适用什么？</li><li>什么是阿姆达尔定律？如何计算出词频统计程序的最大理论加速比？</li><li>为什么毒丸方法会被广泛采用？</li></ul><h4 id="forkjoinpool"><a href="#forkjoinpool" class="headerlink" title="forkjoinpool"></a>forkjoinpool</h4><p>Fork/Join并行方式是获取良好的并行计算性能的一种最简单同时也是最有效的设计技术。Fork/Join并行算法是我们所熟悉的分治算法的并行版本。fork操作将会启动一个新的并行Fork/Join子任务。join操作会一直等待直到所有的子任务都结束。Fork/Join算法，如同其他分治算法一样，总是会递归的、反复的划分子任务，直到这些子任务可以用足够简单的、短小的顺序方法来执行。</p><p>ForkJoinPool 的另一个特性是它使用了work-stealing（工作窃取）算法：线程池内的所有工作线程都尝试找到并执行已经提交的任务，或者是被其他活动任务创建的子任务（如果不存在就阻塞等待）。这种特性使得 ForkJoinPool 在运行多个可以产生子任务的任务，或者是提交的许多小任务时效率更高。尤其是构建异步模型的 ForkJoinPool 时，对不需要合并（join）的事件类型任务也非常适用。<br>线程池中每个工作线程（ForkJoinWorkerThread）都对应一个任务队列（WorkQueue），工作线程优先处理来自自身队列的任务（LIFO或FIFO顺序，参数 mode 决定），然后以FIFO的顺序随机窃取其他队列中的任务。在一个线程正在偷取任务时，另外一个线程是无法完成偷取操作的。大体上讲，我们起码有一定概率保证了阻塞性。如果一个偷取操作失败，偷取线程会选择另外一个随机目标继续尝试。。</p><p>fork:当前线程不是个ForkJoinWorkerThread的时候，则加入到ForkJoinPool线程池(基于ExecutorService实现);<br>如果当前线程已经是个ForkJoinWorkerThread了，则把这个任务加入到当前线程的workQueue;<br>这是和普通线程池不同的地方，task并不是交给线程池中的queue，而是放到线程本地的workQueue</p><p>大致上可以认为是ForkJoinPool每个线程都有自己的队列,ThreadPoolExecutor共用一个队列。</p><p>ForkJoinPool最适合计算密集型任务，而且最好是非阻塞任务。<br>偷的话很简单，双向队列。cas解决竞争(最后一个或争抢)。</p><h4 id="work-stealing"><a href="#work-stealing" class="headerlink" title="work-stealing"></a>work-stealing</h4><p>上面讲了，还是写下吧</p><ol><li>每个线程都有自己的双端队列</li><li>当调用fork方法时，将任务放进队列头部，线程以LIFO顺序，使用push/pop方式处理队列中的任务</li><li>如果自己队列里的任务处理完后，会从其他线程维护的队列尾部使用poll的方式窃取任务，以达到充分利用CPU资源的目的</li><li>从尾部窃取可以减少同原线程的竞争</li><li>当队列中剩最后一个任务时，通过cas解决原线程和窃取线程的竞争</li></ol><h4 id="CountDownLatch与CyclicBarrier"><a href="#CountDownLatch与CyclicBarrier" class="headerlink" title="CountDownLatch与CyclicBarrier"></a>CountDownLatch与CyclicBarrier</h4><p><a href="https://www.jianshu.com/p/bce9f156080f" target="_blank" rel="noopener">https://www.jianshu.com/p/bce9f156080f</a><br>CountDownLatch是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，再继续执行。<br>CyclicBarrier是一个同步的辅助类，允许一组线程相互之间等待，达到一个共同点，再继续执行。<br>他们都是:Synchronization aid，我把它翻译成同步辅助器，既然是辅助工具，怎么使用啊？哪些场景使用啊？</p><ul><li>CountDownLatch是不可重置的，所以无法重用；而CyclicBarrier则没有这种限制，可以重用。</li><li>CountDownLatch的基本操作组合是countDown/await。调用await的线程阻塞等待countDown足够的次数，不管你是在一个线程还是多个线程里countDown，只要次数足够即可。所以说CountDownLatch操作的是事件。</li><li>CyclicBarrier的基本操作组合，则就是await。当所有的伙伴（parties）都调用了await，才会继续进行任务，并自动进行重置。注意，正常情况下，CyclicBarrier的重置都是自动发生的，如果我们调用reset方法，但还有线程在等待，就会导致等待线程被打扰，抛出BrokenBarrierException异常。CyclicBarrier侧重点是线程，而不是调用事件，它的典型应用场景是用来等待并发线程结束。</li></ul><p>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><p>CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p><h4 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h4><p>在启动一个并行化项目前，开发人员会希望预估他们能够实现的性能提升量（加速比）。 如果知道（或预估出)能够以并行方式执行的串行代码的百分数，那么开发人员可使用阿姆达尔定律计算应用的加速比上限，无需实际编写任何并发代码。<br>pctpar：并行执行时间<br>p：内核数<br>$$<br>speedup &lt;= \frac{1} {(1-pctpar)+\frac{pctpar}{p}}<br>$$<br>这里忽略了实际开销，例如通信、同步和其它线程管理，以及无限内核处理器的假设，阿姆达尔定律一直饱受批评。 除了没有考虑并发算法固有的开销，对阿姆达尔定律最强烈的批评之一是，随着内核数量的增加，处理的数据量也可能会增加。 阿姆达尔定律假设不论内核数量如何，数据集大小均为固定，并且整体串行执行时间保持不变。</p><h4 id="古斯塔夫森定律"><a href="#古斯塔夫森定律" class="headerlink" title="古斯塔夫森定律"></a>古斯塔夫森定律</h4><p>如果使用 8 核的并行应用能够计算的数据集是原始大小的 8 倍，串行部分的执行时间会增加吗？ 即使有增加，它也并非与数据集的增加同比例增长。 实际数据显示串行执行时间几乎保持不变。斯塔夫森定律又被称为扩展的加速比(scaled speedup)，它考虑了数据大小与内核数量成比例的增加并计算应用的加速比（上限），假设大数据集能够以并行方式执行。 扩展的加速比公式如下：<br>p代表内核数量。 为简化表述，对于指定的数据集大小， s 代表并行应用中的串行执行时间的百分数。<br>$$<br>speedup &lt;= p + (1-p)s<br>$$</p><h4 id="毒丸"><a href="#毒丸" class="headerlink" title="毒丸"></a>毒丸</h4><p>对不起，毒丸基本上找不到资料。找到的是另一个资料…emmm我觉得并发队列里常用的手法吧，很合理，可能也不需要这名字</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起初还在想这么薄的书怎么能学七周呢，原来大部分内容都隐藏在作业里自学了。&lt;br&gt;第一周参上&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/categories/java/"/>
    
      <category term="book_notes" scheme="http://oodtoodt.github.io/categories/java/book-notes/"/>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/tags/java/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="concurrent" scheme="http://oodtoodt.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>名词解释-2</title>
    <link href="http://oodtoodt.github.io/2020/04/24/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-2/"/>
    <id>http://oodtoodt.github.io/2020/04/24/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-2/</id>
    <published>2020-04-24T11:27:32.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="curring"><a href="#curring" class="headerlink" title="curring"></a>curring</h3><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h2&gt;&lt;h3 id=&quot;curring&quot;&gt;&lt;a href=&quot;#curring&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java多线程</title>
    <link href="http://oodtoodt.github.io/2020/04/24/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://oodtoodt.github.io/2020/04/24/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-04-24T03:07:44.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vert.x-example-notes</title>
    <link href="http://oodtoodt.github.io/2020/04/17/java-%E6%8A%80%E6%9C%AF%E6%A0%88/vertx-notes/vertx-example-notes/"/>
    <id>http://oodtoodt.github.io/2020/04/17/java-%E6%8A%80%E6%9C%AF%E6%A0%88/vertx-notes/vertx-example-notes/</id>
    <published>2020-04-17T03:06:55.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在把文档全部复制粘贴了之后，我意识到这根本没啥用。或者说用途有限，留下一个初步印象。<br>来读example代码，写点东西记一记</p><p>ongoing</p><a id="more"></a><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><p>会经常性的抽风</p><h2 id="Net-Http"><a href="#Net-Http" class="headerlink" title="Net/Http"></a>Net/Http</h2><h3 id="net-和-http"><a href="#net-和-http" class="headerlink" title="net 和 http"></a>net 和 http</h3><p>NetServer、NetClient<br>HttpServer、HttpClient<br>服务器方面<br>net用到了Pump.pump(sock,sock).start()，http用的是req.response().putheader().end();<br>net是connectHandler ，http是requestHandler</p><p>客户端<br>net是connect，socket = res.result();,然后用socket操作,socket.handler<br>http直接是getNow,resp就可以操作了，.</p><p>当然，echo的功能是回声，而http-simple的功能就只是显示hello world<br>所以pump(rs,ws)，基本就是读取然后回复了</p><h3 id="ssl（https）"><a href="#ssl（https）" class="headerlink" title="ssl（https）"></a>ssl（https）</h3><p>两种ssl在根本上差不多，XXClientOptions().setSsl().setTrustAll()，当然这种不安全，应当配置turst store和包含该客户端信任的服务器证书</p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>这就真的…套了好多层了，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vertx.createHttpServer().requestHander(req-&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    HttpClientRequest c_req = client.request(req.method(),<span class="number">8282</span>,<span class="string">"localhost"</span>,req.uri(),c_res-&gt;&#123;</span><br><span class="line">        ...</span><br><span class="line">        c_res.handler(data-&gt;&#123;</span><br><span class="line">            ...</span><br><span class="line">            req.response().write(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        c_res.endHandler((v) -&gt; req.response().end());</span><br><span class="line">    &#125;);</span><br><span class="line">    c_req.setChunked();</span><br><span class="line">    c_req.headers().setAll(req.headers());</span><br><span class="line">    req.handler(data-&gt;&#123;</span><br><span class="line">        ...</span><br><span class="line">        c_req.write(data);</span><br><span class="line">    &#125;);</span><br><span class="line">    req.endHandler((v) -&gt; c_req.end());</span><br><span class="line">&#125;).lesten(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>还分了两种，一种是用了ProxyOptions,用套接字连接端点服务器然后传递其他事件的，一种看起来简单一些，就是个代理接受请求。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>老实说这个例子挺失败的…说是双工但是怎么看都接受不到东西，我也不知道是html写的有问题还是这里的vertx写的有问题，总之，我没成功。那也没啥好探究了的（</p><h3 id="本地文件"><a href="#本地文件" class="headerlink" title="本地文件"></a>本地文件</h3><ul><li>如何用本地html<br>这个简单</li></ul><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><ul><li>如何处理HTML form<br>虽然很简单，但是顺序很奇怪，像是被sort过，也有可能是异步的原因（但是每次都一样的，2143</li></ul><h3 id="SimpleFormUploadServer-java"><a href="#SimpleFormUploadServer-java" class="headerlink" title="SimpleFormUploadServer.java"></a>SimpleFormUploadServer.java</h3><ul><li>如何处理form upload<br>这不就是我们那个10.xx里面有个奇怪文件夹嘛，一模一样的</li></ul><h3 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h3><p>这个是告诉你怎么直接泵送的，上下各写了一个Pump。<br>但我还是不怎么明白：这东西有什么用？对大文件直接落到本地的.uploaded文件，然后呢？</p><h3 id="sharing"><a href="#sharing" class="headerlink" title="sharing"></a>sharing</h3><ul><li>如何sharing 让多台服务器在同一主机和端口上侦听。尝试部署一个以上的实例。<br>是关于怎么跑很多核的，无非就是set了一下Instances，然后这里是用轮询的方式分发给任意一个处理的（传入新连接的时候）</li></ul><h3 id="HTTP2-s1mple"><a href="#HTTP2-s1mple" class="headerlink" title="HTTP2 s1mple"></a>HTTP2 s1mple</h3><p>和ssl差不太多，但如果你记得h2和h2c的话，你就会知道这个.setUseAlpn的含义了。</p><blockquote><p>ALPN是一个TLS的扩展，它在客户端和服务器开始交换数据之前协商协议。不支持ALPN的客户端仍然可以执行经典的SSL握手。通常情况，ALPN会对 h2 协议达成一致，尽管服务器或客户端决定了仍然使用 HTTP/1.1 协议。<br>要处理 h2c 请求，TLS必须被禁用，服务器将升级到 HTTP/2 以满足任何希望升级到 HTTP/2 的 HTTP/1.1 请求。它还将接受以 <code>PRI*HTTP/2.0\r\nSM\r\n</code>开始的h2c直接连接。</p></blockquote><h3 id="HTTP2-push"><a href="#HTTP2-push" class="headerlink" title="HTTP2 push"></a>HTTP2 push</h3><p>服务器推送(Server Push)是 HTTP/2 支持的一个新功能，可以为单个客户端请求并行发送多个响应。<br>写到这我发现我真正应该该笔记的是啥<br>不过之前的价值也不太大吧。</p><ul><li>如何用本地jspush</li><li>如何用本地的index.html（首次是用sendfile那里，很简单，但是组合可能就成为障碍</li><li>稍加比对会发现有get和getnow两种，前者是<strong>创造</strong>一个HTTP GET,虽然大部分都被Deprecated(指在4中就会发生变化推荐使用WebClient)，返回一个Request，后者返回的是Client</li></ul><h3 id="h2c"><a href="#h2c" class="headerlink" title="h2c"></a>h2c</h3><p>用h2c而不是tls<br>但是很奇怪的在网上显示的version是http1.1，而用客户端收到的就是2.0.【行吧客户端自己设了一下才收的数据，还说是不适用于不支持h2c的浏览器..嗯行吧，而且这应该就是正统h2c的用法了。</p><h3 id="custom-frame"><a href="#custom-frame" class="headerlink" title="custom frame"></a>custom frame</h3><p>还以为frame是框架啥的。。发现就是帧，3个参数8bit的type，8bit的flags，后面就是payload</p><h2 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h2><h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><p>两边都注册个函数，收发就行了。</p><ul><li>这里是用的一致名称来搜索地址的</li></ul><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>区别太细微以至于我一开始没看到。。。</p><ul><li>发布是publish，意味着都能收到。</li><li>点对点是send，即便同地址有许多，也只会用不严格的轮询算法选择其中一个。</li></ul><h3 id="成了，Codecs"><a href="#成了，Codecs" class="headerlink" title="成了，Codecs"></a>成了，Codecs</h3><p>为了支持发送所有对象，你要为对象类型注册一个编解码器<br>问题是，API里找不到这个编解码器<br>当我想自行解决问题的时候，问题就变得无法解决了起来<br>成了，解决了。怪不得没有，原来注册编解码器的所有都是自己写的——这个CustomMessage根本就是在目录下的一个java文件而已<br>那这么说这个例子还挺有借鉴价值的</p><ul><li>编解码器要怎么写：实现哪些方法，哪些是固定格式，比如怎么出json</li><li>整个流程<br>以下是胡比比：<br>sender先计时器用eventbus每秒向cluster receiver发一个自定义消息，等待reply<br>还部署了一个local receiver用的verticle实例，每两秒向local receiver发送消息并等待回复。</li></ul><p>这里面的local receiver是自己写的，里面就是一个叫<code>local-message-receiver</code>的eventbus用来接收消息，可以认为是用verticle deploy了实例之后他就接进来了。<br>不不不。我觉得只是随便开了一个verticle，为了辨认起了local receiver的class的名字，目的就是异步，就是说我不在同一个eventloop里面搞多个事件。<br>我又变卦了。我现在觉得是前者。原因是创建verticle必然会把它分配给一个eventloop，并在里面执行它的start（极大可能是在当前eventloop里执行）<br>这里我理解就是，不需要你自己开这边这个了，另一个clusterreceiver还是需要自己开。local会自己开，甚至存在非常奇怪的继承</p><p>注意到在sender里面刚开始就注册了codec，后面就不用了。即便是在sender里面deploy的localreceiver内部的start，也不注册了。<br>这个继承关系让我摸不到头脑。<br>你要说这不是继承，那这是什么呢<br>某种神奇的注册机制，相当于把代码提上来？<br>反射？</p><p>经过半小时的纠缠，我现在看法又改变了。<br>我现在觉得是一个依赖线程或者说是eventloop的context在搞鬼。比如我们的context信息如果是相同的，草，我要做实验</p><p>实验做完了，debug一点一点看的。<br>首先，这个事就是个全局环境。两者的vertx是相同的——vertx是什么？vertx就是个全局的超级对象，是vert.x框架下的核心。而只要vertx相同，那么eventbus就相同。<br>而我是通过deploy的方式在当前的vertx里新建了verticle，所以我们的vertx是相同的，甚至上下文context也有非常多相同的：owner(就是vertx本尊了)，tccl（我们暂且认为是上下文装载器，某种filter），workerpoll和internal版本，orderedtasks和internal版本。<br>而如果！我新跑一个ClusterReceiver，那么这个vertx将和之前不同。这一不同几乎就是完！全！不！同！基本上找不到相同的数据了。</p><p>其他的没啥。基本上的逻辑就这样了。codec的内容我们以后再看…下一个下一个</p><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>嗯so easy，就跟net的时候。。。<br>等等？这也太干脆了，就直接在点对点的基础上在调用时候使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runner.runClusteredExample(Sender<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">new</span> <span class="title">VertxOptions</span>().<span class="title">setEventBusOptions</span>(<span class="title">new</span> <span class="title">EventBusOptions</span>()</span></span><br><span class="line"><span class="class">            .<span class="title">setSsl</span>(<span class="title">true</span>)</span></span><br><span class="line">            .setKeyStoreOptions(new JksOptions().setPath("keystore.jks").setPassword("wibble"))</span><br><span class="line">            .setTrustStoreOptions(<span class="keyword">new</span> JksOptions().setPath(<span class="string">"keystore.jks"</span>).setPassword(<span class="string">"wibble"</span>))</span><br><span class="line">        )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>下面的start一模一样！！作者应该也是就这么复制的hhh</p><ul><li>如何传递ssl的eventbus,这里建议去看runner源码，下面会有解析</li></ul><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>这东西是用来做异步结果协调的。主要的问题是，文档里没得解释…只能自己看了<br>教你写future/promise</p><blockquote><p>promise表示可能已经或可能尚未发生的动作的可写面(writable side)。可以用future（）方法返回与承诺相关联的Future，future可用于获取承诺完成的通知并检索其值。<br>future表示可能已经或可能尚未发生的操作的结果(result)。</p></blockquote><p>里面也写了mimic，即模拟一个消耗时间的操作和另一个消耗时间的操作异步顺序链接（依次执行异步调用）</p><ul><li>如何异步协调</li></ul><h2 id="verticle"><a href="#verticle" class="headerlink" title="verticle"></a>verticle</h2><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>这个结果太绝了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Main verticle has started, let&#39;s deploy some others...</span><br><span class="line">In OtherVerticle.start</span><br><span class="line">In OtherVerticle.start</span><br><span class="line">In OtherVerticle.start</span><br><span class="line">In OtherVerticle.start</span><br><span class="line">In OtherVerticle.start</span><br><span class="line">In OtherVerticle.start</span><br><span class="line">Config is &#123;&#125;</span><br><span class="line">Config is &#123;&#125;</span><br><span class="line">Config is &#123;&#125;</span><br><span class="line">Config is &#123;&#125;</span><br><span class="line">Config is &#123;&#125;</span><br><span class="line">Config is &#123;&quot;foo&quot;:&quot;bar&quot;&#125;</span><br><span class="line">Other verticle deployed ok, deploymentID &#x3D; 58929df6-6dd1-4972-82e2-9be041e6c313</span><br><span class="line">In OtherVerticle.stop</span><br><span class="line">Undeployed ok!</span><br></pre></td></tr></table></figure><p>嗯。那么首先start和config只是分了两个system.out.println而已，然后被deploy直接就分离了。<br>还有other…那个就是deploy的第二个参数而已，也接到非常神奇的后面了。<br>最后unploy倒是没什么问题，算是顺序的了。<br>值得一提的是带config的跑到最后了，估计就是谁跑得快谁开吧。<br>我们看下文档：（按顺序）</p><pre><code>+ Deploying without waiting for it to deploy+ Deploying and waiting for it to deploy(指要传参给res)+ Passing configuration to another verticle during deploy(最慢)+ Deploying more than one instance+ Deploying as a worker verticle+ Undeploying a verticle deployment explicitly</code></pre><ul><li>deploy的顺序</li><li>理解异步<h3 id="异步启动和终止"><a href="#异步启动和终止" class="headerlink" title="异步启动和终止"></a>异步启动和终止</h3>这里的参数就是<code>Future&lt;Void&gt; starFuture</code>了，见具体章节。<br>即需要时间来启动或者清理的时候，我们需要用这种启动来避免阻塞<br>不是问题</li><li>异步启动</li></ul><h3 id="worker-verticle实例"><a href="#worker-verticle实例" class="headerlink" title="worker verticle实例"></a>worker verticle实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx.eventBus().&lt;String&gt;consumer(...)</span><br></pre></td></tr></table></figure><p>太绝了，吓坏孩子了。<br>反正就是定义这个eventbus里面的<code>public &lt;T&gt;messageconsumer&lt;T&gt;</code>都是string了(T直接就是string了)<br>重点不在这！<br>重点在这里向我们展示了如何使用worker verticle，虽然只是配置了一下options，但是你会发现，虽然你开的worker是在0里开始的，但是！它consume eventbus的时候就是从worker-thread-1开始干的了<br>！！！<br>注意！你开的worker是从worker-0开始的，你的主verticle是从eventloop-thread-0开始的！！<br>我日，我改了半天想探究一下为啥俩0一个1，原来如此。<br>然后我还搞明白了一件事<br>这是异步！！！<br>我往<strong>deploy的res里面</strong>向外部的arraylist或者数组加东西，然后从<strong>外面</strong>undeploy这个获取到的id。我为啥反应这么慢呢，是因为我确实对java不熟，不能确认lambda里能否对外面的值进行改动（可以的）<br>想清楚了来龙去脉随便设计个timer就懂了。在外面println的时候<code>a[0]</code>依然是null或是原设值，在timer里等1ms(最低了，0都不让设的)就已经是改过的值了。(吹一波自己！periodic用timer解可还行，不过还是依赖了lambda传effective final的特性)<br>时刻记住这里到处都是异步。可能有些东西就想通了。<br>要是昨天先看这个例子我估计我就搞明白昨天那个sender里面开verticle是怎么回事了。</p><ul><li>理解异步</li><li>如何用worker-verticle写多线程</li></ul><h2 id="execblocking"><a href="#execblocking" class="headerlink" title="execblocking"></a>execblocking</h2><p>指以不阻塞事件循环的方式来包含阻塞与非阻塞代码。<br>对runner产生了一点小小的想法。一会解析一下runner<br>这里又出现了<code>vertx.&lt;String&gt;executeBlocking</code>，但是你会发现，如果删去对于promise(第一个函参)是没影响的，但是对第二个函参res就有影响了，<code>res.result</code>变成了object编译错误。回过头看刚才那个例子，明白是影响到了后面的函参提供的构造(body())。<br>好，不扯闲篇，</p><ul><li>如何用executeblocking API来执行阻塞代码并获得阻塞代码执行后的异步回调的结果</li></ul><p>这个结果看不太出什么，我们如果让他sleep5s，然后我们打开localhost8080的时候会被疯狂警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4月 21, 2020 2:16:29 下午 io.vertx.core.impl.BlockedThreadChecker</span><br><span class="line">警告: Thread Thread[dedicated-pool-0,5,main]&#x3D;Thread[dedicated-pool-0,5,main] has been blocked for 4887 ms, time limit is 0 ms</span><br></pre></td></tr></table></figure><p>每秒一次。代表警告这个线程被阻塞的时间太久。<br>其他没啥说的，executeBlocking两个函参，第一个是要阻塞的代码是什么，第二个是异步回调执行结果</p><h2 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h2><p>这里是展示高可用性的，当原始节点死亡时，会将顶点重新部署到另一个节点<br>不清楚ide里能不能模拟集群环境<br>初步失败了，感觉不知道怎么杀了这个进程，kill找不到progress，wsl又蠢得一比</p><h2 id="JavaScript-Verticle-and-NPM"><a href="#JavaScript-Verticle-and-NPM" class="headerlink" title="JavaScript Verticle and NPM"></a>JavaScript Verticle and NPM</h2><p>没啥关系不看了。</p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><ul><li>如何用流json来解析包含许多小对象的大数组。</li><li>mapTo的Json器怎么写<br>唔，依赖com.fasterxml.jackson这个东西。pom有点问题，一层层找上去发现是依赖崩了。亏我还去查了半天的文档。接受教训，先看依赖，再找文档</li></ul><p>是在用ReadStream的接口，用AsyncFile来读写实现这个接口的。<br>注意到Http|C/S|Request、MessageConsumer、Net/Web|Socket都实现了这个接口的<br>流(完全)到达时调用endHandler。<br>handler：设置一个处理器，它将从ReadStream读取项<br>没什么好看的了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在把文档全部复制粘贴了之后，我意识到这根本没啥用。或者说用途有限，留下一个初步印象。&lt;br&gt;来读example代码，写点东西记一记&lt;/p&gt;
&lt;p&gt;ongoing&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/categories/java/"/>
    
      <category term="frame" scheme="http://oodtoodt.github.io/categories/java/frame/"/>
    
      <category term="vert.x" scheme="http://oodtoodt.github.io/categories/java/frame/vert-x/"/>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/tags/java/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="example" scheme="http://oodtoodt.github.io/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>名词解释-1</title>
    <link href="http://oodtoodt.github.io/2020/04/16/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1/"/>
    <id>http://oodtoodt.github.io/2020/04/16/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1/</id>
    <published>2020-04-16T07:05:16.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是基础？这就是基础</p><a id="more"></a><h2 id="http、tcp"><a href="#http、tcp" class="headerlink" title="http、tcp"></a>http、tcp</h2><p>http连接=以http协议为通信协议的tcp连接</p><p>http短连接=以http协议为通信协议的，请求一次就断开的tcp连接</p><p>http长连接=以http协议为通信协议的，请求多次才断开的tcp连接（这个是为了通过减少建立tcp连接的次数达到节省两端资源的目的）</p><p>tcp/ip和http都是协议是约定好的规范，他们位于网络5层模型的传输层（tcp）和应用层（http），tcpip表示的是一系列协议。规定好的协议总要操作系统实现了才能使用，而socket就是操作系统实现的，tcp/ip协议族的接口，用于创建一个套接字。<br>可以理解为，通过网络读写的文件描述符，socket、bind、listen、accept、connect一系列都是操作系统提供的接口用于实现tcp协议相关的功能。<br>tcp协议可以让两个进程通过三次握手建立稳定的通信信道，发送字节流，<br>而http协议建立在tcp协议之上，也就是说tcp协议可以让两个程序说话，而http协议定义了说话的规则。</p><p>作者：渣硕<br>链接：<a href="https://www.zhihu.com/question/39541968/answer/87821283" target="_blank" rel="noopener">https://www.zhihu.com/question/39541968/answer/87821283</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>看了一圈，http确实就是tcp上层的东西，但是确实可以单独拿出tcp不用http来自己跑web</p><h2 id="同步、异步、并发、并行、阻塞、非阻塞"><a href="#同步、异步、并发、并行、阻塞、非阻塞" class="headerlink" title="同步、异步、并发、并行、阻塞、非阻塞"></a>同步、异步、并发、并行、阻塞、非阻塞</h2><blockquote><p>同步 不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，称这些程序单元是同步执行的。 例如购物系统中更新商品库存，需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的。 简言之，同步意味着有序。<br>异步 为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式。 不相关的程序单元之间可以是异步的。 例如，爬虫下载网页。调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无需相互通知协调。这些异步操作的完成时刻并不确定。 简言之，异步意味着无序。 上文提到的“通信方式”通常是指异步和并发编程提供的同步原语，如信号量、锁、同步队列等等。我们需知道，虽然这些通信方式是为了让多个程序在一定条件下同步执行，但正因为是异步的存在，才需要这些通信方式。如果所有程序都是按序执行，其本身就是同步的，又何需这些同步信号呢？<br>并发 并发描述的是程序的组织结构。指程序要被设计成多个可独立执行的子任务。 以利用有限的计算机资源使多个任务可以被实时或近实时执行为目的。<br>并行 并行描述的是程序的执行状态。指多个任务同时被执行。 以利用富余计算资源（多核CPU）加速完成多个任务为目的。 并发提供了一种程序组织结构方式，让问题的解决方案可以并行执行，但并行执行不是必须的</p></blockquote><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。<br>最关键的点就是：是否是『同时』。<br>这里不准确，我们后面会有章节专门讲</p><hr><p>其实售票大厅更在意的是旅客一个一个的到窗口去买票，因为一次只能卖一张票。</p><p>即使大家一窝蜂的都围上去，还是一次只能卖一张票，何必呢？挤在一起又不安全。</p><p>只是有些人素质太差，非要往上挤，售票大厅迫不得已，采用排队这种形式来达到自己的目的，即一个一个的买票。</p><p>至于每个旅客排队时的状态，是看手机呀还是说话呀，根本不用去在意。</p><p>除了这种由于资源导致的同步外，还存在一种由于逻辑上的先后顺序导致的同步。</p><p>比如，先更新代码，然后再编译，接着再打包。这些操作由于后一步要使用上一步的结果，所以只能按照这种顺序一个一个的执行。</p><p>关于同步还需知道两个小的点：</p><p>一是范围，并不需要在全局范围内都去同步，只需要在某些关键的点执行同步即可。</p><p>比如食堂只有一个卖饭窗口，肯定是同步的，一个人买完，下一个人再买。但吃饭的时候也是一个人吃完，下一个人才开始吃吗？当然不是啦。</p><p>二是粒度，并不是只有大粒度的事物才有同步，小粒度的事物也有同步。</p><p>只不过小粒度的事物同步通常是天然支持的，而大粒度的事物同步往往需要手工处理。</p><p>比如两个线程的同步就需要手工处理，但一个线程里的两个语句天然就是同步的。</p><p>所谓异步，就是步调各异。既然是各异，那就是都不相同。所以结果就是：</p><p>多个事物可以你进行你的、我进行我的，谁都不用管谁，所有的事物都在同时进行中。</p><p>一言以蔽之，同步就是多个事物不能同时开工，异步就是多个事物可以同时开工。</p><p>注：一定要去体会“多个事物”，多个线程是多个事物，多个方法是多个事物，多个语句是多个事物，多个CPU指令是多个事物。等等等等。</p><p>阻塞和非阻塞<br>汽车可以正常通行时，就是非阻塞。一旦堵上了，全部趴窝，一动不动，就是阻塞。</p><p>因此阻塞关注的是不能动，非阻塞关注的是可以动。</p><p>两两组合<br>所谓同步/异步，关注的是能不能同时开工。</p><p>所谓阻塞/非阻塞，关注的是能不能动。</p><p>通过推理进行组合：</p><p>同步阻塞，不能同时开工，也不能动。只有一条小道，一次只能过一辆车，可悲的是还TMD的堵上了。</p><p>同步非阻塞，不能同时开工，但可以动。只有一条小道，一次只能过一辆车，幸运的是可以正常通行。</p><p>异步阻塞，可以同时开工，但不可以动。有多条路，每条路都可以跑车，可气的是全都TMD的堵上了。</p><p>异步非阻塞，可以工时开工，也可以动。有多条路，每条路都可以跑车，很爽的是全都可以正常通行。</p><p>是不是很容易理解啊。其实它们的关注点是不同的，只要搞明白了这点，组合起来也不是事儿。</p><p>回到程序里，把它们和线程关联起来：</p><p>同步阻塞，相当于一个线程在等待。</p><p>同步非阻塞，相当于一个线程在正常运行。</p><p>异步阻塞，相当于多个线程都在等待。</p><p>异步非阻塞，相当于多个线程都在正常运行。</p><h2 id="并行、并发、线程、进程"><a href="#并行、并发、线程、进程" class="headerlink" title="并行、并发、线程、进程"></a>并行、并发、线程、进程</h2><p>后两者在linux中区别不大，甚至本质相同：线程就是轻量级进程；只是线程资源消耗少，线程共享虚拟内存这两点显著区别。两者都用作任务调度单位。<br>进程还有一个概念，就是操作系统中运行起来的实例，可以被实现为存放调度给cpu的任务和状态数据的数据结构（os 进程）<br>我们这里的进程的含义是：有了一个可行思路。指如何想明白做一件事情的过程，它用来帮助你理清做事的思路，做与没做对于进程这个概念不重要。（Process进程）</p><p>并发(Concurrency)是由p进程引申出来的抽象概念。换句人话就是：你有一套方案，可以让多个人一起把事情做的更高效。注意是<strong>可以</strong>，不是必然。<br>这时候就出现了这样的问题：你把并发的p进程写成程序的时候，你怎么用编程语言告诉操作系统你的程序的步骤是「并发的」，即你需要一个写法来表达「几个任务是并发的/并发的任务之间时怎么交互协作的」<br>于是有了并发模型：</p><ul><li>Fork &amp; Join模型（大任务拆解为小任务并发的跑，结果拼起来）</li><li>Actor模型（干活的步骤之间直接发消息）</li><li>CSP模型（干活的步骤之间订阅通话的频道来协作）</li><li>线程&amp;锁模型（干活的人共享一个小本本，用来协作。注意小本本不能改乱套了，所以得加锁）</li><li>。。。</li></ul><p>现在我们已经有了一个并发的想法，然后进入执行层面：你假设有20人可以一起干活。但你可能只雇到1个人，这人就得干所有的活。<br>你真的雇了10个人，10个人同时在工地上干活，就是「并行」。<br>程序是否能并行，要看物理上有多少个cpu或物理主机。<br>比如你写了个java程序，启动了4个进程，但cpu只有单核，那么只有1个线程在运行。如果有4个，那么就完全「并行」运行。</p><p>并发这个词，本意指两件事没有谁先谁后的关系，或关系不确定。<br>对于任务执行这个领域，对任务A和B，如果我说他们俩是「并发」的，这就要求不能在任何B里用A的结果，也不能在A里用B的结果。但这之外，在执行层面，A可以在B之前，也可以在B里执行，也可以交替执行，或者「并行」的执行，都是「并发」。<br>如果A需要B的结果，需要加锁、channel来表达先B后A，那就不是「并发」的。<br>这里只将cpu核心当做做事的人，再广义一点，比如显卡、网卡、磁盘都可以是独立干活的人。在设计程序的时候，可以把计算和IO拆开设计一个「并发」的方法，利用CPU和网卡是两个零件来「并行」的跑<br>Rob Pike提到了两个观点：</p><blockquote><p>【并发】说的是处理（Deal）的方法；【并行】说的是执行（Execution）的方法。<br>如果想让一个事情变得容易【并行】，先得让制定一个【并发】的方法。</p></blockquote><p><strong>为什么要这么理解并发？</strong><br>将并发理解为一种解决问题的方法，其主要用意是表达：一个问题的解决方案是可以由许许多多的并发任务组装（compose）到一起的。这有点像OOP里表达一个类可以由其他类的成员组装到一起一样。</p><p><em>将大的任务拆解为许许多多小的可以并发的任务是重要的编程思想。</em></p><p>比如当你在编写一个GET /user/:userId接口时，实际上底层要去3个地方取用户的基本信息（头像、昵称），活动的积分，当前已经下的订单，再组装到一起返回</p><p>如果把一个并发任务以函数的方式去写就刚好把函数式编程（FP）与并发编程结合起来，就容易得到写起来很舒服，并且有利于并行执行的代码。这也是为什么很多FP语言都天然很适合做并发程序设计的原因。</p><h2 id="WebSocket-阮大"><a href="#WebSocket-阮大" class="headerlink" title="WebSocket(阮大)"></a>WebSocket(阮大)</h2><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><p>WebSockets是一项网络技术，它允许HTTP服务器和HTTP客户端（通常是浏览器）之间的全双工套接字式连接。</p><h2 id="HTTP（阮大）"><a href="#HTTP（阮大）" class="headerlink" title="HTTP（阮大）"></a>HTTP（阮大）</h2><p>主要是看到HTTP2.0，感觉需要过来解释一些</p><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><h4 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h4><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.0</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10</span>_10_5)</span><br><span class="line">Accept: *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>第一行请求，必须在尾部添加协议版本，后面多行头信息，描述客户端情况</p><h4 id="回应格式"><a href="#回应格式" class="headerlink" title="回应格式"></a>回应格式</h4><p>回应的格式是”头信息 + 一个空行（\r\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常见的Content-Type字段的值总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。<br>比如<code>test/html; charset=utf-8</code> （加了参数</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。<br>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。<br>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。<br>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。<br>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。<br>因此，1.1版规定可以不使用Content-Length字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。<br>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p><p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure><p>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>注意他不叫HTTP/2.0，因为下个版本就是HTTP/3</p><h4 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h4><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h4 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h4><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h4 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h4><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><h2 id="SSL-TLS-阮大"><a href="#SSL-TLS-阮大" class="headerlink" title="SSL/TLS(阮大)"></a>SSL/TLS(阮大)</h2><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><p>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。<br>（2） 篡改风险（tampering）：第三方可以修改通信内容。<br>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</p><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><blockquote><p>但是，这里有两个问题。<br>（1）如何保证公钥不被篡改？<br>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。<br>（2）公钥加密计算量太大，如何减少耗用的时间？<br>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p></blockquote><p>因此，SSL/TLS协议的基本过程是这样的：</p><p>（1） 客户端向服务器端索要并验证公钥。<br>（2） 双方协商生成”对话密钥”。<br>（3） 双方采用”对话密钥”进行加密通信。</p><p>上面过程的前两步，又称为”握手阶段”（handshake）。</p><p>具体过程请看：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p><h2 id="h2c"><a href="#h2c" class="headerlink" title="h2c"></a>h2c</h2><p>字符串“h2”标识HTTP/2使用传输层安全性（TLS）<code>[TLS12]</code>的协议。 此标识符用于TLS应用层协议协商（ALPN）扩展<code>[TLS-ALPN]</code>字段以及识别TLS上的HTTP/2的任何地方。 “h2”字符串被串行化为一个ALPN协议标识符，作为两个八位字节序列：0x68,0x32。</p><p>字符串“h2c”标识在明文TCP上运行HTTP/2的协议。 该标识符用于HTTP/1.1升级头字段和任何标识HTTP/2 TCP的地方。 “h2c”字符串是从ALPN标识符空间中保留的，但描述了不使用TLS的协议。 谈判“h2”或“h2c”意味着使用本文档中描述的传输，安全，成帧和消息语义。<br>————————————————<br>版权声明：本文为CSDN博主「The_Hungry_Brain」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u010129119/article/details/79361949" target="_blank" rel="noopener">https://blog.csdn.net/u010129119/article/details/79361949</a></p><h2 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h2><p>Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。<br>想要清晰透彻的了解协议，最好通读一遍协议本身。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>作者：洪春涛<br>链接：<a href="https://www.zhihu.com/question/25536695/answer/221638079" target="_blank" rel="noopener">https://www.zhihu.com/question/25536695/answer/221638079</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>远程过程调用带来的新问题在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：</p><ol><li>Call ID映射<br>我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li><li>序列化和反序列化<br>客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li><li>网络传输<br>远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。有了这三个机制，就能实现RPC了，具体过程如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = l * r;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lvalue = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> rvalue = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> l_times_r = Multiply(lvalue, rvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client端 </span></span><br><span class="line"><span class="comment">//    int l_times_r = Call(ServerAddr, Multiply, lvalue, rvalue)</span></span><br><span class="line"><span class="number">1.</span> 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法</span><br><span class="line"><span class="number">2.</span> 将Call ID，lvalue和rvalue序列化。可以直接将它们的值以二进制形式打包</span><br><span class="line"><span class="number">3.</span> 把<span class="number">2</span>中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class="line"><span class="number">4.</span> 等待服务器返回结果</span><br><span class="line"><span class="number">5.</span> 如果服务器调用成功，那么就将结果反序列化，并赋给l_times_r</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server端</span></span><br><span class="line"><span class="number">1.</span> 在本地维护一个Call ID到函数指针的映射call_id_map，可以用<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::function&lt;&gt;&gt;</span><br><span class="line"><span class="number">2.</span> 等待请求</span><br><span class="line"><span class="number">3.</span> 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class="line"><span class="number">4.</span> 通过在call_id_map中查找，得到相应的函数指针</span><br><span class="line"><span class="number">5.</span> 将lvalue和rvalue反序列化后，在本地调用Multiply函数，得到结果</span><br><span class="line"><span class="number">6.</span> 将结果序列化后通过网络返回给<span class="built_in">Client</span></span><br></pre></td></tr></table></figure>所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。其中：</li></ol><ul><li>Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。</li><li>序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。</li><li>网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。<br>当然，这里面还有一些细节可以填充，比如如何处理网络错误，如何防止攻击，如何做流量控制，等等。但有了以上的架构，这些都可以持续加进去。</li></ul><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>A high-performance, open-source universal RPC framework</p><h2 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h2><p>以往的HTTP，我们习惯了和head /body 打交道。而在HTTP2，取而代之的是幀（Frame）。它将会成为协议中的最小通讯单位——所有的数据，head，body都会打包到Frame内发送。Frame 有很多类型，比如 header frame, data frame （以后…，不本文就会继续讲到）。</p><h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p>不论多少次行为，总与上一次结果或影响相同</p><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><blockquote><p>Representational State Transfer (REST) is a software architecture style consisting of guidelines and best practices for creating scalable web services. REST is a coordinated set of constraints applied to the design of components in a distributed hypermedia system that can lead to a more performant and maintainable architecture.<br>REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移<br>指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值)<br>要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。<br>RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。</p></blockquote><p>客户端通过HTTP方法可以获取资源，是吧? 不，确切的说，客户端获取的只是资源的表述而已。 资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。</p><p>资源的表述包括数据和描述数据的元数据，例如，HTTP头”Content-Type” 就是这样一个元数据属性。</p><p>那么客户端如何知道服务端提供哪种表述形式呢?</p><p>答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。</p><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p><p>综合上面的解释，我们总结一下什么是RESTful架构：</p><p>　　（1）每一个URI代表一种资源；</p><p>　　（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><blockquote><p>根据理查德森模型 (<a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="noopener">http://martinfowler.com/articles/richardsonMaturityModel.html</a>), REST架构的成熟度有3个等级:<br>Level 0 POX (这个就不算REST了)<br>Level 1 Resources<br>Level 2 Http verbs<br>Level 3 Hypermedia Controls</p></blockquote><blockquote><p>上述表述的模型在level 2上, 这也是目前大多数RESTful的应用所在的成熟度.</p></blockquote><blockquote><p>Level 0 POX<br>这类应用只有一个URI上的上帝接口, 根据交换的XML内容操作所有的资源. 往往导致上帝接口越来越复杂, 越来越难以维护.</p></blockquote><blockquote><p>Level 1 Resources<br>这一级别主要解决了上帝接口的问题, 使得各种资源有了自己相应的URI, 虽然仍然是POX的交互方式, 但是每一个接口都更加紧凑和内聚, 相应的容易维护起来.<br>这里的主要问题是URI templating和URI tunneling.<br>URI templating带来的结果是服务器端和客户端的紧耦合, 任何时候服务器段想改变自身的URL schema的时候, 都要break已经存在的客户端应用.<br>URI tunneling带来的问题包含URI templating, 而且放弃了使用http协议标准带来的任何好处, level 2中详述.<br>早期的rails routes就是url templating/tunneling. Rails3中已经更加靠近level 2了.</p></blockquote><blockquote><p>Level 2 Http verbs<br>这一级别使用http verbs来对各种资源进行crud操作, 使得应用程序的接口更加的统一, 语义更加明确. 同时, 因为遵照http的标准进行交互, 很多http提供的好处几乎可以免费的得到.</p><ol><li>Cache<br>按照HTTP协议, GET操作是安全的, 幂等(Idempotent)的. 任意多次对同一资源的GET操作, 都不会导致资源的状态变化. 所以GET的结果是可以安全的cache. 所有http提供的cache facilities 都可以被利用起来, 大幅度提高应用程序的性能. 甚至你仅仅只在response里加上cache directives就可以免费获得网络上各级的缓存服务器, 代理服务器, 以及用户客户端的缓存支持. 互联网上几乎所有的应用你都可以粗略统计得到Get VS Non-Get的请求比例约为 4:1. 如果你能为GET操作加上缓存, 那将极大提供你的程序的性能.</li><li>Robust<br>在HTTP常用的几个动词里, HEAD, GET, PUT, DELETE 是安全的,幂等的. 因为对同一资源的任意多次请求, 永远代表同一个语义. 所以任何时候客户端发出去这些动词的时候, 如果服务器没有响应, 或者返回错误代码, 客户端都可以非常安全的再次执行同一操作而不用担心重复操作带来不同的语义及最终结果. POST, PATCH操作就不是安全的, 因为当客户端向服务器端发出请求后, 服务器没有响应或者返回错误代码, 客户端是不能安全的重复操作的. 一定只能重新与服务器确认现在的资源状态才能决定下一步的操作.<br>绝大部分的RESTful应用就停在这里了, 当然也满足绝大多的需求.</li></ol></blockquote><blockquote><p>Level 3<br>RESTful的架构本意是”在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”<br>这个世界上规模最大的, 耦合度最低, 最稳定的, 性能最好的分布式网络应用是什么? 就是WEB本身.<br>规模,稳定,性能都不用说了. 为什么说耦合度低呢? 想一想每个人上网的经历, 你几乎不需要任何培训就可以上一个新的网络购物平台挑选商品,用信用卡付款,邮寄到自己家里.<br>把网站的程序想像成一个状态机, 用户在一系列状态转换中完成自己的目标. 这中间的每一步, 应用程序都告诉你当前的状态和可能的下一步操作, 最终引导用户从挑选商品,挑选更多商品,到支付页面,到输入信用卡信息,最终完成付费,到达状态机的终点.<br>这种service discoverablility和self-documenting就是level 3想解决的问题<br>在这里面, 告诉用户当前状态以及各种下一步操作的东西, 比如链接, 按钮等等, 就是Hypermedia Controls. Hypermedia Controls 就是这个状态机的引擎.<br>Level 3的REST架构就是希望能够统一这一类的Hypermedia Controls, 赋予他们标准的, 高度可扩展的标准语义及表现形式, 使得甚至无人工干预的机器与机器间的通用交互协议边的可能. 比如你可以告诉一个通用的购物客户端, “给我买个最便宜的xbox”, 客户端自动连上google进行搜索, 自动在前10个购物网站进行搜索, 进行价格排序, 然后自动挑选最便宜的网站, 进行一系列操作最终完成用信用卡付费, 填写个人收件地址然后邮寄.<br>这些都依赖于Hypermedia Controls带来的这种service discoverablility和self-documenting<br>更多的关于REST的细节及其应用和实现, 请参考Rest in Practice. 非常非常棒的一本书, 把REST讲的非常透彻.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是基础？这就是基础&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java-AQS</title>
    <link href="http://oodtoodt.github.io/2020/04/16/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS/"/>
    <id>http://oodtoodt.github.io/2020/04/16/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS/</id>
    <published>2020-04-16T05:36:01.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>ongoing。</p><a id="more"></a><hr><p>condition是要和lock配合使用的（它们是绑定的），lock的实现原理依赖于AQS，而ConditionObject则是AQS的内部类。</p><h5 id="AQS-https-segmentfault-com-a-1190000017372067"><a href="#AQS-https-segmentfault-com-a-1190000017372067" class="headerlink" title="AQS(https://segmentfault.com/a/1190000017372067)"></a>AQS(<a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017372067</a>)</h5><p>了解J.U.C的关键就是AQS.J.U.C，是JDK中提供的并发工具包, java.util.concurrent<br>AbstractQueuedSynchronizer.它提供了一个FIFO队列，是一个抽象类，定义了同步状态的获取和释放方法。<br>AQS的功能分为独占和共享两种<br>AQS的实现依赖内部的同步队列，即FIFO的双向队列（链表）。如果当前线程竞争锁失败，那么AQS会把当前线程和等待状态信息构造成一个Node加到同步队列中，同时再阻塞该进程。</p><h6 id="关于这个同步队列："><a href="#关于这个同步队列：" class="headerlink" title="关于这个同步队列："></a>关于这个同步队列：</h6><p>出现锁竞争和释放锁时，AQS同步队列中的节点会发生变化，添加时：</p><ul><li>新线程封装成node追加到同步队列中，设置prev，修改当前的前置的next指自己</li><li>通过CAS（compare and swap)将tail指向新的尾部节点</li></ul><blockquote><p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。考虑ABA问题是否会有影响,下面有源码分析</p></blockquote><p>释放锁移除时：</p><ul><li>修改head指向下一个获得锁的节点</li><li>新的获得锁的节点，将prev指向null</li></ul><h6 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h6><p>shit的多级列表在有代码的情况下非常难用，就不弄了</p><ol><li><p>ReentrantLock.lock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是获取锁的入口，调用sync这个类里面的方法，sync是什么呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br></pre></td></tr></table></figure><p>通过进一步分析，发现Sync这个类有两个具体的实现，分别是 NofairSync(非公平锁), FailSync(公平锁).</p><p> 公平锁 表示所有线程严格按照FIFO来获取锁<br> 非公平锁 表示可以存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁</p></li></ol><p>以下以非公平锁作为主要分析逻辑<br>2. NonfairSync.lock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))<span class="comment">//通过cas操作来修改state状态，表示抢争锁的操作</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置当前获得锁状态的进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);<span class="comment">//尝试去获取锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这里是非公平锁，所以调用lock方法时，先去通过cas去抢占锁<br>如果抢占锁成功，保存获得锁成功的当前线程<br>抢占锁失败，调用acquire来走锁竞争逻辑</p><ol start="3"><li>compareAndSetState()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect,<span class="keyword">int</span> update)</span></span>&#123;</span><br><span class="line">    <span class="comment">//see below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>,stateOffset,expect,update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前内存中的state的值和预期值expect相等，则替换为update。更新成功返回true，否则返回false. 这个操作是原子的，不会出现线程安全问题，这里面涉及到Unsafe这个类的操作，以及涉及到state这个属性的意义。AQS中有一个这样的state的属性定义,这个对于重入锁的实现来说，表示一个同步状态(计数)。它有两个含义的表示</p><pre><code>当state=0时，表示无锁状态当state&gt;0时，表示已经有线程获得了锁，也就是state=1，但是因为ReentrantLock允许重入，所以同一个线程多次获得同步锁的时候，state会递增，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>需要注意的是：不同的AQS实现，state所表达的含义是不一样的。Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Hadoop、Kafka等；Unsafe可认为是Java中留下的后门，提供了一些低层次操作，如直接内存访问、线程调度等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1,<span class="keyword">long</span> var2,<span class="keyword">int</span> var4,<span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>这个是一个native方法， 第一个参数为需要改变的对象，第二个为偏移量(即之前求出来的headOffset的值)，第三个参数为期待的值，第四个为更新后的值<br>整个方法的作用是如果当前时刻的值等于预期值var4相等，则更新为新的期望值 var5，如果更新成功，则返回true，否则返回false；<br>4. acquire<br>acquire是AQS中的方法，如果CAS操作未能成功，说明state已经不为0，此时继续acquire(1)操作,这里大家思考一下，acquire方法中的1的参数是用来做什么呢？如果没猜中，往前面回顾一下state这个概念<br>我猜就是给锁++<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg)&amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法的主要逻辑是<br>    通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false<br>    如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部<br>    acquireQueued，将Node作为参数，通过自旋去尝试获取锁。</p><ol start="5"><li>NonfairSync.tryAcquire<br>这个方法的作用是尝试获取锁，如果成功返回true，不成功返回false<br>它是重写AQS类中的tryAcquire方法，并且大家仔细看一下AQS中tryAcquire方法的定义，并没有实现，而是抛出异常。按照一般的思维模式，既然是一个不实现的模版方法，那应该定义成abstract，让子类来实现呀？大家想想为什么<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>nonfairTryAcquire<br>tryAcquire(1)在NonfairSync中的实现代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得当前执行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">//获得state的值</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//state=0说明当前是无锁状态</span></span><br><span class="line">        <span class="comment">//通过cas操作来替换state的值改为1，大家想想为什么要用cas呢？</span></span><br><span class="line">        <span class="comment">//理由是，在多线程环境中，直接修改state=1会存在线程安全问题，你猜到了吗？</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             <span class="comment">//保存当前获得锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这段逻辑就很简单了。如果是同一个线程来获得锁，则直接增加重入次数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">//增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>获取当前线程，判断当前的锁的状态<br>如果state=0表示当前是无锁状态，通过cas更新state状态的值<br>如果当前线程是属于重入，则增加重入次数</li><li>addWaiter<br>当tryAcquire方法获取锁失败以后，则会先调用addWaiter将当前线程封装成Node，然后添加到AQS队列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">//mode=Node.EXCLUSIVE</span></span><br><span class="line">        <span class="comment">//将当前线程封装成Node，并且mode为独占锁</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); </span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// tail是AQS的中表示同步队列队尾的属性，刚开始为null，所以进行enq(node)方法</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//tail不为空的情况，说明队列中存在节点数据</span></span><br><span class="line">            node.prev = pred;  <span class="comment">//讲当前线程的Node的prev节点指向tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//通过cas讲node添加到AQS队列</span></span><br><span class="line">                pred.next = node;<span class="comment">//cas成功，把旧的tail的next指针指向新的tail</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node); <span class="comment">//tail=null，将node添加到同步队列中</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>将当前线程封装成Node<br>判断当前链表中的tail节点是否为空，如果不为空，则通过cas操作把当前线程的node添加到AQS队列<br>如果为空或者cas失败，调用enq将节点添加到AQS队列</li><li>enq<br>enq就是通过自旋操作把当前节点加入到队列中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋，不做过多解释，不清楚的关注公众号[架构师修炼宝典]</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail; <span class="comment">//如果是第一次添加到队列，那么tail=null</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//CAS的方式创建一个空的Node作为头结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   <span class="comment">//此时队列中只一个头结点，所以tail也指向它</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//进行第二次循环时，tail不为null，进入else区域。将当前线程的Node结点的prev指向tail，然后使用CAS将tail指向Node</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line"><span class="comment">//t此时指向tail,所以可以CAS成功，将tail重新指向Node。此时t为更新前的tail的值，即指向空的头结点，t.next=node，就将头结点的后续结点指向Node，返回头结点</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>假如有两个线程t1,t2同时进入enq方法，t==null表示队列是首次使用，需要先初始化<br>另外一个线程cas失败，则进入下次循环，通过cas操作将node添加到队尾</li></ol><p>到目前为止，通过addwaiter方法构造了一个AQS队列，并且将线程添加到了队列的节点中<br>10. acquireQueued<br>将添加到队列中的Node作为参数传入acquireQueued方法，这里面会做抢占锁的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">// 获取prev节点,若为null即刻抛出NullPointException</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 如果前驱为head才有资格进行锁的抢夺</span></span><br><span class="line">                setHead(node); <span class="comment">// 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点</span></span><br><span class="line"><span class="comment">//凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">//获取锁成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">// 若前面为true,则执行挂起,待下次唤醒的时候检测中断的标志</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果抛出异常则取消锁的获取,进行出队(sync queue)操作</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前节点的prev节点<br>如果prev节点为head节点，那么它就有资格去争抢锁，调用tryAcquire抢占锁<br>抢占锁成功以后，把获得锁的节点设置为head，并且移除原来的初始化head节点<br>如果获得锁失败，则根据waitStatus决定是否需要挂起线程<br>最后，通过cancelAcquire取消获得锁的操作<br>前面的逻辑都很好理解，主要看一下shouldParkAfterFailedAcquire这个方法和parkAndCheckInterrupt的作用</p><p>后面不想写了，滚去看原链好了。（其实复制粘贴都要结束了）</p><hr><p>condition内部维护了一个「等待队列」（单向），所有await方法的线程会加入其中，如果该线程能够从await方法返回的话一定是该线程获取了与condition相关联的lock<br>当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalAll后会使得当前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理</p><p>很显然，当线程第一次调用condition.await()方法时，会进入到这个while()循环中，然后通过LockSupport.park(this)方法使得当前线程进入等待状态，那么要想退出这个await方法第一个前提条件自然而然的是要先退出这个while循环，出口就只剩下两个地方：1. 逻辑走到break退出while循环；2. while循环中的逻辑判断为false。</p><p>再看代码出现第1种情况的条件是当前等待的线程被中断后代码会走到break退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的condition的signal或者signalAll方法），while中逻辑判断为false后结束while循环。总结下，就是当前线程被中断或者调用condition.signal/condition.signalAll方法当前节点移动到了同步队列后 ，这是当前线程退出await方法的前提条件。</p><p>当退出while循环后就会调用acquireQueued(node, savedState)，这个方法在介绍AQS的底层实现时说过了，若感兴趣的话可以去，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到lock）。这样也说明了退出await方法必须是已经获得了condition引用（关联）的lock。到目前为止，开头的三个问题我们通过阅读源码的方式已经完全找到了答案，也对await方法的理解加深。</p><p>线程awaitThread先通过lock.lock()方法获取锁成功后调用了condition.await方法进入等待队列，而另一个线程signalThread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalAll方法，使得线程awaitThread能够有机会移入到同步队列中，当其他线程释放lock后使得线程awaitThread能够有机会获取lock，从而使得线程awaitThread能够从await方法中退出执行后续操作。如果awaitThread获取lock失败会直接进入到同步队列。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ongoing。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/categories/java/"/>
    
      <category term="APIs" scheme="http://oodtoodt.github.io/categories/java/APIs/"/>
    
      <category term="J.U.C" scheme="http://oodtoodt.github.io/categories/java/APIs/J-U-C/"/>
    
      <category term="source code" scheme="http://oodtoodt.github.io/categories/java/APIs/J-U-C/source-code/"/>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/tags/java/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
  </entry>
  
  <entry>
    <title>vert.x-notes</title>
    <link href="http://oodtoodt.github.io/2020/04/15/java-%E6%8A%80%E6%9C%AF%E6%A0%88/vertx-notes/vertx-notes/"/>
    <id>http://oodtoodt.github.io/2020/04/15/java-%E6%8A%80%E6%9C%AF%E6%A0%88/vertx-notes/vertx-notes/</id>
    <published>2020-04-15T02:29:43.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>我…我把整篇文章搬过来了！<br>复制粘贴…<br><a href="https://vertxchina.github.io/vertx-translation-chinese/core/Core.html" target="_blank" rel="noopener">https://vertxchina.github.io/vertx-translation-chinese/core/Core.html</a><br><a href="https://vertx.io/docs/vertx-core/java/#_buffers" target="_blank" rel="noopener">https://vertx.io/docs/vertx-core/java/#_buffers</a></p><a id="more"></a><h2 id="Are-you-fluent"><a href="#Are-you-fluent" class="headerlink" title="Are you fluent"></a>Are you fluent</h2><p>A fluent API是可以连锁调用许多方法的,比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request.response().puHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/plain"</span>).write(<span class="string">"some text"</span>).end();</span><br><span class="line"><span class="comment">//but we dont force you, you still can ignore it</span></span><br><span class="line">HttpServerResponse response = request.response();</span><br><span class="line">response.putHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/plain"</span>);</span><br><span class="line">response.write(<span class="string">"some text"</span>);</span><br><span class="line">response.end();</span><br></pre></td></tr></table></figure><h2 id="Don’t-call-us-we’ll-call-you"><a href="#Don’t-call-us-we’ll-call-you" class="headerlink" title="Don’t call us, we’ll call you"></a>Don’t call us, we’ll call you</h2><p>Vert.x APIs主要是事件驱动的。意味着如果Vert.x中发生的事情你感兴趣，Vert.x会通过事件的方法调用你</p><blockquote><p>Handler主要用于异步消息的处理（是一套Android提供的消息处理机制）：当发出一个消息之后，首先进入一个消息队列，发送消息的函数即刻返回，而另外一个部分在消息队列中逐一将消息取出，然后对消息进行处理，也就是发送消息和接收消息不是同步的处理。 这种机制通常用来处理相对耗时比较长的操作。<br>（无视就好，和这个什么关系都没有</p></blockquote><p>这里的Lambda/匿名函数/req-&gt;{//blablabla}就是一个处理器（Handler），在随后的例子中，我们用1stHandler以及2ndHandler来指代具体的匿名函数，让代码更加清晰明了，放在Verticle中类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        vertx.createHttpServer().requestHandler(<span class="number">1</span>stHandler).listen(<span class="number">8080</span>);</span><br><span class="line">    vertx.createHttpServer().requestHandler(<span class="number">2</span>ndHandler).listen(<span class="number">8081</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你通过提供handlers来handle事件，比如如果你要收到一个时间事件你应该：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vertx.setPeriodic(<span class="number">1000</span>, id -&gt; &#123; <span class="comment">// This handler will get called every second System.out.println("timer fired!");</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//HTTP request</span></span><br><span class="line">server.requestHandler(request -&gt; &#123;</span><br><span class="line">  <span class="comment">// This handler will be called every time an HTTP request is received at the server</span></span><br><span class="line">  request.response().end(<span class="string">"hello world!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>过以后当Vert.x有一个事件经过你的handler时，Vert.x将异步调用它。<br>这使我们想到Vert.x中的一些重要概念</p><h2 id="Don’t-block-me"><a href="#Don’t-block-me" class="headerlink" title="Don’t block me!"></a>Don’t block me!</h2><p>除了极少数例外（某些文件系统以’Sync’结尾）,Vert.x中所有API均不会阻塞调用线程<br>如果可以立即提供结果，将立即返回结果，否则通常会在一段时间后提供处理程序以接受事件<br>没有Vert.xAPI阻塞意味着你可以用少量线程来处理大量并发<br>传统的blocking API可能会在以下情况下block：</p><ul><li>读数据from a socket</li><li>写数据到磁盘</li><li>向收件人发送消息并等待回复</li><li>许多其他情况<br>上述情况下您的线程等待结果时无法执行其他任何操作——就很没用<br>阻塞API进行大量并发操作需要大量线程防止应用程序停止运行，线程在其所需内存（堆栈）和上下文切换方面都有开销<br>所以在现代应用所需的并发级别中，blocking方法无法扩展</li></ul><h2 id="Reactor-and-Multi-Reactor"><a href="#Reactor-and-Multi-Reactor" class="headerlink" title="Reactor and Multi-Reactor"></a>Reactor and Multi-Reactor</h2><p>在大多数情况下，Vert.x使用称为事件循环(event loop)的线程来调用处理程序。<br>「由于没有blocks」这句话将会大量的看到。因为它，event loop可以轻松地在事件到达时连续地将事件传递给不同的处理程序。event loop可以潜在地在短时间内交付大量事件，比如单event loop可以快速处理数千个HTTP requests——<br>我们称之为 Reactor Pattern（反应堆模式）<br>Node.js也实现了这种模式，但这不太一样。</p><blockquote><p>在标准的反应堆实现中，只有一个事件循环线程(single event loop thread)，该线程在一个循环中运行，将所有事件到达时将所有事件传递给它们。<br>单线程的麻烦是只能在任何时间运行在单个内核上，因此，如果您希望单线程反应堆应用程序能够在多核服务器上扩展，则必须启动并管理许多不同的流程<br>Vert.x在这里的工作方式有所不同。每个Vertx实例都维护多个事件循环，而不是单个事件循环。默认情况下，我们根据计算机上可用内核的数量选择数量，可以选择覆写<br>意味着单个Vertx进程可以在整个服务器上扩展<br>我们称之为多反应堆模式<br>即使Vertx实例维护多个事件循环，也不会同步执行任何特定handler，绝大数时间将使用完全相同的event loop进行调用</p></blockquote><h2 id="The-Golden-Rule-Don’t-Block-the-Event-Loop"><a href="#The-Golden-Rule-Don’t-Block-the-Event-Loop" class="headerlink" title="The Golden Rule - Don’t Block the Event Loop"></a>The Golden Rule - Don’t Block the Event Loop</h2><p>不要block event loop <strong>yourself</strong>！包括：</p><ul><li>thread.sleep()</li><li>Waiting on a lock（等待锁）</li><li>Waiting on a mutex or monitor(等待互斥或监视器 比如synchronized section）</li><li>进行长时间的数据库操作并等待结果</li><li>进行复杂的需要花费大量时间的计算</li><li>自旋<br>那么多久的时间是可以等待的呢？取决于你的程序和并发量</li></ul><p><strong>数学并不难。</strong><br>如果您的应用程序没有响应，可能表明您在某处阻止了event loop，Vertx会自动记录警告，如果您在日志中看到这些警告您应进行调查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread vertx-eventloop-thread-3 has been blocked for 20458 ms</span><br></pre></td></tr></table></figure><p>Vertx还将提供堆栈跟踪来精确定位<br>在创建Vertx对象之前改变VertxOptions对象可以改变这些设置。</p><h2 id="Running-blocking-code"><a href="#Running-blocking-code" class="headerlink" title="Running blocking code"></a>Running blocking code</h2><p>很多库，尤其是JVM生态系统中，有同步APIs和大量阻塞方法。像JDBC API，它固有的同步，那么无论Vertx多么努力，都无法使其变成异步的。<br>我们不会在一夜之间将所有方法写成异步的，所以我们提供了在Vertx安全使用传统的blocking APIs的办法<br>通过调用<code>executeBlocking</code>同时指定要执行的阻塞代码和执行了阻塞代码后被异步回调的结果程序来完成这个任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vertx.excuteBlocking(promise -&gt;&#123;</span><br><span class="line">  <span class="comment">//Call some blocking API that takes a significant amount of time to return</span></span><br><span class="line">  String result = someAPI.blockingMethod(<span class="string">"hello"</span>);</span><br><span class="line">  promise.complete(result);</span><br><span class="line">&#125;,res -&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">"The result is: "</span> + res.result());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>阻塞代码应在合理的时间内阻塞，这排除了长阻塞和轮询操作。当阻塞10秒钟以上时，阻塞线程检查器将在控制台上显示一条消息。长阻塞操作应使用由应用程序管理的专用线程，可以和事件总线或<code>runOnContext</code>和verticles交互。</p></blockquote><p>如果从同一上下文（比如相同的verticle 实例）多次调用<code>executeBlocking</code>，则会依次执行不同的<code>executeBlocking</code>.<br>如果您不关心顺序，那么<code>executeBlocking</code>也可以特定为ordered为false，任何executeBlocking都可能在工作池上并行执行<br>另一种可以选择的方法是用工作verticle(worker verticle)<br>Worker verticle总是通过一个worker pool里的来的线程执行的<br>blocking code默认在Vertx worker pool上执行，配置于<code>setWorkderPoolSize</code><br>可以出于其他目的创造pools：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WorkerExecutor executor = vertx.createSharedWorkerExecutor(<span class="string">"my-worker-pool"</span>);</span><br><span class="line">executor.executeBlocking(promise -&gt; &#123;</span><br><span class="line">  <span class="comment">// Call some blocking API that takes a significant amount of time to return</span></span><br><span class="line">  String result = someAPI.blockingMethod(<span class="string">"hello"</span>);</span><br><span class="line">  promise.complete(result);</span><br><span class="line">&#125;, res -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"The result is: "</span> + res.result());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意worker executor如果不再用必须被关上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor.close();</span><br></pre></td></tr></table></figure><p>当使用相同的名称创建多个workers，它们会享用相同的pool，worker pool在所有worker executors关闭时会被销毁。<br>一个executor在Verticle创建后，Vertx会自动关闭它当Verticle取消部署后<br>可以在创建executors时配置它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> poolSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 minutes</span></span><br><span class="line"><span class="keyword">long</span> maxExecuteTime = <span class="number">2</span>;</span><br><span class="line">TimeUnit maxExecuteTimeUnit = TimeUnit.MINUTES;</span><br><span class="line"></span><br><span class="line">WorkerExecutor executor = vertx.createSharedWorkerExecutor(<span class="string">"my-worker-pool"</span>, poolSize, maxExecuteTime, maxExecuteTimeUnit);</span><br></pre></td></tr></table></figure><h2 id="Async-coordination（异步协调）"><a href="#Async-coordination（异步协调）" class="headerlink" title="Async coordination（异步协调）"></a>Async coordination（异步协调）</h2><p>Vertx <code>futures</code>可以实现多个异步结果的协调。它支持并发组合（并行运行多个异步操作）和顺序组合（链异步操作）</p><h3 id="Concurrent-composition-并发组成-合并"><a href="#Concurrent-composition-并发组成-合并" class="headerlink" title="Concurrent composition(并发组成[合并?])"></a>Concurrent composition(并发组成[合并?])</h3><p><code>CompositeFuture.all</code>接受几个futures参数（最多6个），并返回一个future，当所有future都成功时，该future将成功；如果至少一个future失败，则将失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;HttpServer&gt; httpServerFuture = Future.future(promise -&gt; httpServer.listen(promise));</span><br><span class="line"></span><br><span class="line">Future&lt;NetServer&gt; netServerFuture = Future.future(promise -&gt; netServer.listen(promise));</span><br><span class="line"></span><br><span class="line">CompositeFuture.all(httpServerFuture, netServerFuture).onComplete(ar -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    <span class="comment">// All servers started</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// At least one server failed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所有被合并的<code>Future</code>中的操作同时运行。当组合的处理操作完成时，该方法返回的<code>Future</code>上绑定的处理器（Handler）会被调用。可以传入一个<code>Future</code>列表（可能为空）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompositeFuture.all(Arrays.asList(future1, future2, future3));</span><br></pre></td></tr></table></figure><p>any方法会等待第一个成功执行的Future，当任意一个Future成功得到结果，则该<code>Future</code>成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompositeFuture.any(future1, future2).onComplete(ar -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    <span class="comment">// At least one is succeeded</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// All failed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>join</code>方法的合并会等待所有的Future完成，无论成败，并将结果归并成一个Future，当至少一个Future执行失败，得到的Future就是失败的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompositeFuture.join(future1, future2, future3).onComplete(ar -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    <span class="comment">// All succeeded</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// All completed and at least one failed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>都可以传列表参，都最多有6个的限制。</p><h3 id="Sequential-composition（顺序合并）"><a href="#Sequential-composition（顺序合并）" class="headerlink" title="Sequential composition（顺序合并）"></a>Sequential composition（顺序合并）</h3><p>与<code>all</code>和<code>any</code>实现的并发组合不同，<code>compose</code>方法用于顺序组合<code>Future</code>（chaining futures)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FileSystem fs = vertx.fileSystem();</span><br><span class="line"></span><br><span class="line">Future&lt;Void&gt; fut1 = Future.future(promise -&gt; fs.createFile(<span class="string">"/foo"</span>, promise));</span><br><span class="line"></span><br><span class="line">Future&lt;Void&gt; startFuture = fut1</span><br><span class="line">  .compose(v -&gt; &#123;</span><br><span class="line">  <span class="comment">// When the file is created (fut1), execute this:</span></span><br><span class="line">  <span class="keyword">return</span> Future.&lt;Void&gt;future(promise -&gt; fs.writeFile(<span class="string">"/foo"</span>, Buffer.buffer(), promise));</span><br><span class="line">&#125;)</span><br><span class="line">  .compose(v -&gt; &#123;</span><br><span class="line">  <span class="comment">// When the file is written (fut2), execute this:</span></span><br><span class="line">  <span class="keyword">return</span> Future.future(promise -&gt; fs.move(<span class="string">"/foo"</span>, <span class="string">"/bar"</span>, promise));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>一个文件被创建(fut1)</li><li>一些东西被写入到文件(fut2)</li><li>文件被移走(startFuture)<br>如果全部成功，那么最终的startFuture也是成功的。</li></ol><p>例子中使用了：</p><ul><li><code>compose(mapper)</code>:当前future完成时，执行给出的函数体，返回一个future，返回的future完成时，组合完成</li><li><code>compose(handler,next)</code>:当前future，执行相关代码并完成下一个future的处理（给出的处理器完成了给出的<code>next</code> future)<br>第二个例子中，处理器需要完成<code>next</code> future，以此来汇报处理成功或者失败</li></ul><h2 id="Verticles"><a href="#Verticles" class="headerlink" title="Verticles"></a>Verticles</h2><p>Vert.x通过开箱即用的方式提供了一个简单便捷的、可扩展的、类似Actor Model的部署和并发模型机制。您可以用此模型机制来保管您自己的代码组件。<br>它是可选的。</p><blockquote><p>Verticle 是由 Vert.x 部署和运行的代码块。默认情况一个 Vert.x 实例维护了N（默认情况下N = CPU核数 x 2）个 Event Loop 线程。Verticle 实例可使用任意 Vert.x 支持的编程语言编写，而且一个简单的应用程序也可以包含多种语言编写的 Verticle。</p></blockquote><p>这个模型不能说是严格的Actor模式的实现，但它确实有相似之处，特别是在并发、扩展性和部署等方面<br>您可以将 Verticle 想成 Actor Model 中的 Actor。<br>要使用该模型，您需要将您的代码组织成一系列的<strong>Verticle</strong>。</p><p>一个应用程序通常是由在同一个 Vert.x 实例中同时运行的许多 Verticle 实例组合而成。不同的 Verticle 实例通过向 Event Bus 上发送消息来相互通信。</p><h3 id="Writing-Verticle"><a href="#Writing-Verticle" class="headerlink" title="Writing Verticle"></a>Writing Verticle</h3><p>必须实现Verticle接口<br>直接从抽象类AbstractVerticle继承更简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Called when verticle is deployed</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Optional - called when verticle is undeployed</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常您需要重写start。Vertx部署Verticle时，它的start方法将被调用。<br>stop同理，Vertx撤销一个Verticle时它会被调用</p><h3 id="Asynchronous-Verticle-start-and-stop-异步启动和终止"><a href="#Asynchronous-Verticle-start-and-stop-异步启动和终止" class="headerlink" title="Asynchronous Verticle start and stop(异步启动和终止)"></a>Asynchronous Verticle start and stop(异步启动和终止)</h3><p>比如您想在Verticle启动耗费时间的这个过程中做一些事，比如在<code>start</code>方法中部署其他的Verticle——<br>您不能在start方法中阻塞等待其他的Verticle部署完成<br>您可以实现异步版本的start来做它。这个版本的方法会以一个 Future 作参数被调用。方法执行完时，Verticle 实例<strong>并没有</strong>部署好（状态不被认为 deployed）。<br>稍后，您完成了所有您需要做的事（如：启动其他Verticle），您就可以调用 Future 的 complete（或 fail ）方法来标记启动完成或失败了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> HttpServer server;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; startFuture)</span> </span>&#123;</span><br><span class="line">   server = vertx.createHttpServer().requestHandler(req -&gt; &#123;</span><br><span class="line">     req.response()</span><br><span class="line">       .putHeader(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">       .end(<span class="string">"Hello from Vert.x!"</span>);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now bind the server:</span></span><br><span class="line">   server.listen(<span class="number">8080</span>, res -&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">       startFuture.complete();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       startFuture.fail(res.cause());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//same stop method too</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Do something</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Future&lt;Void&gt; stopFuture)</span> </span>&#123;</span><br><span class="line">   obj.doSomethingThatTakesTime(res -&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">       stopFuture.complete();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       stopFuture.fail();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要手动stop verticle启动的 HTTP server，会在…的时候自动撤销</p><h3 id="Verticle-types"><a href="#Verticle-types" class="headerlink" title="Verticle types"></a>Verticle types</h3><ul><li>Stardand Verticle：这是最常用的一类 Verticle —— 它们永远运行在 Event Loop 线程上。稍后的章节我们会讨论更多。</li><li>Worker Verticle：这类 Verticle 会运行在 Worker Pool 中的线程上。一个实例绝对不会被多个线程同时执行。</li></ul><h4 id="Standard-Verticle"><a href="#Standard-Verticle" class="headerlink" title="Standard Verticle"></a>Standard Verticle</h4><p>当 Standard Verticle 被创建时，它会被分派给一个 Event Loop 线程，并在这个 Event Loop 中执行它的 start 方法。当您在一个 Event Loop 上调用了 Core API 中的方法并传入了处理器时，Vert.x 将保证用与调用该方法时相同的 Event Loop 来执行这些处理器。</p><p>这意味着我们可以保证您的 Verticle 实例中所有的代码都是在相同Event Loop中执行（只要您不创建自己的线程并调用它！）</p><p>同样意味着您可以将您的应用中的所有代码用单线程方式编写，让 Vert.x 去考虑线程和扩展问题。您不用再考虑 synchronized 和 volatile 的问题，也可以避免传统的多线程应用经常会遇到的竞态条件和死锁的问题。</p><h4 id="worker-Verticle"><a href="#worker-Verticle" class="headerlink" title="worker Verticle"></a>worker Verticle</h4><p>正如之前所说的，这东西被设计来调用阻塞式代码，不会阻塞Event loop，由Vert.x中的 Worker Pool 中的线程执行。<br>如果您不想使用 Worker Verticle 来运行阻塞式代码，您还可以在一个Event Loop中直接使用 内联阻塞式代码。<br>若您想要将 Verticle 部署成一个 Worker Verticle，您可以通过 setWorker 方法来设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setWorker(<span class="keyword">true</span>);</span><br><span class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, options);</span><br></pre></td></tr></table></figure><p>Worker Verticle 实例绝对不会在 Vert.x 中被多个线程同时执行，但它可以在不同时间由不同线程执行。</p><blockquote><p>警告：Multi-threaded Worker Verticle 是一个高级功能，大部分应用程序不会需要它。</p></blockquote><h4 id="Deploying-verticles-programmatically"><a href="#Deploying-verticles-programmatically" class="headerlink" title="Deploying verticles programmatically"></a>Deploying verticles programmatically</h4><blockquote><p>通过 Verticle 实例 来部署 Verticle 仅限Java<br>您可以指定一个 Verticle 名称或传入您已经创建好的 Verticle 实例，使用任意一个 deployVerticle 方法来部署Verticle。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Verticle myVerticle = <span class="keyword">new</span> MyVerticle();</span><br><span class="line">vertx.deployVerticle(myVerticle);</span><br></pre></td></tr></table></figure><p>指定 Verticle 的 名称 来部署它，这个名称会用于查找实例化 Verticle 的特定 VerticleFactory。<br>不同的 Verticle Factory 可用于实例化不同语言的 Verticle，也可用于其他目的，例如加载服务、运行时从Maven中获取Verticle实例等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部署JavaScript的Verticle</span></span><br><span class="line">vertx.deployVerticle(<span class="string">"verticles/myverticle.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部署Ruby的Verticle</span></span><br><span class="line">vertx.deployVerticle(<span class="string">"verticles/my_verticle.rb"</span>);</span><br></pre></td></tr></table></figure><h4 id="Rules-for-mapping-a-verticle-name-to-a-verticle-factory-Verticle名称到Factory的映射规则"><a href="#Rules-for-mapping-a-verticle-name-to-a-verticle-factory-Verticle名称到Factory的映射规则" class="headerlink" title="Rules for mapping a verticle name to a verticle factory(Verticle名称到Factory的映射规则)"></a>Rules for mapping a verticle name to a verticle factory(Verticle名称到Factory的映射规则)</h4><p>Verticle 名称可以有一个前缀 —— 使用字符串紧跟着一个冒号，它用于查找存在的Factory，参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js:foo.js <span class="comment">// Use the JavaScript verticle factory</span></span><br><span class="line">groovy:com.mycompany.SomeGroovyCompiledVerticle <span class="comment">// Use the Groovy verticle factory </span></span><br><span class="line">service:com.mycompany:myorderservice <span class="comment">// Uses the service verticle factory</span></span><br></pre></td></tr></table></figure><p>如果不指定前缀，Vert.x将根据提供名字后缀来查找对应Factory，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.js <span class="comment">// 将使用JavaScript的Factory</span></span><br><span class="line">SomeScript.groovy <span class="comment">// 将使用Groovy的Factory</span></span><br></pre></td></tr></table></figure><p>都没指定，Vert.x将假定这个名字是一个Java 全限定类名（FQCN）然后尝试实例化它。</p><h4 id="How-are-Verticle-Factories-located"><a href="#How-are-Verticle-Factories-located" class="headerlink" title="How are Verticle Factories located?"></a>How are Verticle Factories located?</h4><p>大部分Verticle Factory会从 classpath 中加载，并在 Vert.x 启动时注册。</p><p>您同样可以使用编程的方式去注册或注销Verticle Factory：通过<code>registerVerticleFactory</code>方法和<code>unregisterVerticleFactory</code>方法。</p><h4 id="Waiting-for-deployment-to-complete"><a href="#Waiting-for-deployment-to-complete" class="headerlink" title="Waiting for deployment to complete"></a>Waiting for deployment to complete</h4><p>Verticle的部署是异步方式，可能在<code>deploy</code>方法调用返回后一段时间才会完成部署。</p><p>如果您想要在部署完成时被通知则可以指定一个完成处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Deployment id is: "</span> + res.result());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Deployment failed!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果部署成功，这个完成处理器的结果中将会包含部署ID的字符串。这个部署 ID可以在之后您想要撤销它时使用。</p><h4 id="Undeploying-verticle-deployments"><a href="#Undeploying-verticle-deployments" class="headerlink" title="Undeploying verticle deployments"></a>Undeploying verticle deployments</h4><p>我们可以通过<code>undeploy</code>方法来撤销部署好的 Verticle。</p><p>撤销操作也是异步的，因此若您想要在撤销完成过后收到通知则可以指定另一个完成处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vertx.undeploy(deploymentID, res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Undeployed ok"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Undeploy failed!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Specifying-number-of-veritcle-instances-设置-Verticle-实例数"><a href="#Specifying-number-of-veritcle-instances-设置-Verticle-实例数" class="headerlink" title="Specifying number of veritcle instances(设置 Verticle 实例数)"></a>Specifying number of veritcle instances(设置 Verticle 实例数)</h4><p>当使用名称部署一个 Verticle 时，您可以指定您想要部署的 Verticle 实例的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setInstances(<span class="number">16</span>);</span><br><span class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, options);</span><br></pre></td></tr></table></figure><p>这个功能对于跨多核扩展时很有用。例如，您有一个实现了Web服务器的Verticle需要部署在多核的机器上，您可以部署多个实例来利用所有的核。</p><h4 id="Passing-configuration-to-a-verticle"><a href="#Passing-configuration-to-a-verticle" class="headerlink" title="Passing configuration to a verticle"></a>Passing configuration to a verticle</h4><p>可在部署时传给 Verticle 一个 JSON 格式的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JsonObject config = <span class="keyword">new</span> JsonObject().put(<span class="string">"name"</span>, <span class="string">"tim"</span>).put(<span class="string">"directory"</span>, <span class="string">"/blah"</span>);</span><br><span class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setConfig(config);</span><br><span class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, options);</span><br></pre></td></tr></table></figure><p>传入之后，这个配置可以通过 Context 对象或使用 config 方法访问。</p><p>这个配置会以 JSON 对象（JsonObject）的形式返回，因此您可以用下边代码读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Configuration: "</span> + config().getString(<span class="string">"name"</span>));</span><br></pre></td></tr></table></figure><h4 id="Accessing-environment-variables-in-a-Verticle-在-Verticle-中访问环境变量"><a href="#Accessing-environment-variables-in-a-Verticle-在-Verticle-中访问环境变量" class="headerlink" title="Accessing environment variables in a Verticle(在 Verticle 中访问环境变量)"></a>Accessing environment variables in a Verticle(在 Verticle 中访问环境变量)</h4><p>环境变量和系统属性可以直接通过 Java API 访问：</p><p>System.getProperty(“prop”);<br>System.getenv(“HOME”);</p><h4 id="Verticle-Isolation-Groups"><a href="#Verticle-Isolation-Groups" class="headerlink" title="Verticle Isolation Groups"></a>Verticle Isolation Groups</h4><blockquote><p>警告：谨慎使用此功能，类加载器可能会导致您的应用难于调试，变得一团乱麻（can of worms）。<br>您可能需要部署一个Verticle，它包含的类要与应用程序中其他类隔离开来。比如您想要在一个Vert.x实例中部署两个同名不同版本的Verticle，或者不同的Verticle使用了同一个jar包的不同版本。<br>当使用隔离组时，您需要用 setIsolatedClassed 方法来提供一个您想隔离的类名列表。列表项可以是一个Java 限定类全名，也可以是包含通配符的可匹配某个包或子包的任何类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setIsolationGroup(<span class="string">"mygroup"</span>);</span><br><span class="line">options.setIsolatedClasses(Arrays.asList(<span class="string">"com.mycompany.myverticle.*"</span>,</span><br><span class="line">                   <span class="string">"com.mycompany.somepkg.SomeClass"</span>, <span class="string">"org.somelibrary.*"</span>));</span><br><span class="line">vertx.deployVerticle(<span class="string">"com.mycompany.myverticle.VerticleClass"</span>, options);</span><br></pre></td></tr></table></figure><h4 id="High-Availability"><a href="#High-Availability" class="headerlink" title="High Availability"></a>High Availability</h4><p>在这种方式下，当其中一个部署在 Vert.x 实例中的 Verticle 突然挂掉，这个 Verticle 可以在集群环境中的另一个 Vert.x 实例中重新部署。<br>若要启用高可用方式运行一个 Verticle，仅需要追加 -ha 参数，且无需 -cluster：<br><code>vertx run my-verticle.js -ha</code></p><h4 id="Running-Verticles-from-the-command-line"><a href="#Running-Verticles-from-the-command-line" class="headerlink" title="Running Verticles from the command line"></a>Running Verticles from the command line</h4><p>您可以在 Maven 或 Gradle 项目中以正常方式添加 Vert.x Core 为依赖，在项目中直接使用 Vert.x。</p><h4 id="Causing-Vert-x-to-exit"><a href="#Causing-Vert-x-to-exit" class="headerlink" title="Causing Vert.x to exit"></a>Causing Vert.x to exit</h4><p>Vert.x 实例维护的线程不是守护线程，因此它们会阻止JVM退出。</p><p>如果您通过嵌入式的方式使用 Vert.x 并且完成了操作，您可以调用 close 方法关闭它。这将关闭所有内部线程池并关闭其他资源，允许JVM退出。</p><h4 id="The-Context-object"><a href="#The-Context-object" class="headerlink" title="The Context object"></a>The Context object</h4><p>每个 Verticle 在部署的时候都会被分配一个 Context（根据配置不同，可以是Event Loop Context 或者 Worker Context），之后此 Verticle 上所有的普通代码都会在此 Context 上执行（即对应的 Event Loop 或Worker 线程）<br>您可以通过 getOrCreateContext 方法获取 Context 实例<br>若已经有一个 Context 和当前线程关联，那么它直接重用这个 Context 对象，如果没有则创建一个新的。您可以检查获取的 Context 的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Context context = vertx.getOrCreateContext();</span><br><span class="line"><span class="keyword">if</span> (context.isEventLoopContext()) &#123;</span><br><span class="line">  System.out.println(<span class="string">"Context attached to Event Loop"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isWorkerContext()) &#123;</span><br><span class="line">  System.out.println(<span class="string">"Context attached to Worker Thread"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isMultiThreadedWorkerContext()) &#123;</span><br><span class="line">  System.out.println(<span class="string">"Context attached to Worker Thread - multi threaded worker"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (! Context.isOnVertxThread()) &#123;</span><br><span class="line">  System.out.println(<span class="string">"Context not attached to a thread managed by vert.x"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您获取了这个 Context 对象，您就可以在 Context 中异步执行代码了。换句话说，您提交的任务将会在同一个 Context 中运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vertx.getOrCreateContext().runOnContext( (v) -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"This will be executed asynchronously in the same context"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当在同一个 Context 中运行了多个处理函数时，可能需要在它们之间共享数据。 Context 对象提供了存储和读取共享数据的方法。举例来说，它允许您将数据传递到 runOnContext 方法运行的某些操作中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Context context = vertx.getOrCreateContext();</span><br><span class="line">context.put(<span class="string">"data"</span>, <span class="string">"hello"</span>);</span><br><span class="line">context.runOnContext((v) -&gt; &#123;</span><br><span class="line">  String hello = context.get(<span class="string">"data"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Executing-periodic-and-delayed-actions-执行周期性-延迟性操作"><a href="#Executing-periodic-and-delayed-actions-执行周期性-延迟性操作" class="headerlink" title="Executing periodic and delayed actions(执行周期性/延迟性操作)"></a>Executing periodic and delayed actions(执行周期性/延迟性操作)</h4><p>在 Vert.x 中，想要延迟之后执行或定期执行操作很常见。</p><p>在 Standard Verticle 中您不能直接让线程休眠以引入延迟，因为它会阻塞 Event Loop 线程。取而代之是使用 Vert.x 定时器。定时器可以是一次性或周期性的</p><h5 id="one-shot-Timers"><a href="#one-shot-Timers" class="headerlink" title="one-shot Timers"></a>one-shot Timers</h5><p>一次性计时器会在一定延迟后调用一个 Event Handler，以毫秒为单位计时。<br>您可以通过<code>setTimer</code>方法传递延迟时间和一个处理器来设置计时器的触发。<br>返回值是一个唯一的计时器id，该id可用于之后取消该计时器，这个计时器id会传入给处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timerID = vertx.setTimer(<span class="number">1000</span>, id -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"And one second later this is printed"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"First this is printed"</span>);</span><br></pre></td></tr></table></figure><h5 id="Periodic-Timers"><a href="#Periodic-Timers" class="headerlink" title="Periodic Timers"></a>Periodic Timers</h5><p>和一次性的一模一样，只不过…<br>请记住这个计时器将会定期触发。如果您的定时任务会花费大量的时间，则您的计时器事件可能会连续执行甚至发生更坏的情况：重叠。这种情况，您应考虑使用<code>setTimer</code>方法，当任务执行完成时设置下一个计时器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timerID = vertx.setPeriodic(<span class="number">1000</span>, id -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"And every second this is printed"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"First this is printed"</span>);</span><br></pre></td></tr></table></figure><h5 id="取消、清除"><a href="#取消、清除" class="headerlink" title="取消、清除"></a>取消、清除</h5><p>指定id,cancelTimer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx.cancelTimer(timerID);</span><br></pre></td></tr></table></figure><p>清除依然是Verticle被撤销时自动关闭</p><h4 id="Verticle-worker-pool"><a href="#Verticle-worker-pool" class="headerlink" title="Verticle worker pool"></a>Verticle worker pool</h4><p>Verticle 使用 Vert.x 中的 Worker Pool 来执行阻塞式行为，例如 executeBlocking 或 Worker Verticle。</p><p>可以在部署配置项中指定不同的Worker 线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx.deployVerticle(<span class="string">"the-verticle"</span>, <span class="keyword">new</span> DeploymentOptions().setWorkerPoolName(<span class="string">"the-specific-pool"</span>));</span><br></pre></td></tr></table></figure><h3 id="The-Event-Bus"><a href="#The-Event-Bus" class="headerlink" title="The Event Bus"></a>The Event Bus</h3><p>Event Bus 是 Vert.x 的<strong>神经系统</strong>。</p><p>每一个 Vert.x 实例都有一个单独的 Event Bus 实例。您可以通过 Vertx 实例的<code>eventBus</code>方法来获得对应的EventBus实例。</p><p>您的应用中的不同部分通过 Event Bus 相互通信，无论它们使用哪一种语言实现，无论它们在同一个 Vert.x 实例中或在不同的 Vert.x 实例中。</p><p>甚至可以通过桥接的方式允许在浏览器中运行的客户端JavaScript在相同的Event Bus上相互通信。</p><p>Event Bus可形成跨越多个服务器节点和多个浏览器的点对点的分布式消息系统。</p><p>Event Bus支持发布/订阅、点对点、请求/响应的消息通信方式。</p><p>Event Bus的API很简单。基本上只涉及注册处理器、撤销处理器和发送和发布消息。</p><p>首先来看些基本概念和理论。</p><h4 id="The-Theory"><a href="#The-Theory" class="headerlink" title="The Theory"></a>The Theory</h4><h5 id="Addressing"><a href="#Addressing" class="headerlink" title="Addressing"></a>Addressing</h5><p>消息会被 Event Bus 发送到一个 地址(address)。</p><p>同任何花哨的寻址方案相比，Vert.x的地址格式并不麻烦。Vert.x中的地址是一个简单的字符串，任意字符串都合法。当然，使用某种模式来命名仍然是明智的。如：使用点号来划分命名空间。</p><p>一些合法的地址形如：<code>europe.news.feed1</code>、<code>acme.games.pacman</code>、<code>sausages</code>和<code>X</code>。</p><h5 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h5><p>消息在处理器（Handler）中被接收。您可以在某个地址上注册一个处理器来接收消息。</p><p>同一个地址可以注册许多不同的处理器，一个处理器也可以注册在多个不同的地址上。</p><h5 id="publish-subscribe-messaging"><a href="#publish-subscribe-messaging" class="headerlink" title="publish/subscribe messaging"></a>publish/subscribe messaging</h5><p>发布/订阅消息<br>Event Bus支持<strong>发布消息</strong>功能。</p><p>消息将被发布到一个地址中，发布意味着会将信息传递给所有注册在该地址上的处理器。这和<strong>发布/订阅模式</strong>很类似。</p><h5 id="Point-to-point-and-Request-Response-messaging"><a href="#Point-to-point-and-Request-Response-messaging" class="headerlink" title="Point-to-point and Request-Response messaging"></a>Point-to-point and Request-Response messaging</h5><p>Event Bus也支持<strong>点对点</strong>消息模式。</p><p>消息将被发送到一个地址中，Vert.x将会把消息分发到某个注册在该地址上的处理器。若这个地址上有不止一个注册过的处理器，它将使用 不严格的轮询算法 选择其中一个。</p><p>点对点消息传递模式下，可在消息发送的时候指定一个应答处理器（可选）。</p><p>当接收者收到消息并且已经被处理时，它可以选择性决定回复该消息，若选择回复则绑定的应答处理器将会被调用。当发送者收到回复消息时，它也可以回复，这个过程可以不断重复。通过这种方式可以允许在两个不同的 Verticle 之间设置一个对话窗口。这种消息模式被称作<strong>请求-响应</strong>模式。</p><h5 id="Best-effort-delivery"><a href="#Best-effort-delivery" class="headerlink" title="Best-effort delivery"></a>Best-effort delivery</h5><p>Vert.x会尽它最大努力去传递消息，并且不会主动丢弃消息。这种方式称为 尽力传输(Best-effort delivery)。</p><p>但是，当 Event Bus 中的全部或部分发生故障时，则可能会丢失消息。</p><p>若您的应用关心丢失的消息，您应该编写具有幂等性的处理器，并且您的发送者可以在恢复后重试。(接口幂等：无论客户端调用服务端接口发起多少次请求，有且只有一次有效。)</p><p>RPC通信通常情况下有三种语义：at least once、at most once 和 exactly once。不同语义情况下要考虑的情况不同。</p><h5 id="Types-of-messages"><a href="#Types-of-messages" class="headerlink" title="Types of messages"></a>Types of messages</h5><p>Vert.x 默认允许任何基本/简单类型、String 或<code>buffers</code>作为消息发送。不过在 Vert.x 中的通常做法是使用 JSON 格式来发送消息。</p><p>JSON 对于 Vert.x 支持的所有语言都是非常容易创建、读取和解析的，因此它已经成为了Vert.x中的通用语(lingua franca)。但是若您不想用 JSON，我们并不强制您使用它。</p><p>Event Bus 非常灵活，它支持在 Event Bus 中发送任意对象。您可以通过为您想要发送的对象自定义一个<code>codec</code>来实现。</p><h4 id="The-Event-Bus-API"><a href="#The-Event-Bus-API" class="headerlink" title="The Event Bus API"></a>The Event Bus API</h4><h5 id="Getting-the-event-bus"><a href="#Getting-the-event-bus" class="headerlink" title="Getting the event bus"></a>Getting the event bus</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus eb = vertx.eventBus();</span><br></pre></td></tr></table></figure><p>对于每一个 Vert.x 实例来说它是单例的。</p><h5 id="Registering-Handlers"><a href="#Registering-Handlers" class="headerlink" title="Registering Handlers"></a>Registering Handlers</h5><p>最简单的注册处理器的方式是使用 consumer 方法，这儿有个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBus eb = vertx.eventBus();</span><br><span class="line"></span><br><span class="line">eb.consumer(<span class="string">"news.uk.sport"</span>, message -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"I have received a message: "</span> + message.body());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当一个消息达到您的处理器，该处理器会以 message 为参数被调用。</p><p>调用 consumer 方法会返回一个 MessageConsumer 对象。该对象随后可用于撤销处理器、或将处理器用作流式处理。</p><p>您也可以不设置处理器而使用 consumer 方法直接返回一个 MessageConsumer，之后再来设置处理器。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventBus eb = vertx.eventBus();</span><br><span class="line"></span><br><span class="line">MessageConsumer&lt;String&gt; consumer = eb.consumer(<span class="string">"news.uk.sport"</span>);</span><br><span class="line">consumer.handler(message -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"I have received a message: "</span> + message.body());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在集群模式下的Event Bus上注册处理器时，注册信息会花费一些时间才能传播到集群中的所有节点。</p><p>若您希望在完成注册后收到通知，您可以在 MessageConsumer 对象上注册一个 completion handler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">consumer.completionHandler(res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"The handler registration has reached all nodes"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Registration failed!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Un-registering-Handlers"><a href="#Un-registering-Handlers" class="headerlink" title="Un-registering Handlers"></a>Un-registering Handlers</h5><p>您可以通过 unregister() 方法来注销处理器。</p><p>若您在集群模式下的 Event Bus 中撤销处理器，则同样会花费一些时间在节点中传播。若您想在完成后收到通知，可以使用unregister(handler) 方法注册处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">consumer.unregister(res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"The handler un-registration has reached all nodes"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Un-registration failed!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Publishing-messages"><a href="#Publishing-messages" class="headerlink" title="Publishing messages"></a>Publishing messages</h5><p>发布消息很简单，只需使用<code>publish</code>方法指定一个地址去发布即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.publish(<span class="string">"news.uk.sport"</span>, <span class="string">"Yay! Someone kicked a ball"</span>);</span><br></pre></td></tr></table></figure><p>这个消息将会传递给所有在地址 news.uk.sport 上注册过的处理器。</p><h5 id="Sending-messages"><a href="#Sending-messages" class="headerlink" title="Sending messages"></a>Sending messages</h5><p>与发布消息的不同之处在于，发送(send)的消息只会传递给在该地址注册的其中一个处理器，这就是点对点模式。Vert.x 使用不严格的轮询算法来选择绑定的处理器。<br>publish改成send即可</p><h5 id="Setting-headers-on-messages"><a href="#Setting-headers-on-messages" class="headerlink" title="Setting headers on messages"></a>Setting headers on messages</h5><p>在 Event Bus 上发送的消息可包含头信息。这可通过在发送或发布时提供的 DeliveryOptions 来指定。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DeliveryOptions options = <span class="keyword">new</span> DeliveryOptions();</span><br><span class="line">options.addHeader(<span class="string">"some-header"</span>, <span class="string">"some-value"</span>);</span><br><span class="line">eventBus.send(<span class="string">"news.uk.sport"</span>, <span class="string">"Yay! Someone kicked a ball"</span>, options);</span><br></pre></td></tr></table></figure><h5 id="Message-ordering"><a href="#Message-ordering" class="headerlink" title="Message ordering"></a>Message ordering</h5><p>Vert.x将按照特定发送者发送消息的顺序来传递消息给特定处理器。</p><h5 id="The-Message-object"><a href="#The-Message-object" class="headerlink" title="The Message object"></a>The Message object</h5><p>您在消息处理器中接收到的对象的类型是<code>Message</code>。</p><p>消息的<code>body</code>对应发送或发布的对象。消息的头信息可以通过<code>headers</code>方法获取。</p><h5 id="Acknowledging-messages-sending-replies"><a href="#Acknowledging-messages-sending-replies" class="headerlink" title="Acknowledging messages / sending replies"></a>Acknowledging messages / sending replies</h5><p>当使用 send 方法发送消息时，Event Bus会尝试将消息传递到注册在Event Bus上的 MessageConsumer中。在某些情况下，发送者需要知道消费者何时收到消息并<em>处理</em>了消息。</p><p>消费者可以通过调用<code>reply</code>方法来应答这个消息。</p><p>当这种情况发生时，它会将消息回复给发送者并且在发送者中调用应答处理器来处理回复的消息。<br>看这个例子会更清楚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thre receiver</span></span><br><span class="line">MessageConsumer&lt;String&gt; consumer = eventBus.consumer(<span class="string">"news.uk.sport"</span>);</span><br><span class="line">consumer.handler(message -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"I have received a message: "</span> + message.body());</span><br><span class="line">  message.reply(<span class="string">"how interesting!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//The sender</span></span><br><span class="line">eventBus.request(<span class="string">"news.uk.sport"</span>, <span class="string">"Yay! Someone kicked a ball across a patch of grass"</span>, ar -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Received reply: "</span> + ar.result().body());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Sending-with-timeouts"><a href="#Sending-with-timeouts" class="headerlink" title="Sending with timeouts"></a>Sending with timeouts</h5><p>当发送带有应答处理器的消息时，可以在 DeliveryOptions 中指定一个超时时间。如果在这个时间之内没有收到应答，则会以失败为参数调用应答处理器。默认超时是 30 秒。</p><h5 id="Send-Failures"><a href="#Send-Failures" class="headerlink" title="Send Failures"></a>Send Failures</h5><p>消息发送可能会因为其他原因失败，包括：</p><ul><li>没有可用的处理器来接收消息</li><li>接收者调用了 fail 方法显式声明失败</li></ul><p>发生这些情况时，应答处理器将会以这些失败为参数被调用。</p><h5 id="Message-Codecs"><a href="#Message-Codecs" class="headerlink" title="Message Codecs"></a>Message Codecs</h5><p>您可以在 Event Bus 中发送任何对象，只要你为这个对象类型注册一个编解码器 MessageCodec。消息编解码器有一个名称，您需要在发送或发布消息时通过 DeliveryOptions 来指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eventBus.registerCodec(myCodec);</span><br><span class="line"></span><br><span class="line">DeliveryOptions options = <span class="keyword">new</span> DeliveryOptions().setCodecName(myCodec.name());</span><br><span class="line"></span><br><span class="line">eventBus.send(<span class="string">"orders"</span>, <span class="keyword">new</span> MyPOJO(), options);</span><br></pre></td></tr></table></figure><p>若您总是希望某个类使用将特定的编解码器，那么您可以为这个类注册默认编解码器。这样您就不需要在每次发送的时候使用 DeliveryOptions 来指定了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eventBus.registerDefaultCodec(MyPOJO<span class="class">.<span class="keyword">class</span>, <span class="title">myCodec</span>)</span>;</span><br><span class="line"></span><br><span class="line">eventBus.send(<span class="string">"orders"</span>, <span class="keyword">new</span> MyPOJO());</span><br></pre></td></tr></table></figure><p>您可以通过 unregisterCodec 方法注销某个消息编解码器。</p><p>消息编解码器的编码和解码不一定使用同一个类型。例如您可以编写一个编解码器来发送 MyPOJO 类的对象，但是当消息发送给处理器后解码成 MyOtherPOJO 对象。</p><h5 id="Clustered-Event-Bus"><a href="#Clustered-Event-Bus" class="headerlink" title="Clustered Event Bus"></a>Clustered Event Bus</h5><p>Event Bus 不仅仅存在于单个 Vert.x 实例中。通过您在网络上将不同的 Vert.x 实例集群在一起，它可以形成一个单一的、分布式的Event Bus。</p><h5 id="Clustering-programmatically"><a href="#Clustering-programmatically" class="headerlink" title="Clustering programmatically"></a>Clustering programmatically</h5><p>若您用编程的方式创建 Vert.x 实例（Vertx），则可以通过将 Vert.x 实例配置成集群模式来获取集群模式的Event Bus：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VertxOptions options = <span class="keyword">new</span> VertxOptions();</span><br><span class="line">Vertx.clusteredVertx(options, res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    Vertx vertx = res.result();</span><br><span class="line">    EventBus eventBus = vertx.eventBus();</span><br><span class="line">    System.out.println(<span class="string">"We now have a clustered event bus: "</span> + eventBus);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Failed: "</span> + res.cause());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Clustering-on-the-command-line"><a href="#Clustering-on-the-command-line" class="headerlink" title="Clustering on the command line"></a>Clustering on the command line</h5><p>-cluster</p><h4 id="Automatic-clean-up-in-verticles"><a href="#Automatic-clean-up-in-verticles" class="headerlink" title="Automatic clean-up in verticles"></a>Automatic clean-up in verticles</h4><p>若您在 Verticle 中注册了 Event Bus 的处理器，那么这些处理器在 Verticle 被撤销的时候会自动被注销。</p><h4 id="Configuring-the-event-bus"><a href="#Configuring-the-event-bus" class="headerlink" title="Configuring the event bus"></a>Configuring the event bus</h4><p>Event Bus 是可以配置的，这对于以集群模式运行的 Event Bus 是非常有用的。Event Bus 使用 TCP 连接发送和接收消息，因此可以通过<code>EventBusOptions</code>对TCP连接进行全面的配置。由于 Event Bus 同时用作客户端和服务器，因此这些配置近似于<code>NetClientOptions</code>和<code>NetServerOptions</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">VertxOptions options = <span class="keyword">new</span> VertxOptions()</span><br><span class="line">    .setEventBusOptions(<span class="keyword">new</span> EventBusOptions()</span><br><span class="line">        .setSsl(<span class="keyword">true</span>)</span><br><span class="line">        .setKeyStoreOptions(<span class="keyword">new</span> JksOptions().setPath(<span class="string">"keystore.jks"</span>).setPassword(<span class="string">"wibble"</span>))</span><br><span class="line">        .setTrustStoreOptions(<span class="keyword">new</span> JksOptions().setPath(<span class="string">"keystore.jks"</span>).setPassword(<span class="string">"wibble"</span>))</span><br><span class="line">        .setClientAuth(ClientAuth.REQUIRED)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">Vertx.clusteredVertx(options, res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    Vertx vertx = res.result();</span><br><span class="line">    EventBus eventBus = vertx.eventBus();</span><br><span class="line">    System.out.println(<span class="string">"We now have a clustered event bus: "</span> + eventBus);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Failed: "</span> + res.cause());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上边代码段描述了如何在Event Bus中使用SSL连接替换传统的TCP连接。</p><blockquote><p>警告：若要在集群模式下保证安全性，您 必须 将集群管理器配置成加密的或强制安全的。参考集群管理器的文档获取更多细节。</p></blockquote><p>Event Bus 的配置需要在所有集群节点中保持一致性。</p><p>EventBusOptions还允许您指定 Event Bus 是否运行在集群模式下，以及它的主机信息和端口。您可使用 setClustered、getClusterHost和 getClusterPort 方法来设置。</p><p>在容器中使用时，您也可以配置公共主机和端口号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VertxOptions options = <span class="keyword">new</span> VertxOptions()</span><br><span class="line">    .setEventBusOptions(<span class="keyword">new</span> EventBusOptions()</span><br><span class="line">        .setClusterPublicHost(<span class="string">"whatever"</span>)</span><br><span class="line">        .setClusterPublicPort(<span class="number">1234</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">Vertx.clusteredVertx(options, res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    Vertx vertx = res.result();</span><br><span class="line">    EventBus eventBus = vertx.eventBus();</span><br><span class="line">    System.out.println(<span class="string">"We now have a clustered event bus: "</span> + eventBus);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Failed: "</span> + res.cause());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>和其他一些语言不同，Java 没有对 JSON 的原生支持（first class support），因此我们提供了两个类，以便在 Vert.x 应用中处理 JSON 更容易。</p><h3 id="JSON-object"><a href="#JSON-object" class="headerlink" title="JSON object"></a>JSON object</h3><p>JsonObject 类用来描述JSON对象。</p><p>一个JSON 对象基本上只是一个 Map 结构。它具有字符串的键，值可以是任意一种JSON 支持的类型（如 string, number, boolean）。</p><p>JSON 对象也支持 null 值。</p><h4 id="Creating-JSON-objects-创建-JSON-对象"><a href="#Creating-JSON-objects-创建-JSON-对象" class="headerlink" title="Creating JSON objects 创建 JSON 对象"></a>Creating JSON objects 创建 JSON 对象</h4><p>可以使用默认构造函数创建空的JSON对象。</p><p>您可以通过一个 JSON 格式的字符串创建JSON对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String jsonString = <span class="string">"&#123;\"foo\":\"bar\"&#125;"</span>;</span><br><span class="line">JsonObject object = <span class="keyword">new</span> JsonObject(jsonString);</span><br></pre></td></tr></table></figure><p>您可以从通过一个Map创建JSON对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">map.put(<span class="string">"xyz"</span>, <span class="number">3</span>);</span><br><span class="line">JsonObject object = <span class="keyword">new</span> JsonObject(map);</span><br></pre></td></tr></table></figure><h4 id="Putting-entries-into-a-JSON-object-将键值对放入-JSON-对象"><a href="#Putting-entries-into-a-JSON-object-将键值对放入-JSON-对象" class="headerlink" title="Putting entries into a JSON object 将键值对放入 JSON 对象"></a>Putting entries into a JSON object 将键值对放入 JSON 对象</h4><p>使用put 方法可以将值放入到JSON对象里。</p><p>这个API是流式的，因此这个方法可以被链式地调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JsonObject object = <span class="keyword">new</span> JsonObject();</span><br><span class="line">object.put(<span class="string">"foo"</span>, <span class="string">"bar"</span>).put(<span class="string">"num"</span>, <span class="number">123</span>).put(<span class="string">"mybool"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h4 id="Getting-values-from-a-JSON-object-从-JSON-对象获取值"><a href="#Getting-values-from-a-JSON-object-从-JSON-对象获取值" class="headerlink" title="Getting values from a JSON object 从 JSON 对象获取值"></a>Getting values from a JSON object 从 JSON 对象获取值</h4><p>您可使用 getXXX 方法从JSON对象中获取值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String val = jsonObject.getString(<span class="string">"some-key"</span>);</span><br><span class="line"><span class="keyword">int</span> intVal = jsonObject.getInteger(<span class="string">"some-other-key"</span>);</span><br></pre></td></tr></table></figure><h4 id="Mapping-between-JSON-objects-and-Java-objects-JSON-对象和-Java-对象间的映射"><a href="#Mapping-between-JSON-objects-and-Java-objects-JSON-对象和-Java-对象间的映射" class="headerlink" title="Mapping between JSON objects and Java objects JSON 对象和 Java 对象间的映射"></a>Mapping between JSON objects and Java objects JSON 对象和 Java 对象间的映射</h4><p>您可以从 Java 对象的字段创建一个JSON 对象，如下所示：</p><p>你可以通过一个JSON 对象来实例化一个Java 对象并填充字段值。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.bodyHandler(buff -&gt; &#123;</span><br><span class="line">  JsonObject jsonObject = buff.toJsonObject();</span><br><span class="line">  User javaObject = jsonObject.mapTo(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在最简单的情况下，如果 Java 类中所有的字段都是 public（或者有 public 的 getter/setter）时，并且有一个 public 的默认构造函数（或不定义构造函数），mapFrom 和 mapTo 都应该成功。</p><p>只要不存在对象的循环引用，嵌套的 Java 对象可以被序列化/反序列化为嵌套的JSON对象。</p><h4 id="Encoding-a-JSON-object-to-a-String-将-JSON-对象编码成字符串"><a href="#Encoding-a-JSON-object-to-a-String-将-JSON-对象编码成字符串" class="headerlink" title="Encoding a JSON object to a String 将 JSON 对象编码成字符串"></a>Encoding a JSON object to a String 将 JSON 对象编码成字符串</h4><p>您可使用 encode 方法将一个对象编码成字符串格式。</p><p>如要得到更优美、格式化的字符串，可以使用 encodePrettily 方法。</p><h3 id="JSON-arrays-JSON-数组"><a href="#JSON-arrays-JSON-数组" class="headerlink" title="JSON arrays JSON 数组"></a>JSON arrays JSON 数组</h3><p>JsonArray 类用来描述 JSON数组。</p><p>一个JSON 数组是一个值的序列（值的类型可以是 string、number、boolean 等）。</p><p>JSON 数组同样可以包含 null 值。</p><h4 id="Creating-JSON-arrays-创建-JSON-数组"><a href="#Creating-JSON-arrays-创建-JSON-数组" class="headerlink" title="Creating JSON arrays 创建 JSON 数组"></a>Creating JSON arrays 创建 JSON 数组</h4><p>可以使用默认构造函数创建空的JSON数组。</p><p>您可以从JSON格式的字符串创建一个JSON数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String jsonString = <span class="string">"[\"foo\",\"bar\"]"</span>;</span><br><span class="line">JsonArray array = <span class="keyword">new</span> JsonArray(jsonString);</span><br></pre></td></tr></table></figure><h4 id="Adding-entries-into-a-JSON-array-将数组项添加到JSON数组"><a href="#Adding-entries-into-a-JSON-array-将数组项添加到JSON数组" class="headerlink" title="Adding entries into a JSON array 将数组项添加到JSON数组"></a>Adding entries into a JSON array 将数组项添加到JSON数组</h4><p>您可以使用 add 方法添加数组项到JSON数组中：</p><h4 id="Getting-values-from-a-JSON-array"><a href="#Getting-values-from-a-JSON-array" class="headerlink" title="Getting values from a JSON array"></a>Getting values from a JSON array</h4><p>您可使用 getXXX 方法从JSON 数组中获取值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String val = array.getString(<span class="number">0</span>);</span><br><span class="line">Integer intVal = array.getInteger(<span class="number">1</span>);</span><br><span class="line">Boolean boolVal = array.getBoolean(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="Encoding-a-JSON-array-to-a-String"><a href="#Encoding-a-JSON-array-to-a-String" class="headerlink" title="Encoding a JSON array to a String"></a>Encoding a JSON array to a String</h4><p>您可使用 encode 将一个 JsonArray 编码成字符串格式。</p><h4 id="Creating-arbitrary-JSON"><a href="#Creating-arbitrary-JSON" class="headerlink" title="Creating arbitrary JSON"></a>Creating arbitrary JSON</h4><p>这里一直假设您在使用有效的表示形式<br>如果你不确定，你应该用Json.decodeValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object object = Json.decodeValue(arbitraryJson);</span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> JsonObject) &#123;</span><br><span class="line">  <span class="comment">// That's a valid json object</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> JsonArray) &#123;</span><br><span class="line">  <span class="comment">// That's a valid json array</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">  <span class="comment">// That's valid string</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// etc...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Json-Pointers"><a href="#Json-Pointers" class="headerlink" title="Json Pointers"></a>Json Pointers</h2><p>你可以用pointers来查询或写入。可以用字符串、URI或者人工添加地址来构造JsonPointer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JsonPointer pointer1 = JsonPointer.from(<span class="string">"/hello/world"</span>);</span><br><span class="line"><span class="comment">// Build a pointer manually</span></span><br><span class="line">JsonPointer pointer2 = JsonPointer.create()</span><br><span class="line">  .append(<span class="string">"hello"</span>)</span><br><span class="line">  .append(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>pointer初始化之后，用<code>queryJson</code>来查询JSON值，用<code>writerJson</code>更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object result1 = objectPointer.queryJson(jsonObject);</span><br><span class="line"><span class="comment">// Query a JsonArray</span></span><br><span class="line">Object result2 = arrayPointer.queryJson(jsonArray);</span><br><span class="line"><span class="comment">// Write starting from a JsonObject</span></span><br><span class="line">objectPointer.writeJson(jsonObject, <span class="string">"new element"</span>);</span><br><span class="line"><span class="comment">// Write starting from a JsonObject</span></span><br><span class="line">arrayPointer.writeJson(jsonArray, <span class="string">"new element"</span>);</span><br></pre></td></tr></table></figure><p>提供JsonPointerIterator实现后你可以对任意对象model使用Vert.x Json Pointer</p><h2 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h2><p>在 Vert.x 内部，大部分数据被重新组织成 Buffer 格式。</p><p>一个 Buffer 是可以读取或写入的0个或多个字节序列，并且根据需要可以自动扩容、将任意字节写入 Buffer。您也可以将 Buffer 想象成字节数组（类似于 JDK 中的 ByteBuffer）。</p><h3 id="Creating-buffers"><a href="#Creating-buffers" class="headerlink" title="Creating buffers"></a>Creating buffers</h3><p>可以使用静态方法 Buffer.buffer 来创建 Buffer。</p><p>Buffer 可以从字符串或字节数组初始化，或者直接创建空的 Buffer。</p><p>这儿有一些创建 Buffer 的例子。</p><p>创建一个空的 Buffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = Buffer.buffer();</span><br></pre></td></tr></table></figure><p>从字符串创建一个 Buffer，这个 Buffer 中的字符会以 UTF-8 格式编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = Buffer.buffer(<span class="string">"some string"</span>);</span><br></pre></td></tr></table></figure><p>从字符串创建一个 Buffer，这个字符串可以用指定的编码方式编码，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = Buffer.buffer(<span class="string">"some string"</span>, <span class="string">"UTF-16"</span>);</span><br></pre></td></tr></table></figure><p>从字节数组 byte[] 创建 Buffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Buffer buff = Buffer.buffer(bytes);</span><br></pre></td></tr></table></figure><p>创建一个指定初始大小的 Buffer。若您知道您的 Buffer 会写入一定量的数据，您可以创建 Buffer 并指定它的大小。这使得这个 Buffer 初始化时分配了更多的内存，比数据写入时重新调整大小的效率更高。注意以这种方式创建的 Buffer 是<strong>空的</strong>。它不会创建一个填满了 0 的Buffer。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = Buffer.buffer(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h3 id="Writing-to-a-Buffer"><a href="#Writing-to-a-Buffer" class="headerlink" title="Writing to a Buffer"></a>Writing to a Buffer</h3><h4 id="Appending-to-a-Buffer"><a href="#Appending-to-a-Buffer" class="headerlink" title="Appending to a Buffer"></a>Appending to a Buffer</h4><h4 id="Random-access-buffer-writes"><a href="#Random-access-buffer-writes" class="headerlink" title="Random access buffer writes"></a>Random access buffer writes</h4><h3 id="Reading-from-a-Buffer"><a href="#Reading-from-a-Buffer" class="headerlink" title="Reading from a Buffer"></a>Reading from a Buffer</h3><h3 id="Working-with-unsigned-numbers"><a href="#Working-with-unsigned-numbers" class="headerlink" title="Working with unsigned numbers"></a>Working with unsigned numbers</h3><h3 id="Buffer-length"><a href="#Buffer-length" class="headerlink" title="Buffer length"></a>Buffer length</h3><h3 id="Copying-buffers"><a href="#Copying-buffers" class="headerlink" title="Copying buffers"></a>Copying buffers</h3><h3 id="Slicing-buffers"><a href="#Slicing-buffers" class="headerlink" title="Slicing buffers"></a>Slicing buffers</h3><h3 id="Buffer-re-use"><a href="#Buffer-re-use" class="headerlink" title="Buffer re-use"></a>Buffer re-use</h3><h2 id="Writing-TCP-servers-and-clients"><a href="#Writing-TCP-servers-and-clients" class="headerlink" title="Writing TCP servers and clients"></a>Writing TCP servers and clients</h2><h3 id="Creating-a-TCP-server"><a href="#Creating-a-TCP-server" class="headerlink" title="Creating a TCP server"></a>Creating a TCP server</h3><h3 id="Configuring-a-TCP-server"><a href="#Configuring-a-TCP-server" class="headerlink" title="Configuring a TCP server"></a>Configuring a TCP server</h3><h3 id="Start-the-Server-Listening"><a href="#Start-the-Server-Listening" class="headerlink" title="Start the Server Listening"></a>Start the Server Listening</h3><h3 id="Listening-on-a-random-port"><a href="#Listening-on-a-random-port" class="headerlink" title="Listening on a random port"></a>Listening on a random port</h3><h3 id="Getting-notified-of-incoming-connections"><a href="#Getting-notified-of-incoming-connections" class="headerlink" title="Getting notified of incoming connections"></a>Getting notified of incoming connections</h3><h3 id="Reading-data-from-the-socket"><a href="#Reading-data-from-the-socket" class="headerlink" title="Reading data from the socket"></a>Reading data from the socket</h3><h3 id="Writing-data-to-a-socket"><a href="#Writing-data-to-a-socket" class="headerlink" title="Writing data to a socket"></a>Writing data to a socket</h3><h3 id="Closed-handler"><a href="#Closed-handler" class="headerlink" title="Closed handler"></a>Closed handler</h3><h3 id="Handling-exceptions"><a href="#Handling-exceptions" class="headerlink" title="Handling exceptions"></a>Handling exceptions</h3><h3 id="Event-bus-write-handler"><a href="#Event-bus-write-handler" class="headerlink" title="Event bus write handler"></a>Event bus write handler</h3><h3 id="Local-and-remote-addresses"><a href="#Local-and-remote-addresses" class="headerlink" title="Local and remote addresses"></a>Local and remote addresses</h3><h3 id="Sending-files-or-resources-from-the-classpath"><a href="#Sending-files-or-resources-from-the-classpath" class="headerlink" title="Sending files or resources from the classpath"></a>Sending files or resources from the classpath</h3><h3 id="Streaming-sockets"><a href="#Streaming-sockets" class="headerlink" title="Streaming sockets"></a>Streaming sockets</h3><h3 id="Upgrading-connections-to-SSL-TLS"><a href="#Upgrading-connections-to-SSL-TLS" class="headerlink" title="Upgrading connections to SSL/TLS"></a>Upgrading connections to SSL/TLS</h3><h3 id="Closing-a-TCP-Server"><a href="#Closing-a-TCP-Server" class="headerlink" title="Closing a TCP Server"></a>Closing a TCP Server</h3><h3 id="Automatic-clean-up-in-verticles-1"><a href="#Automatic-clean-up-in-verticles-1" class="headerlink" title="Automatic clean-up in verticles"></a>Automatic clean-up in verticles</h3><h3 id="Scaling-sharing-TCP-servers"><a href="#Scaling-sharing-TCP-servers" class="headerlink" title="Scaling - sharing TCP servers"></a>Scaling - sharing TCP servers</h3><hr><h3 id="Creating-a-TCP-client"><a href="#Creating-a-TCP-client" class="headerlink" title="Creating a TCP client"></a>Creating a TCP client</h3><h3 id="Configuring-a-TCP-client"><a href="#Configuring-a-TCP-client" class="headerlink" title="Configuring a TCP client"></a>Configuring a TCP client</h3><p>Making connections<br>Configuring connection attempts<br>Logging network activity<br>Configuring servers and clients to work with SSL/TLS</p><h4 id="Enabling-SSL-TLS-on-the-server"><a href="#Enabling-SSL-TLS-on-the-server" class="headerlink" title="Enabling SSL/TLS on the server"></a>Enabling SSL/TLS on the server</h4><h4 id="Specifying-key-certificate-for-the-server"><a href="#Specifying-key-certificate-for-the-server" class="headerlink" title="Specifying key/certificate for the server"></a>Specifying key/certificate for the server</h4><h4 id="Specifying-trust-for-the-server"><a href="#Specifying-trust-for-the-server" class="headerlink" title="Specifying trust for the server"></a>Specifying trust for the server</h4><h4 id="Enabling-SSL-TLS-on-the-client"><a href="#Enabling-SSL-TLS-on-the-client" class="headerlink" title="Enabling SSL/TLS on the client"></a>Enabling SSL/TLS on the client</h4><h4 id="Client-trust-configuration"><a href="#Client-trust-configuration" class="headerlink" title="Client trust configuration"></a>Client trust configuration</h4><h4 id="Specifying-key-certificate-for-the-client"><a href="#Specifying-key-certificate-for-the-client" class="headerlink" title="Specifying key/certificate for the client"></a>Specifying key/certificate for the client</h4><h4 id="Self-signed-certificates-for-testing-and-development-purposes"><a href="#Self-signed-certificates-for-testing-and-development-purposes" class="headerlink" title="Self-signed certificates for testing and development purposes"></a>Self-signed certificates for testing and development purposes</h4><h4 id="Revoking-certificate-authorities"><a href="#Revoking-certificate-authorities" class="headerlink" title="Revoking certificate authorities"></a>Revoking certificate authorities</h4><h4 id="Configuring-the-Cipher-suite"><a href="#Configuring-the-Cipher-suite" class="headerlink" title="Configuring the Cipher suite"></a>Configuring the Cipher suite</h4><h4 id="Configuring-TLS-protocol-versions"><a href="#Configuring-TLS-protocol-versions" class="headerlink" title="Configuring TLS protocol versions"></a>Configuring TLS protocol versions</h4><h4 id="SSL-engine"><a href="#SSL-engine" class="headerlink" title="SSL engine"></a>SSL engine</h4><h4 id="Server-Name-Indication-SNI"><a href="#Server-Name-Indication-SNI" class="headerlink" title="Server Name Indication (SNI)"></a>Server Name Indication (SNI)</h4><h4 id="Application-Layer-Protocol-Negotiation-ALPN"><a href="#Application-Layer-Protocol-Negotiation-ALPN" class="headerlink" title="Application-Layer Protocol Negotiation (ALPN)"></a>Application-Layer Protocol Negotiation (ALPN)</h4><h5 id="OpenSSL-ALPN-support"><a href="#OpenSSL-ALPN-support" class="headerlink" title="OpenSSL ALPN support"></a>OpenSSL ALPN support</h5><h5 id="Jetty-ALPN-support"><a href="#Jetty-ALPN-support" class="headerlink" title="Jetty-ALPN support"></a>Jetty-ALPN support</h5><h2 id="Using-a-proxy-for-client-connections"><a href="#Using-a-proxy-for-client-connections" class="headerlink" title="Using a proxy for client connections"></a>Using a proxy for client connections</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我…我把整篇文章搬过来了！&lt;br&gt;复制粘贴…&lt;br&gt;&lt;a href=&quot;https://vertxchina.github.io/vertx-translation-chinese/core/Core.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://vertxchina.github.io/vertx-translation-chinese/core/Core.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://vertx.io/docs/vertx-core/java/#_buffers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://vertx.io/docs/vertx-core/java/#_buffers&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/categories/java/"/>
    
      <category term="frame" scheme="http://oodtoodt.github.io/categories/java/frame/"/>
    
      <category term="vert.x" scheme="http://oodtoodt.github.io/categories/java/frame/vert-x/"/>
    
      <category term="documentation" scheme="http://oodtoodt.github.io/categories/java/frame/vert-x/documentation/"/>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/tags/java/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
  </entry>
  
  <entry>
    <title>log4j2-notes</title>
    <link href="http://oodtoodt.github.io/2020/04/14/java-%E6%8A%80%E6%9C%AF%E6%A0%88/log4j2-notes/log4j2-notes/"/>
    <id>http://oodtoodt.github.io/2020/04/14/java-%E6%8A%80%E6%9C%AF%E6%A0%88/log4j2-notes/log4j2-notes/</id>
    <published>2020-04-14T07:48:47.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://logging.apache.org/log4j/2.x/manual/appenders.html" target="_blank" rel="noopener">http://logging.apache.org/log4j/2.x/manual/appenders.html</a><br><a href="http://www.slf4j.org/manual.html" target="_blank" rel="noopener">http://www.slf4j.org/manual.html</a><br><a href="https://maven.apache.org/pom.html#Properties" target="_blank" rel="noopener">https://maven.apache.org/pom.html#Properties</a></p><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>log4j2有一套寻找配置文件的流程。</p><h3 id="节点分析"><a href="#节点分析" class="headerlink" title="节点分析"></a>节点分析</h3><p>根节点Configuration有两个属性:status和monitorinterval,有两个子节点:Appenders和Loggers</p><ul><li>Appender定义了输出的格式</li><li>这些logger通过name进行区分，来对不同的logger配置不同的输出</li></ul><p>status指定log4j本身的打印日志的级别<br>monitorinterval指定log4j自动重新配置的检测间隔时间</p><h4 id="Appenders"><a href="#Appenders" class="headerlink" title="Appenders"></a>Appenders</h4><p>常见的有三种子节点:Console、RollingFile、File</p><h5 id="console"><a href="#console" class="headerlink" title="console"></a>console</h5><p>用来定义输出到控制台的Appender.<br>name<br>target<br>PatternLayout输出格式，不设置默认为:%m%n.</p><h5 id="flie"><a href="#flie" class="headerlink" title="flie"></a>flie</h5><p>用来定义输出到指定位置的文件的Appender.<br>name<br>fileName<br>PatternLayout</p><h5 id="RollingFile"><a href="#RollingFile" class="headerlink" title="RollingFile"></a>RollingFile</h5><p>用来定义超过指定大小自动删除旧的创建新的的Appender.<br>name<br>fileName<br>PatternLayout<br>filePattern<br>Policies指定滚动日志的策略，就是什么时候进行新建日志文件输出日志.</p><p>TimeBasedTriggeringPolicy:Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1 hour。modulate=true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am.</p><p>SizeBasedTriggeringPolicy:Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小.</p><p>DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。</p><h4 id="Loggers"><a href="#Loggers" class="headerlink" title="Loggers"></a>Loggers</h4><p>常见的有两种:Root和Logger.</p><h5 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h5><p>用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出</p><p>level:日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF.打印往高处打</p><p>AppenderRef：Root的子节点，用来指定该日志输出到哪个Appender.</p><h5 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h5><p>level<br>name<br>AppenderRef</p><h3 id="名称继承"><a href="#名称继承" class="headerlink" title="名称继承"></a>名称继承</h3><p>用<code>.</code>继承，存在向下的继承关系。<br>additivity是 子Logger 是否继承 父Logger 的 输出源（appender）的标志位。具体说，默认情况下子Logger会继承父Logger的appender，也就是说子Logger会在父Logger的appender里输出。若是additivity设为false，则子Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。<br>所以经过一通探究，这里到底在说什么呢？在说到底应该如何调用。一般我们用log都是跟踪类的，所以我们写log4j2的时候就可以跟踪相应的类（package和类名等等）</p><h3 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h3><p>空</p><h2 id="先来简单例子"><a href="#先来简单例子" class="headerlink" title="先来简单例子"></a>先来简单例子</h2><p>其实就是缺省形态</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"OFF"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="复杂例子"><a href="#复杂例子" class="headerlink" title="复杂例子"></a>复杂例子</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出。 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"error"</span> <span class="attr">monitorInterval</span>=<span class="string">”30″</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个输出控制台的配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"trace"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个都知道是输出日志的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"log"</span> <span class="attr">fileName</span>=<span class="string">"log/test.log"</span> <span class="attr">append</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">File</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFile"</span> <span class="attr">fileName</span>=<span class="string">"logs/app.log"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">filePattern</span>=<span class="string">"log/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;yyyy-MM-dd 'at' HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"50MB"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立一个默认的root的logger--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFile"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"OFF"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">appenders</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">JsonLayout</span>/&gt;</span> <span class="comment">&lt;!--使用json格式输出--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Console</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">loggers</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>config - 插件配置。<br>locationInfo - 如果为“true”，则在生成的 JSON 中包含位置信息。<br>properties - 如果为“true”，则在生成的 JSON 中包含线程上下文映射。<br>propertiesAsList - 如果为 true，则将线程上下文映射包括为映射条目对象的列表，其中每个条目具有“key”属性（其值为键）和“value”属性（其值为值）。默认为 false，在这种情况下，线程上下文映射包含为键值对的简单映射。<br>complete - 如果为“true”，则包括 JSON 页眉和页脚，以及记录之间的逗号。<br>compact - 如果为“true”，则不使用行尾和缩进，默认为“false”。<br>eventEol - 如果为“true”，则在每个日志事件后强制执行 EOL（即使compact为“true”），默认为“false”。即使在紧凑模式下，这也允许一行甚至每一行。<br>headerPattern- 标题模式，默认为”[“如果是 null。<br>footerPattern- 标题模式，默认为”]”如果是 null。<br>charset- 要使用的字符集if null，使用“UTF-8”。<br>includeStacktrace - 如果为“true”，则包括生成的 JSON 中任何Throwable的堆栈跟踪，默认为“true”。<br>————————————————<br>版权声明：本文为CSDN博主「caolist」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/caolist/article/details/89330735" target="_blank" rel="noopener">https://blog.csdn.net/caolist/article/details/89330735</a></p></blockquote><h2 id="意犹未尽啊"><a href="#意犹未尽啊" class="headerlink" title="意犹未尽啊"></a>意犹未尽啊</h2><p>那么就把slf4j的也放过来吧</p><p>slf4j = Simple Logging Facade for Java<br>就是做在日志上层的抽象类，底层具体用什么日志工具不用关心，用一个适配层把api转换成具体工具的接口，这样就可以移植了。</p><p><strong>slf4j只是一个日志标准，并不是日志系统的具体实现</strong>。理解这句话非常重要，slf4j只做两件事情：</p><ul><li>提供日志接口</li><li>提供获取具体日志对象的方法</li></ul><p>slf4j的作用：只要所有代码都使用门面对象slf4j，我们就不需要关心其具体实现，最终所有地方使用一种具体实现即可，更换、维护都非常方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>: ketao Date: 14-5-3 Time: 上午1:03 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>: \$Id$ </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogTest<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        logger.info(<span class="string">"纯字符串信息的info级别日志"</span>); </span><br><span class="line">        logger.info(<span class="string">"一个参数:&#123;&#125;的info级别日志"</span>, <span class="string">"agr1"</span>); </span><br><span class="line">        logger.info(<span class="string">"二个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;的info级别日志"</span>, <span class="string">"args1"</span>, <span class="string">"args2"</span>); <span class="comment">// 下面两种方式都可以，一般使用上面一种就可以了 </span></span><br><span class="line">        logger.info(<span class="string">"三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志"</span>, <span class="string">"args1"</span>, <span class="string">"args2"</span>, <span class="string">"args3"</span>); </span><br><span class="line">        logger.info(<span class="string">"三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志"</span>, <span class="keyword">new</span> Object[] &#123; <span class="string">"args1"</span>, <span class="string">"args2"</span>, <span class="string">"args3"</span> &#125;); </span><br><span class="line">        logger.info(<span class="string">"======================异常相关===================================="</span>); <span class="comment">// 测试异常相关日志 </span></span><br><span class="line">        logger.info(<span class="string">"抛出异常,e:"</span>, <span class="keyword">new</span> IOException(<span class="string">"测试抛出IO异常信息"</span>)); </span><br><span class="line">        logger.info(<span class="string">"二个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;的info级别日志"</span>, <span class="string">"args1"</span>, <span class="keyword">new</span> IOException(<span class="string">"测试抛出IO异常信息"</span>)); </span><br><span class="line">        logger.info(<span class="string">"二个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;的info级别日志"</span>, <span class="string">"args1"</span>, <span class="string">"args2"</span>, <span class="keyword">new</span> IOException(<span class="string">"测试抛出IO异常信息"</span>)); <span class="comment">// 下面两种方式都可以，一般使用上面一种就可以了 </span></span><br><span class="line">        logger.info(<span class="string">"三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志"</span>, <span class="string">"args1"</span>, <span class="string">"args2"</span>, <span class="keyword">new</span> IOException(<span class="string">"测试抛出IO异常信息"</span>)); </span><br><span class="line">        logger.info(<span class="string">"三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志"</span>, <span class="string">"args1"</span>, <span class="string">"args2"</span>, <span class="string">"agrs3"</span>, <span class="keyword">new</span> IOException( <span class="string">"测试抛出IO异常信息"</span>)); </span><br><span class="line">        logger.info(<span class="string">"三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志"</span>, </span><br><span class="line">            <span class="keyword">new</span> Object[] &#123; <span class="string">"args1"</span>, <span class="string">"args2"</span>, <span class="string">"args3"</span>, </span><br><span class="line">                <span class="keyword">new</span> IOException(<span class="string">"测试抛出IO异常信息"</span>) </span><br><span class="line">            &#125;</span><br><span class="line">        ); </span><br><span class="line">        logger.info(<span class="string">"三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志"</span>, </span><br><span class="line">            <span class="keyword">new</span> Object[] &#123; </span><br><span class="line">                <span class="string">"args1"</span>, <span class="string">"args2"</span>, </span><br><span class="line">                <span class="keyword">new</span> IOException(<span class="string">"测试抛出IO异常信息"</span>) </span><br><span class="line">            &#125;</span><br><span class="line">        ); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throwable 异常信息单独作为一个参数输入，因此，如果把异常信息作为{}占位符中的字符串，则会调用其对应toString方法，而无法打印异常堆栈信息。</p><p>atTrace(), atDebug(), atInfo(), atWarn() and atError() methods是快速的Logging API</p><h2 id="log4j2的官方文档体系"><a href="#log4j2的官方文档体系" class="headerlink" title="log4j2的官方文档体系"></a>log4j2的官方文档体系</h2><h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><p>最好声明为静态<br>关于name…<br>in the cloud</p><h3 id="Using-Log4j-2-in-Web-Applications"><a href="#Using-Log4j-2-in-Web-Applications" class="headerlink" title="Using Log4j 2 in Web Applications"></a>Using Log4j 2 in Web Applications</h3><p>You must take particular care when using Log4j or any other logging framework within a Java EE web application</p><h3 id="Lookups"><a href="#Lookups" class="headerlink" title="Lookups"></a>Lookups</h3><p>查找系统提供了一种在任意位置向Log4j配置添加值的方法。 </p><h4 id="Context-Map-Lookup"><a href="#Context-Map-Lookup" class="headerlink" title="Context Map Lookup"></a>Context Map Lookup</h4><h4 id="Date-Lookup"><a href="#Date-Lookup" class="headerlink" title="Date Lookup"></a>Date Lookup</h4><p>这就是最常见的SimpleDateFormat的问题了，会查找这东西的，指匹配日期等</p><h4 id="环境查找"><a href="#环境查找" class="headerlink" title="环境查找"></a>环境查找</h4><h4 id="java查找"><a href="#java查找" class="headerlink" title="java查找"></a>java查找</h4><h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><p>还有很多查找。当你看到不认识的XX:<code>${XX:..}</code>，不要犹豫，先来查文档吧。</p><h3 id="Appenders-1"><a href="#Appenders-1" class="headerlink" title="Appenders"></a>Appenders</h3><p>Appender负责将LogEvents传递到其目的地。</p><h3 id="Layouts"><a href="#Layouts" class="headerlink" title="Layouts"></a>Layouts</h3><p>将logEvent格式化来满足日志事件的需求，比如json</p><h3 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h3><p>对日志事件评估，以确定是否或如何发布它们</p><h3 id="Asynchronous-Loggers-for-Low-Latency-Logging"><a href="#Asynchronous-Loggers-for-Low-Latency-Logging" class="headerlink" title="Asynchronous Loggers for Low-Latency Logging"></a>Asynchronous Loggers for Low-Latency Logging</h3><p>低延迟日志记录的异步记录器</p><h3 id="Garbage-free-Steady-State-Logging"><a href="#Garbage-free-Steady-State-Logging" class="headerlink" title="Garbage-free Steady State Logging"></a>Garbage-free Steady State Logging</h3><p>无垃圾稳态记录</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我觉得没什么用，串个大概到时候查吧。<br>主要是太多了，而且很多都是空白的知识领域</p><h2 id="maven-POM-Reference-basics"><a href="#maven-POM-Reference-basics" class="headerlink" title="maven-POM.Reference.basics"></a>maven-POM.Reference.basics</h2><h3 id="Maven-Coordinates"><a href="#Maven-Coordinates" class="headerlink" title="Maven Coordinates"></a>Maven Coordinates</h3><h3 id="Relationships"><a href="#Relationships" class="headerlink" title="Relationships"></a>Relationships</h3><h4 id="dependecies"><a href="#dependecies" class="headerlink" title="dependecies"></a>dependecies</h4><h4 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h4><h4 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h4><h3 id="properites"><a href="#properites" class="headerlink" title="properites"></a>properites</h3><p>属性是了解POM基础知识的最后一个要素。Maven属性是值占位符，如Ant中的属性。它们的值可以通过使用符号${X}在POM中的任何位置访问，其中X是属性。</p><ol><li>env.X：使用“env”来定义变量。将返回shell的环境变量。例如，${env.PATH}包含PATH环境变量。</li></ol><p>注意：虽然环境变量本身在Windows上不区分大小写，但查找属性区分大小写。换句话说，虽然Windows shell为<code>％PATH％</code>和<code>％Path％</code>返回相同的值，但Maven区分<code>${env.PATH}</code>和<code>${env.Path}</code>。对于Maven 2.1.0，为了可靠性，环境变量的名称被归一化为所有大写。</p><ol start="2"><li><p><code>project.x：POM</code>中的点（.）记号路径将包含相应元素的值。例如：可以通过<code>${project.version}</code>访问<code>&lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;</code>。</p></li><li><p><code>settings.x：settings.xml</code>中的点（.）标注路径将包含相应的元素的值。例如：<code>&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/ settings&gt;</code>可通过<code>${settings.offline}</code>访问。</p></li><li><p>Java系统属性：可通过java.lang.System.getProperties()访问的所有属性都可用作POM属性，如${java.home}。</p></li><li><p>x：在POM中的<code>&lt;properties /&gt;</code>元素中设置。<code>&lt;properties&gt;&lt;someVar&gt;value&lt;/someVar&gt;&lt;/properties&gt;</code>的值可以用作<code>${someVar}</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://logging.apache.org/log4j/2.x/manual/appenders.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://logging.apache.org/log4j/2.x/manual/appenders.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.slf4j.org/manual.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.slf4j.org/manual.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://maven.apache.org/pom.html#Properties&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://maven.apache.org/pom.html#Properties&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/categories/java/"/>
    
      <category term="APIs" scheme="http://oodtoodt.github.io/categories/java/APIs/"/>
    
      <category term="log4j2" scheme="http://oodtoodt.github.io/categories/java/APIs/log4j2/"/>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/tags/java/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
  </entry>
  
  <entry>
    <title>MySQL必知必会-notes-1</title>
    <link href="http://oodtoodt.github.io/2020/04/13/java-%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-notes-1/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-notes-1/"/>
    <id>http://oodtoodt.github.io/2020/04/13/java-%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-notes-1/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-notes-1/</id>
    <published>2020-04-13T09:01:36.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>ongoing。</p><a id="more"></a><!-- TOC --><ul><li><a href="#%E4%B8%BB%E9%94%AE">主键</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFsql">什么是SQL</a></li><li><a href="#%E6%B3%A8%E6%84%8F">注意</a><ul><li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a></li><li><a href="#%E5%A4%A7%E5%B0%8F%E5%86%99">大小写</a></li></ul></li><li><a href="#%E6%A3%80%E7%B4%A2">检索</a><ul><li><a href="#%E6%A3%80%E7%B4%A2%E5%88%97">检索列</a></li><li><a href="#%E6%A3%80%E7%B4%A2%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%8C">检索不同的行</a></li><li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li></ul></li><li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li><li><a href="#%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6">过滤条件</a><ul><li><a href="#%E7%BB%84%E5%90%88where">组合where</a><ul><li><a href="#in">IN</a></li><li><a href="#not">Not</a></li></ul></li></ul></li><li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%87%E6%BB%A4">通配符过滤</a><ul><li><a href="#like">like</a><ul><li><a href="#%25">%</a></li><li><a href="#"></a></li></ul></li></ul></li><li><a href="#%E6%AD%A3%E5%88%99%E6%90%9C%E7%B4%A2">正则搜索</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D">基本字符匹配</a></li><li><a href="#or%E5%8C%B9%E9%85%8D">OR匹配</a></li><li><a href="#%E5%8C%B9%E9%85%8D%E5%87%A0%E4%B8%AA%E4%B9%8B%E4%B8%80">匹配几个之一</a></li><li><a href="#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4">匹配范围</a></li><li><a href="#%E7%89%B9%E6%AE%8A%E7%AC%A6">特殊符</a></li><li><a href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB">匹配字符类</a></li><li><a href="#%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B">匹配多个实例</a></li><li><a href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6">定位符</a></li></ul></li><li><a href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5">创建计算字段</a><ul><li><a href="#concatconcatenate">concat(concatenate)</a></li><li><a href="#as">as</a></li><li><a href="#%E6%89%A7%E8%A1%8C%E7%AE%97%E6%9C%AF%E8%AE%A1%E7%AE%97">执行算术计算</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">使用数据处理函数</a></li><li><a href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE">汇总数据</a><ul><li><a href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0">聚集函数</a></li><li><a href="#%E8%81%9A%E9%9B%86%E4%B8%8D%E5%90%8C%E5%80%BC">聚集不同值</a></li></ul></li><li><a href="#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE">分组数据</a></li><li><a href="#%E5%AD%90%E6%9F%A5%E8%AF%A2">子查询</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2">计算的子查询</a></li></ul></li><li><a href="#%E8%81%94%E7%BB%93%E8%A1%A8">联结表</a></li><li><a href="#%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93">高级联结</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%88%AB%E5%90%8D">使用表别名</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E8%81%94%E7%BB%93">使用不同联结</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E8%81%94%E7%BB%93%E5%92%8C%E8%81%94%E7%BB%93%E6%9D%A1%E4%BB%B6">使用联结和联结条件</a></li></ul></li><li><a href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2">组合查询</a><ul><li><a href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2">组合查询</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E7%BB%84%E5%90%88">创建组合</a></li></ul></li><li><a href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2">全文本搜索</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81">为什么需要</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2">使用全文本搜索</a><ul><li><a href="#%E5%90%AF%E5%8A%A8">启动</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95">使用查询扩展</a></li><li><a href="#%E5%B8%83%E5%B0%94%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2">布尔文本搜索</a></li></ul></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5">数据插入</a></li><li><a href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE">更新数据</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">删除数据</a></li><li><a href="#%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E5%88%99">更新删除的原则</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E8%A1%A8">创建表</a><ul><li><a href="#%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F%E5%8C%96">语句格式化</a></li><li><a href="#%E4%BD%BF%E7%94%A8null%E5%80%BC">使用null值</a></li><li><a href="#%E4%B8%BB%E9%94%AE">主键</a></li><li><a href="#%E4%BD%BF%E7%94%A8autoincrement">使用autoincrement</a></li><li><a href="#%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BCdefault">指定默认值default</a></li><li><a href="#%E5%BC%95%E6%93%8E">引擎</a></li><li><a href="#%E6%9B%B4%E6%96%B0%E8%A1%A8">更新表</a></li><li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8">重命名表</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE">使用视图</a><ul><li><a href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8">视图的作用</a></li><li><a href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E8%A7%84%E5%88%99%E5%92%8C%E9%99%90%E5%88%B6">视图的规则和限制</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE">使用视图</a></li><li><a href="#%E5%88%A9%E7%94%A8%E8%A7%86%E5%9B%BE%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%9A%84%E8%81%94%E7%BB%93">利用视图简化复杂的联结</a></li><li><a href="#%E7%94%A8%E8%A7%86%E5%9B%BE%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE">用视图重新格式化检索出的数据</a></li><li><a href="#%E8%A7%86%E5%9B%BE%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5">视图与计算字段</a></li><li><a href="#%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE">更新视图</a></li></ul></li><li><a href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">存储过程</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88">为什么</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">使用存储过程</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0">使用参数</a></li><li><a href="#%E6%99%BA%E8%83%BD%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">智能存储过程</a></li></ul></li><li><a href="#%E6%B8%B8%E6%A0%87">游标</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E4%BD%BF%E7%94%A8">创建、打开、关闭、使用</a></li></ul></li><li><a href="#%E8%A7%A6%E5%8F%91%E5%99%A8">触发器</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86">事务处理</a><ul><li><a href="#rollback">ROLLBACK</a></li><li><a href="#commit">COMMIT</a></li></ul></li><li><a href="#%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96">全球化和本地化</a></li><li><a href="#%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86">安全管理</a></li></ul><!-- /TOC --><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>一列，其值能唯一区分表中每行</p><ul><li>任意两行不具有相同的主键值</li><li>每行必须具有一个主键值<br>主键通常就是一列，也可能是几列<br>  普遍的习惯：<br>  不更新主键列中的值<br>  不重用它<br>  不再主键列使用可能会更改的值</li></ul><h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><p>结构化查询语言（Structured Query Language）<br>注意SQL不一定完全可移植</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>用杠杠的时候给爷tmd加上空格！不加不认识！</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><p>drop主要用于删除结构<br>例如删除数据库：drop database XX，删除表 drop table XX。字段也是结构的一种，也可以使用drop了？对的，但是我们改变了表结构要先alter方法。例如，我们要删除student表上的age字段的信息，可以这样写：alter table student drop age</p></li><li><p>delete主要用于删除数据<br>举个例子，要删除 student表上名字为‘张三’的所有信息：delete from student where name=‘张三’。这种情况下用delete，由此可见delete常用于删除数据。</p></li></ul><h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><p>注意在linux下会有大小写的区分<br>windows下全部不区分大小写</p><p>查询字符串对大小写不敏感</p><p>关键字和函数名不区分大小写<br>存储函数、存储过程、事件的名字不区分大小写，触发器区分<br>数据列和索引的名字不区分</p><p>不能完全保证，仅供参考</p><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><p>help show…show可以帮助你做一些事。</p><h3 id="检索列"><a href="#检索列" class="headerlink" title="检索列"></a>检索列</h3><p>select … from …</p><blockquote><p>SQL语句一般返回原始的、无格式的数据。数据的格式化是一个表示问题，而不是一个检索问题<br>其中，前面的…可以填单个列，可以填多个列(用逗号隔开)，可以填星号(<code>*</code>)通配符匹配所有列</p></blockquote><h3 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT vend_id FROM products</span><br></pre></td></tr></table></figure><p>注意不能部分使用DISTINCT</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>行从0开始<br>建议使用LIMIT 4 OFFSET 3，即LIMIT 3,4，但是更显然：从行3开始取4行</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>order by<br>怎么样有没有想起一些？<br>多个按顺序<br>DESC 降序</p><h2 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h2><p>where可以检索需要的行<br>where prod_price BETWEEN 5 AND 10;<br>where .. is null(注意排除not null的行并不能得到null的行)</p><h3 id="组合where"><a href="#组合where" class="headerlink" title="组合where"></a>组合where</h3><p>AND<br>OR</p><h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h4><p>Where vend_id IN (1002,1003)</p><h4 id="Not"><a href="#Not" class="headerlink" title="Not"></a>Not</h4><p>where vend_id not in (1002,1003)</p><h2 id="通配符过滤"><a href="#通配符过滤" class="headerlink" title="通配符过滤"></a>通配符过滤</h2><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><h4 id=""><a href="#" class="headerlink" title="%"></a>%</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure><p>%表出现任意次数，这里指jet开头的所有串</p><h4 id="-1"><a href="#-1" class="headerlink" title="_"></a>_</h4><p>匹配单个字符</p><h2 id="正则搜索"><a href="#正则搜索" class="headerlink" title="正则搜索"></a>正则搜索</h2><h3 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h3><p>REGEXP 后跟正则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where prod_name REGEXP '.000'</span><br></pre></td></tr></table></figure><p>.表示任意字符</p><blockquote><p>like是严格匹配的，REGEXP是部分匹配的</p></blockquote><p><strong>匹配不区分大小写</strong>,可以使用binary来区分</p><h3 id="OR匹配"><a href="#OR匹配" class="headerlink" title="OR匹配"></a>OR匹配</h3><p><code>|</code>为正则的or符</p><h3 id="匹配几个之一"><a href="#匹配几个之一" class="headerlink" title="匹配几个之一"></a>匹配几个之一</h3><p><code>[123]</code> == <code>[1|2|3]</code></p><h3 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h3><p><code>[1-5]</code></p><h3 id="特殊符"><a href="#特殊符" class="headerlink" title="特殊符"></a>特殊符</h3><p><code>\\-</code>表示查找<code>-</code>，即转义</p><h3 id="匹配字符类"><a href="#匹配字符类" class="headerlink" title="匹配字符类"></a>匹配字符类</h3><p>举个例子：<code>[:alnum:]</code>匹配任意字母和数字。<br>具体请自查。</p><h3 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 0或多个</span><br><span class="line">+ 1或多个</span><br><span class="line">? 0或1个</span><br><span class="line"><span class="comment">-- 下面是给前面做工作的</span></span><br><span class="line">&#123;n&#125; 指定n个匹配</span><br><span class="line">&#123;n,&#125; 下限n个</span><br><span class="line">&#123;n,m&#125; n-m个，不超过255</span><br></pre></td></tr></table></figure><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">^ 文本开始</span><br><span class="line">$ 文本结束</span><br><span class="line">[[:&lt;:]] 词的开始</span><br><span class="line">[[:&gt;:]] 词的结束</span><br><span class="line"><span class="comment">--比如</span></span><br><span class="line">where prod_name regexp '^[0-9\\.]'</span><br></pre></td></tr></table></figure><p>即开头是0-9或者是.的才会被匹配</p><h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><h3 id="concat-concatenate"><a href="#concat-concatenate" class="headerlink" title="concat(concatenate)"></a>concat(concatenate)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name),<span class="string">' ('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">')'</span>)</span><br><span class="line">   -&gt; <span class="keyword">from</span> vendors</span><br><span class="line">   -&gt; <span class="keyword">order</span> <span class="keyword">by</span> vend_name</span><br><span class="line">   -&gt; ;</span><br></pre></td></tr></table></figure><p>可以把多个串连接成一个较长的串<br>RTrim()函数可以去掉值右边的所有空格</p><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>命名一个别名</p><h3 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">---------+----------+------------+</span></span><br><span class="line">| prod_id | quantity | item_price |</span><br><span class="line">+<span class="comment">---------+----------+------------+</span></span><br><span class="line">| ANV01   |       10 |       5.99 |</span><br><span class="line">| ANV02   |        3 |       9.99 |</span><br><span class="line">| TNT2    |        5 |      10.00 |</span><br><span class="line">| FB      |        1 |      10.00 |</span><br><span class="line">+<span class="comment">---------+----------+------------+</span></span><br><span class="line">mysql&gt; select prod_id,</span><br><span class="line">    -&gt; quantity,</span><br><span class="line">    -&gt; item_price,</span><br><span class="line">    -&gt; quantity * item_price AS expanded_price</span><br><span class="line">    -&gt; from orderitems</span><br><span class="line">    -&gt; where order_num = 20005;</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| ANV01   |       10 |       5.99 |          59.90 |</span><br><span class="line">| ANV02   |        3 |       9.99 |          29.97 |</span><br><span class="line">| TNT2    |        5 |      10.00 |          50.00 |</span><br><span class="line">| FB      |        1 |      10.00 |          10.00 |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br></pre></td></tr></table></figure><h2 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h2><p>Upper()<br>RTrim()…等等请查表。这里只讲几个<br>soundex是一个将任何文本串转换为描述其语音表示的字母数字模式的算法<br>日期的、数据的、文本的都有</p><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>AVG(),COUNT(),MAX(),MIN(),SUM()<br>如果<code>count(*)</code>，则不忽略空行<br>MAX(),MIN()要求指定列名</p><h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><ul><li>对所有的行执行计算，指定ALL参数或不给参数（all是默认行为）</li><li>只包含不同的值，指定DISTINCT参数<br>DISTINCT不能用于<code>count(*)</code></li></ul><p>可以有多个聚集函数</p><h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p>group by，可以对行计数，计算和平均数，获得最大最小值而不用检索所有数据——<br>【不用检索所有数据，这里是比较关键的点，就是说你需要的只是在几列里面检索几行，不需要其他的那些东西<br>Having可以过滤分组，用法和where一模一样<br>Group by和order by经常完成相同的工作，但他们是非常不同的,记得在group by后面跟order by</p><p>这时候可以回顾一下select的顺序了：<br>select  必要<br>from  表中必要<br>where 非<br>group by 非<br>having 非<br>order by 非<br>limit(要检索的行数) 非</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>即嵌套</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">select</span> cust_id </span><br><span class="line"> <span class="keyword">from</span> orders </span><br><span class="line"> <span class="keyword">where</span> order_num <span class="keyword">in</span> (<span class="keyword">select</span> order_num </span><br><span class="line">                     <span class="keyword">from</span> orderitems </span><br><span class="line">                     <span class="keyword">where</span> prod_id = <span class="string">'TNT2'</span>);</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| cust_id |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|   10001 |</span><br><span class="line">|   10004 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>由于性能的限制，不能嵌套太多的子查询</p><h3 id="计算的子查询"><a href="#计算的子查询" class="headerlink" title="计算的子查询"></a>计算的子查询</h3><p>指的是子查询中有</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in (<span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">from</span> ...</span><br><span class="line"><span class="keyword">where</span> orders.cust_id = coustomers.cust_id)</span><br></pre></td></tr></table></figure><h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><p>联结（join）<br>创建联结只需要规定表和他们之间如何关联即可<br>【你可以把两个表直接想象成笛卡尔积，从这里面使用过滤<br>可以用where作为过滤，比如where a = b<br>内部联结——INNER JOIN</p><p>但是需要注意的是，一般而言子查询效率不如联结的效率，因为子查询的默认是笛卡尔积，而联结只是表遍历+表遍历</p><h2 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">from</span> customers <span class="keyword">as</span> c,orders <span class="keyword">as</span> o, orderitems <span class="keyword">as</span> oi</span><br><span class="line"><span class="keyword">where</span> c.cust_id = o.cust_id</span><br><span class="line"><span class="keyword">and</span> oi.order_num = o.order_num</span><br><span class="line"><span class="keyword">and</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure><h3 id="使用不同联结"><a href="#使用不同联结" class="headerlink" title="使用不同联结"></a>使用不同联结</h3><ul><li>自联结<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self as p1,self as p2</span><br><span class="line">where p1.X = p2.X</span><br></pre></td></tr></table></figure></li><li>自然联结<br>自然联结排除多次出现，使每个列只返回一次。<br>然而这序言自己做，你只选择那些唯一的列(对某一张表通配符)，然后对其他表的列使用明确的子集。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.*,o.order_num</span><br><span class="line"><span class="keyword">from</span> customers <span class="keyword">as</span> c,orders <span class="keyword">as</span> o</span><br><span class="line"><span class="keyword">where</span> c.cust_id = o.cust_id;</span><br></pre></td></tr></table></figure></li><li>外部联结<br>需要包含没有关联行的那些行<br>比如<blockquote><p>你需要对客户下了多少订单进行计数，包括那些至今尚未下单的客户<br>列出所有产品和订购数量，包括没人订购的</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_id,orders.order_num</span><br><span class="line"><span class="keyword">from</span> customers <span class="keyword">inner</span> <span class="keyword">join</span> orders</span><br><span class="line"><span class="keyword">on</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h3><ul><li>一般使用内部联结，外部联结也是有效的</li><li>保证正确联结条件</li><li>总是提供联结条件（不然会退化为笛卡尔积）</li><li>一个联结中可以包含多个表，甚至对每个联结可以采用不同的联结类型</li></ul><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><h3 id="组合查询-1"><a href="#组合查询-1" class="headerlink" title="组合查询"></a>组合查询</h3><p>执行多个select语句，并将结果作为单个结果返回</p><ul><li>在单个查询中从不同的表返回类似结构的数据</li><li>对单个表执行多个查询，按单个查询返回数据</li></ul><h3 id="创建组合"><a href="#创建组合" class="headerlink" title="创建组合"></a>创建组合</h3><p>可用union来组合数条查询<br>只需在不同的select之间使用union即可<br>union中必须包含相同的列、表达式或聚集函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure><p>可以使用union all来匹配所有行，不取消重复的行</p><h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><p>并发所有的引擎都支持全文本搜索，比如MyISAM支持而InnoDB不支持</p><h3 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h3><p>有了like和正则，为什么还需要全文本搜索？</p><ul><li>性能</li><li>明确控制，两者很难明确地控制匹配什么和不匹配什么——比如第一个词必须匹配，第二个词必须不匹配，第三个词必须在第一个词确实匹配的情况下才匹配或不匹配</li><li>智能化 两者都无法提供智能化选择结果的方法——比如不能区分包含单个匹配的行和包含多个匹配的行。</li></ul><p>全文本搜索会创建指定列中各词的一个索引，搜索针对这些词进行。</p><h3 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>一般在创建表时启用，create table接受fulltext子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">    note_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">    prod_id <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    ...</span><br><span class="line">    primary <span class="keyword">key</span>(note_id),</span><br><span class="line">    fulltext(note_text)</span><br><span class="line">)<span class="keyword">engine</span> = myisam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> note_next</span><br><span class="line"><span class="keyword">from</span> productnotes</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">match</span>(note_text) against(<span class="string">'rabbit'</span>);</span><br></pre></td></tr></table></figure><p>比起like的区别是全文本搜索可以按等级排序，比如这里会把rabbit做第三个词的行排在做第20个词的前面。<br>等级由行词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来</p><h4 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h4><p>with QUERY expansion<br>会返回一些和你的搜索有关的所有其他行<br>比如你的搜索match against(‘anvils’)只有一行结果，但是扩展之后就会有很多：第一行包含了anvils;包含了第一行的几个词的行也会被检索出来，依照位置等信息等级排序</p><h4 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h4><ul><li>要匹配的词</li><li>要排斥的词</li><li>排列提示(指定某些词等级更高)</li><li>表达式分组</li><li>另外一些内容<br>即便没有fulltext也可以使用</li></ul><h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><p>插入一行<br>插入一行的一部分<br>插入多行<br>插入某些查询结果</p><blockquote><p>可针对每个表，利用mysql的安全机制禁止insert</p></blockquote><blockquote><p>insert一般不会有输出</p></blockquote><p>一般可以直接插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">Table</span></span><br><span class="line"><span class="keyword">values</span>(</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但很不安全,安全的话应当先对每一个值指定一个列名，即使表的顺序结构改变仍可以正常工作。</p><p>处理请求和按什么次序处理时mysql的任务。insert可能很耗时（尤其是需要更新许多索引时）<br>如果数据检索是最重要的，那么你可以降低insert的优先级，<code>insert low_priority into</code></p><p>可以使用多条insert，也可以一次提交它们(列名相同)</p><p>可以把value(..)替换成<code>select ... from ... where ...</code></p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>update，可以用于更新特定行，或是所有航。</p><blockquote><p>一定更要注意细心，稍不注意就会更新所有行，不要省略where</p></blockquote><blockquote><p>可以限制和控制update的使用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers</span><br><span class="line"><span class="keyword">set</span> cust_email = <span class="string">'elmer@fudd.com'</span></span><br><span class="line"><span class="keyword">where</span> cust_id = <span class="number">10005</span></span><br></pre></td></tr></table></figure><p>update中可以使用子查询<br>更新多行如果出错，整个更新将被取消</p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>delete注意事项同更新<br>甚至使用起来更容易<br>无需set，直接delete from … where …，不需指定列或通配符——删除整行而不删除列，为删除列，请使用update</p><h2 id="更新删除的原则"><a href="#更新删除的原则" class="headerlink" title="更新删除的原则"></a>更新删除的原则</h2><ul><li>除非确实打算更新/删除<strong>每</strong>一行，不然决不要使用不带where的update或delete</li><li>保证每个表都有主键，尽可能像where子句那样使用它(可以指定各主键，多个值)</li><li>在对update或delete语句使用where子句前，应该先用select进行测试，保证他过滤的是正确的记录</li><li>使用强制实施引用完整性的数据库，不允许删除具有和其他表相关联的数据的行</li></ul><blockquote><p>引用完整性通过在表的定义中指定主键和外键来实现的，后面会讲</p></blockquote><p><strong>MySQL没有撤销按钮！</strong></p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><h3 id="语句格式化"><a href="#语句格式化" class="headerlink" title="语句格式化"></a>语句格式化</h3><ul><li>mysql语句中忽略空格</li><li>语句可以在一个长行中输入，也可以分成多行</li><li>使用恰当的缩进（sql中没有缩进的规定）</li></ul><h3 id="使用null值"><a href="#使用null值" class="headerlink" title="使用null值"></a>使用null值</h3><p>即not null/ null</p><blockquote><p>不要把null值和空串混淆</p></blockquote><h3 id="主键-1"><a href="#主键-1" class="headerlink" title="主键"></a>主键</h3><p>主键值必须唯一。如果使用多个列，那么这些列的组合值必须唯一</p><h3 id="使用auto-increment"><a href="#使用auto-increment" class="headerlink" title="使用auto_increment"></a>使用auto_increment</h3><p>告诉mysql，本列每当增加一行时自动增量<br>每个表只允许一个auto_increment列，必须被索引<br>确定值可以使用 <code>select last_insert_id()</code>函数获得</p><h3 id="指定默认值default"><a href="#指定默认值default" class="headerlink" title="指定默认值default"></a>指定默认值default</h3><p>不允许使用函数作为默认值，只支持常量</p><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>可以混用，但外键不能跨引擎<br>具体情况需要具体分析</p><h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><p>alter table可以更新表的定义<br><strong>但是理想状态下当表中存储数据以后，该表就不应该再被更新</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> vendors</span><br><span class="line"><span class="keyword">add</span> vend_phone <span class="built_in">char</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> vendors</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> vend_phone;</span><br></pre></td></tr></table></figure><p>alter table一种常见用途是定义外键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atler tabl eorders</span><br><span class="line">add constraint fk_orders_customers foreign key(cust)id</span><br><span class="line">references customers(cust_id)</span><br></pre></td></tr></table></figure><blockquote><p>使用alter table要极为小心，应当事先备份。</p></blockquote><p>复杂的表结构更改一般需要手动删除过程，涉及以下步骤：</p><ul><li>新的列布局创建新表</li><li>使用insert select语句</li><li>检验包含所需数据的旧表</li><li>重命名旧表</li><li>用旧表原来的名字重命名新表</li><li>根据需要，重建触发器、存储过程、索引、外键</li></ul><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>rename table … to</p><h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><p>视图是虚拟的表，只包含使用时动态检索数据的查询</p><h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><ul><li>重用sql语句</li><li>简化复杂的sql操作，在编写查询后，可以方便地重用它而不必知道它的基本查询细节</li><li>使用表的组成部分而不是整个表</li><li>保护数据——可以授予特定部分的访问权限</li><li>更改数据格式和表示——视图可以返回与底层表的表示和格式不同的数据</li></ul><blockquote><p>如果你用多个联结和购率创建了复杂的视图或嵌套了视图，可能会发现性能下降的很厉害。</p></blockquote><h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><ul><li>唯一命名</li><li>可以创建的视图的数目没有限制</li><li>创建视图必须有足够的访问权限</li><li>视图可以嵌套，可以用从其他视图中检索数据的查询来构造一个视图</li><li>order by可以用在视图中。select的order by可以覆盖它。</li><li>视图不能索引，也不能有关联的触发器或默认值</li><li>视图可以和表一起用，比如联结表和视图</li></ul><h3 id="使用视图-1"><a href="#使用视图-1" class="headerlink" title="使用视图"></a>使用视图</h3><ul><li>用create view来创建</li><li>使用show create view viewname来查看创建视图的语句</li><li>用drop view viewname删除视图</li><li>更新视图时，可以先drop再create，也可以直接<code>create or replace view</code></li></ul><h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> productcustomers <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> cust_name, cust_contact, prod_id</span><br><span class="line"><span class="keyword">from</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">where</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">and</span> orderitems.order_num = orders.order_num;</span><br></pre></td></tr></table></figure><p>创建一个名为productcustomers的视图，联结三个表，以返回已订购了任意产品的所有客户的列表<br>为检索订购了产品TNT2的客户，可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">from</span> productcustomers</span><br><span class="line"><span class="keyword">where</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure><p>由此可以大大简化sql语句的使用<br><em>创建可重用的视图</em> 创建不受特定数据限制的视图是一种好方法，例如上面的视图返回生成所有商品的客户而不仅仅是TNT2的客户。</p><h3 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h3><p>简单的例子就是如果经常需要某个结果，不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可<br>同样适用于某些需要每次都要where的语句（比如not null)</p><p>注如果视图里用了一条where，而视图原来自带一条where，它们将自动组合</p><h3 id="视图与计算字段"><a href="#视图与计算字段" class="headerlink" title="视图与计算字段"></a>视图与计算字段</h3><p>视图对于简化计算字段的使用特别有用</p><p>比如你需要<code>select 一大堆 xx*yy as ... from ... where...</code>来计算（比如每种物品的总价格）<br>就可以转换为一个视图<code>create view ... as select ... xx*yy as ... from ..;</code><br>之后需要检索订单20005的各项物品总价格只需要<code>select * from VIEWNAME where order_num = 20005;</code></p><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图的数据能否更新？答案是情况而定<br>通常，它是可更新的。如果更新一个视图，你将更新到基表上<br>如果MySQL不能正确地确定被更新的基数据，则不允许更新(包括插入和删除)。这意味着如果视图有下列操作则无法更新：</p><ul><li>分组(group by 和 having)</li><li>联结</li><li>子查询</li><li>并</li><li>聚集函数（min(),count(),sum()）</li><li>distinct</li><li>导出(计算)列</li></ul><blockquote><p>这个限制很可能会在未来(现在)的版本中渐渐放开。</p></blockquote><p>一般应当将视图用于检索（select语句）而不用于更新</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><ul><li>通过把处理封装在容易使用的单元中，简化复杂的操作</li><li>保证了数据的完整性，使用同一存储过程则使用的代码都是相同的</li><li>简化对变动的管理——延伸出安全性</li><li>提高性能。存储过程可以使用只能用在单个请求中的mysql元素和特性来编写更灵活更强的代码。<br>总的说，简单、安全、高性能。<br>缺陷也是有的：</li><li>比基本sql复杂，需要更高的技能和经验</li><li>你可能没有创建存储过程的安全访问权限</li></ul><h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> productpricing(@pricelow,</span><br><span class="line">                    @pricehigh,</span><br><span class="line">                    @priceaverage);</span><br></pre></td></tr></table></figure><p>调用。怎么样，有趣吧。</p><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> XX()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> .. <span class="keyword">as</span> ..</span><br><span class="line">    <span class="keyword">from</span> ..;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>删除就<code>drop procedure XX;</code></p><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> productpricing(</span><br><span class="line">    <span class="keyword">out</span> pl <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">out</span> ph <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">out</span> pa <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">min</span>(prod_price)</span><br><span class="line">    <span class="keyword">into</span> pl</span><br><span class="line">    <span class="keyword">from</span> products;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(prod_price)</span><br><span class="line">    <span class="keyword">into</span> ph</span><br><span class="line">    <span class="keyword">from</span> products;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">avg</span>(prod_price)</span><br><span class="line">    <span class="keyword">into</span> pa</span><br><span class="line">    <span class="keyword">from</span> products;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>接受3个参数：pl,ph,pa，out指出是传出给调用者，in传递给存储过程</p><p>不能通过一个参数返回多个行和列</p><p>调用完了call之后就可以</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @pricehigh, @pricelow, @priceaverage;</span><br></pre></td></tr></table></figure><h3 id="智能存储过程"><a href="#智能存储过程" class="headerlink" title="智能存储过程"></a>智能存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="comment">-- //使用$$作为存储过程的分隔符</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> ordertotal(</span><br><span class="line">    <span class="keyword">in</span> onumber <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">in</span> taxable <span class="built_in">boolean</span>,</span><br><span class="line">    <span class="keyword">out</span> ototal <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)<span class="keyword">comment</span> <span class="string">'Obtain order total,optionally adding tax'</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">declare</span> total <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">-- declare variable for total</span></span><br><span class="line">    <span class="keyword">declare</span> taxrate <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">6</span>;  <span class="comment">-- 声明存储过程中的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">sum</span>(item_price*quantity) </span><br><span class="line">    <span class="keyword">from</span> orderitems</span><br><span class="line">    <span class="keyword">where</span> order_num=onumber </span><br><span class="line">    <span class="keyword">into</span> total;</span><br><span class="line"></span><br><span class="line">    if taxable then</span><br><span class="line">        <span class="keyword">select</span> total+(total/<span class="number">100</span>*taxrate) <span class="keyword">into</span> total;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">    <span class="comment">-- and finally save to out variable</span></span><br><span class="line">    <span class="keyword">select</span> total <span class="keyword">into</span> ototal;</span><br><span class="line"><span class="keyword">end</span>;$$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">call</span> ordertotal(<span class="number">20005</span>,<span class="number">1</span>,@total);</span><br><span class="line"><span class="comment">-- 显示结果</span></span><br><span class="line"><span class="keyword">select</span> @total;</span><br><span class="line"><span class="comment">-- 删除存储过程</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> ordertotal;</span><br></pre></td></tr></table></figure><p>这里我抄的网上的代码，他这个分隔符看的我心惊胆战的(被我改了)</p><p>comment会在show procedure status的结果中显示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> ordertotal;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'ordertotal'</span>;</span><br></pre></td></tr></table></figure><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或更改。<br>mysql游标只能用于存储过程(和函数)。</p><ul><li>使用前必须定义它</li><li>声明后必须<em>打开</em>以供使用</li><li>对填有数据的游标，根需取行</li><li>结束使用必须关闭</li></ul><h3 id="创建、打开、关闭、使用"><a href="#创建、打开、关闭、使用" class="headerlink" title="创建、打开、关闭、使用"></a>创建、打开、关闭、使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">delimiter <span class="comment">#</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">procedure</span> processorders()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Declare local variables</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="built_in">BOOLEAN</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> t <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Declare the cursor</span></span><br><span class="line">    <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Declare continue handler</span></span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'02000'</span> <span class="keyword">SET</span> done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Create a table to store the results</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ordertotals</span><br><span class="line">        (order_num <span class="built_in">INT</span>, total <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Open the cursor</span></span><br><span class="line">    OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Loop through all rows</span></span><br><span class="line">    REPEAT</span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- Get order number</span></span><br><span class="line">        FETCH ordernumbers INTO o;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- Get the total for this order</span></span><br><span class="line">        <span class="comment">-- 就是上一章的函数</span></span><br><span class="line">        <span class="keyword">CALL</span> ordertotal(o,<span class="number">1</span>,t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- Insert order and total into ordertotals</span></span><br><span class="line">        <span class="keyword">Insert</span> <span class="keyword">into</span> ordertotals(order_num, total)</span><br><span class="line">        <span class="keyword">VALUES</span>(o,t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- End of loop</span></span><br><span class="line">    UNTIL done <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Close the cursor</span></span><br><span class="line">    CLOSE ordernumbers;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">END</span>;<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>此存储过程不返回数据，但它能够创建和填充另一个表。用CALL执行了另一个存储过程来计算并用Insert存储下来。<br>坑：拼写，<code>--</code>后面跟空格，错误会显示出来，就在里面之中。</p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>如果你想要某条语句在事件发生时自动执行，就需要触发器</p><ul><li>唯一的触发器名</li><li>触发器关联的表</li><li>触发器相应的活动（delete、insert、update）</li><li>触发器何时执行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.order_num <span class="keyword">into</span> @ee;</span><br></pre></td></tr></table></figure><p><strong>不推荐使用</strong></p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><ol><li>在MySQL 中只有使用了Innodb数据库引擎的数据库或表才支持事务</li><li>事务处理可以用来维护数据库的完整性，保证成批的SQL 语句要么全部执行，要么全部不执行</li><li>事务用来管理 insert,update,delete 语句</li></ol><h3 id="ROLLBACK"><a href="#ROLLBACK" class="headerlink" title="ROLLBACK"></a>ROLLBACK</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customers;<span class="comment"># 先检索一下当前表中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下三行选中一块执行</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;<span class="comment">#开始执行一个事务</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers;<span class="comment">#删除表中数据，需要注意的是，如果要删除表中的数据，这个表和其他表不要有关联关系，否则报错，这里删除customers表就报错，换成一个单独的表，可以正常执行</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customers;<span class="comment">#检查一下表中的数据是否被删除，正常是被清空的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>;回退到<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>之前的情形</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customers;<span class="comment">#再次检查发现表中又有数据了</span></span><br></pre></td></tr></table></figure><h3 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT"></a>COMMIT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从系统完全删除订单20010，因为涉及到删除两个数据表中的内容，所以使用事务块处理来保证订单不被部分删除，</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;<span class="comment">#最后commit语句只在不出错的情况下提交更改，事务块中的任何一个语句错误，都不会做出更改</span></span><br></pre></td></tr></table></figure><p>使用ROLLBACK和COMMIT就可以写入或撤销整个事务处理，但是只能对简单的事务处理才能这么做，更复杂的事务处理可能需要部分提交或回退。</p><p>savepoint 是在数据库事务处理中实现“子事务”（subtransaction），也称为嵌套事务的方法。事务可以回滚到 savepoint 而不影响 savepoint 创建前的变化, 不需要放弃整个事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> point1;    // 声明一个<span class="keyword">savepoint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> point1;  // 回滚到point1</span><br></pre></td></tr></table></figure><h2 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h2><ul><li>字符集为字母和符号的集合<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="built_in">character</span> <span class="keyword">set</span>;<span class="comment">-- 字符集</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">collation</span>;<span class="comment">-- 校对</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'collation%'</span>;</span><br><span class="line"><span class="comment">-- 分割线</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mytable</span><br><span class="line">(...)defalut <span class="built_in">character</span> <span class="keyword">set</span> hebrew</span><br><span class="line"><span class="keyword">collate</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure>编码为某个字符集成员的内部表示<br>校对为规定字符如何比较的指令</li></ul><h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">creater user ben identified by 'p@$$wOrd';</span><br></pre></td></tr></table></figure><p>设置权限使用GRANT语句，其反操作为REVOKE。<br>可以做关于未来的授权</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ongoing。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DB" scheme="http://oodtoodt.github.io/categories/DB/"/>
    
      <category term="mysql" scheme="http://oodtoodt.github.io/categories/DB/mysql/"/>
    
      <category term="book_notes" scheme="http://oodtoodt.github.io/categories/DB/mysql/book-notes/"/>
    
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="DB" scheme="http://oodtoodt.github.io/tags/DB/"/>
    
      <category term="mysql" scheme="http://oodtoodt.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>chronicle-其五-company</title>
    <link href="http://oodtoodt.github.io/2020/04/13/%E6%97%A5%E8%AE%B0/chronicle-%E5%85%B6%E4%BA%94-company/chronicle-%E5%85%B6%E4%BA%94-company/"/>
    <id>http://oodtoodt.github.io/2020/04/13/%E6%97%A5%E8%AE%B0/chronicle-%E5%85%B6%E4%BA%94-company/chronicle-%E5%85%B6%E4%BA%94-company/</id>
    <published>2020-04-13T06:37:18.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">我是何人？</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="91539ed9cad0e149ba2a633a9c204e0833c3ca65faff8ee726e6fb1b103089ca">712090add7ef6eb6967f2a974481eb15c456245f5c598d6e0515f507a9982c5da31175840ed3ca3a18430fd16871c3f0cd814b583da8d27442998886b498259b97cf384a950f30fd64ad1e31457e320ce434497f6e76d9a2a4ac047283f8bb38c36575e6577155fd10f11f17f91c115a3f4516d748f722366195a09ae2a4d321bb794a0c4aafd5c42ed4e9d348801be638802891ac27e35977e1b78489ed84f205c1ba8b8c125d8b5699f5b1c2aa6a23bf27af4c926b5661a0104f292b585942a89f4fab899f4e41af38e1d14b64767e13537c1c89ba75dbde02af62aa324bedb42e4a583ab9863f0cc4730a6dff76c3199a4da3bbeb6152a6da897721c9740f3f8cd36ad17cc2ec972f5b34b47ebcce51cd8a61072eba1ccc7b8754937c32c2209b3a13679962d63f00485e305f1545fe93d161404e7dd4822d6d84df68b689c7a0af89ecfff984c52aec3456ad16c42ed7e67c3ba2f5fb7632db2c9521a425e68185926a58b23d982a724d1846d298610538ad14a3d35f0e4aaa646b4e93c2cb2d7a7598f707c948ec867751c27ad6b2a44047bfb31c13f2a5ef1021a780b5e5927854c64b0e593c989d8155d26184b5fdd783aebfac2faf799cd7870750db3b9c01fe28402cfa03b909de1726e08119ebc776b92f0313ad83e626137c3f4276e1f46318bda7cb27c1c8261a26192f8835afb9b9c5a50a308aa69736c98807e689f1d39d6ba86879d1ba07e95e10015b94cf2258b3a3228b21fb320d46061b49069d0659a77362f648f59b2e8a72edd43bff083767326482ca505bf327b45f2fdca4ec37504728db71fe18bb4f535e911041b0835bbe7f0bbd797455a40cd086d121e2d07e9498a88463e250f671bf236f3e18dd81579bdd184cd4a0d3aad10d1125b09a1b36cc0d118f5bf704e5f82a7bbdd55bdc76ad4df8f50c19f4d072cbf2d5b61390ddbb26049bf1613d405af6b24643f15fa3dfb23900598a3616c07dd126bd860f2948b2b60f106748c65f6bd3d07e9fdbbd35ed2f55dbf60af50e1e14a24bbf9a6da7b3b3969534c1bd8fadc0d97520fb9866f3bf63a8900c750fb1e0a5f0b29ec5bf6bfa13586eed83c1a5668561d42757b656cd0080c032c3d0e2a9a6209e21d066c78e845b75fae6d81029329a2cab05ce0a1f2cc56bffa9d29f82e2d0db4f0d9e50010a6804985003e57019642d26239b3d53db1674dbc95e0c3a48b1bccf90daedb3e3f8891e6cbe015b6706b97870c0f710e7f46b0c91946c6c9d75d60fdca68e6f58c5946de6cba198f39b604b386187cc98173b3aa49440ccb7ce3ae893f6efb6207af292a581a4e5c5fc87598656adf40a753689ab6ce7edbd4f0080ab41f74ba57264020d01f053c563e229d8fb839b5714b067c4d3997e64b86220e7c71e792897eb651717d590870d78ac8754e3f618d16c29e2c79f43d8bb1b421d3ac8c578b278fa81f941bfda7a431f9e7f30bd4c789e61fac78b1b5173826c3a1e5a507ba692098b37d91c8c4998597c7b36ac05097b1bf15213b7fcc7bf2901ef813f9a70395246e2af48260164bb50a95ab919a2a34ea06cff95026cc06c437e886faa28338cd4d722d07e1c5b616bfa173d10974ad20c0a8abbe3e62a47e161b9245e7ab017193ce903cf2803ab62646d82b4964e85bbc2e7ae884b31befd87b42530ee5386ed0b6ca3b5942722743bf4effa19204c28e09561098654561be338fbde986b0b98f10eda4b63b3e28c0e442052e431993dac49147e3478a05a9298ade0caeb1c128e20159c91d0416bbaf863d2c2688da987466f2fa71cd96f2f447aa480a92c3959e94aa50eee392feb2753605b68765709ea231eacf0bd795e23b9901f1a3239b944aa5c4447cf1e3551d781555f4e20d99676c3e81a9812e025962bad2a96d6e103143bffde96ed0a9b992da01fe2716a5a20cfe32a77b148a0b42571e6f734a44228ef60b3c264b25f721dd96e4d47dcb0655f7dec3e526a264d172572a63618e45b965b63b8b0b59ba3c22fbc2e30efbc71263e38a02e5364c823443d8e6a7599bbe359a30045e16d33f73bd3bb359eb3434c322c092f118aa43ae4ed993c5cfd8532fac7986274c3e397bbe45c42b9636c3da8835c4c2534ee92806c21a23a72582f03591c48d5ea46b688280127ddb4d02a818a7e26c0cc461540f3fdbd801f9dd98a2dff45dae0c6a857f7b7c8629f595264b7a208c302c4a8aa50f017ace2f2b583535ec2c9127bf6aca5bdf1a341cce59fae9fe5eb35d330f36cf4bf0f307164cc8f549368d722e8a39f3dd5c3d317c615f430843de963cea4a23e6ce8822e7fb3d9b91b4b10185ea3d12cb157994db7e6ab7709e47d04563235bfc0a48db7eb4cc45ac0f2f593f62d529890a18b7e53808d2bbb1703f0267bfd20dabf0e89f2fe1d602534fdc4e5f37611f63f3b51c1d609b3ca33a851bf6301a106d1e578b4b45b93ea33c81aea0175aa97084e7ab56e487edc8ec7b25889d4708c59814bdb942b47cf9f5ca457d8567c4ee0900c21b25764035de3c50989d28ece9bba77054848f133a8a3a5845aac2ff8e4a1d6d645770fd89df087e16bb12ce1d9ba456e0a86a00a0bb0bc00a1ebb57ef06797615ed7a98e9b640f0bd76d69df8e84e7afcedd037e5f88377b5a8b4f8dba4d103339ba2486880115793ada04ce90ab886f58e60d760e8d97eec5ec8152219466ba153fefffdcb1486571cafa98dfe5094fcb8f32097208a549de8e11a5e31b90a814f2f7eca7c9b69c832a90514d7e1993269ed49cbdc88ef8a18e633ab49d892df8a8a2991325e631b41f6601a67bd1016902163b21c238565080754077c1633ca27db98a723c0d6a817dd9dc44e5d7f54c38393c2030af62b0b524670f526b373041e549a72d56a1a661e671378289c25d2d86f00aa8f2d87eac9c4f5a12a9cb73c5a03bfa149dfb213284026994179031298c10f0c333791683287c3cd21c8e5c885d2307a37ae59f3d13cd0c8e0af80f44520d18faab6b9dec817e593ae9e4c933d6f4dbec9c698b8a6718aa53cf2bcef4dfe4569a06e9921af539b1c18d15969f18c17cf2c07b7d11dcebc4d4316b1a78961abdf861eb9d936cd247f9c0b7a034873f7ee8899ce21b77dfd3fee6b040e6c3d11f212940f6e7f0b98509b1ab4c1faba216f97a2118e2b66c89f250bfdeed338734aa72a23e217880617a7f5dfe58a25d75f6518cba45992ebc5dbe43728e74eb18c0f7c2a54eb3d10cc78f46f902ec173ea677376274c282c621f7cbd52e4ef333d1d77b0576a75d2ba335b999cbf6845931da9e281335945d960d894d4fbbeecaf9ffe4cd848ec58ca64d870b4c311927c26e7f7b250944c811632ef8da7b753c0f7b67708665444717d1a641dd26f3bb1e9f4e07d10cc16a926f6febe1c7b5be84080f3073964045fe5da04bcba97f86a481e005e67a12a2bb0f378b34b2bf636fd9b58f400e8b9aa11bf91998c873e94a96983283a80a8839edd164134ff280503268f8046a3ad03c51187e6aabc8deaf99ae4ade75694da1a88c57fb4159bb1fa721350db0c229ee0c773b80ebeba967ed1d4a4ddd2a27b69f8e06e7682c190b682cdccdf54e15a82c26a4300dfd08a67dc6e63ada94e81381f4b303863c5f7cf28711d9a9e43bfdebd21a8c32ef08d77e01e025b542f1e2272c3d9ba6a674ef0b5ae827d0981d4fddd473f56453f4a273f381979280156c7d2307b761f2b7fe096082abc3f7d1687d018a255ac64bcd7e5b4e725f955d69b9c76c9ed568a8f0bea8f30768dd93aaa74bfa8815f0d45ed54e053ee66e3225df81c79c35dc7479959fae9f8e754156c801deccba8603c779b2b52e98d74abaf93f13494325113d2fbbe7b047cafe5cc4bee19c3113de0943bb6e075c293b280b944747903f0a706f65eca7796d6af5b3fdb5473e348d6266ad4cfb1feae9048cc07d731edf6cea898c42246a6d7915a8059e38231ef907a44ca283fbc97ea927d1612e8fbdb3bea60e1f833928f585d4dfe9a86a31b4e12ca2ea2b8af9670c8f4650c6a3e117619fbdb81d5d0694a073146719cd680b2aa1f7fc675b369c03285171ab3eed6b7de28d24584e4ca420a5500bd86653505990979026387be16c36ac35b7eac385644242fc811d147dd41af692fa2da702ae47cdc8bf645b2efbc5f45e6a30b67b5be2975d1a74e0f04788214d3817e5dff3adabd3fdab1479b5ff77dc6dc70343728d0c633200c71ab6169b7de9e0b53a911f3df2af0f5876ef08fb9931d87b0ef8e30e0097666a278af1e2df1d1de1ac0df78e19df2cb3d3e7217740ec0dfd9252074c586707dfd4a03e0825ec5d802413a21d0d06f87ca7d17cf7152bdb6704b1857551e8d29a2090d5e9b2add1eb6080381bc5afc367301e4ad2055361f3d2510a6ceea9070edb1ad93d14e2dadbd5dead80bed37c93f3054b7ad7c6655f3fa63c81ef46a5b703df2ca116fb302cf893dbc5e4c4bad199256048750c99e6ed2809fa35c7647bb74196e733bf4abb6067106cfad5cb3b214da0246f543196324896ff8fc4019bdeb89571709b8874ae2ab4209288ea84d2035ea229fbb2755c2f11fa38bbafe1eff66fd0d6a3c22aec1e51a9f72399995cdc87713197986d7b8334d3bd7e7aefd2fcf7423ddf79cc7806cf6a19a2c73f19166094bdedec47e050078177032860fb351f78c5ff78a063f52c0b02644bd3ac5caea4a3283ab9513c75858354cde030280c193d2ab15087027f84cdd03b22fb30e8cdef033e71c1deae8cd1c9f89c03b403cfc62d4de008aff3ddad9cd0a7cc3e9334b4d229dec08a2240e914c85063813cd63bbf3c2652a297b2d3cc6942c954e42f78d60ffac5aabf1f9a8d2f4fc5881f577e9aefb659a2f1be1582de03fd9076b18dd810220be08a56280c62a220770e687c115548abce7e0d8e6a871fcdc6bf151ef7e1cdaa800672e8a478c3e43f2c9bff1870da6d7cc5d5fc51601ccdf4151613ed0f79d057d307eb9a64ad2d7a70b4f0b84a160b29e5f62ebc309e5b713ea01c926a7e0785fbbe1878e05081de4566ce8b3419115adb662aa066998cfb615c4b4c01ee3cdf2a84b59185a56b5d1047ebe48da17f074ecd8b06dfcfee90a881d21d6dbf7f7fc8e014e4552d4323585056decd20bbbd0f8d8b8fdbc08c47cefa422771108d254607ba65a12b67e3a1a1db83b29386aab63d1dce1619826e67a2b794df5c34192ffc900d320c350f8fd04f5d888e17acbcec2c9944a2dc1ba133805f6cbba4ec6cf6731faa473e8edd78f76d0e8fe951adfe0e2012601cbe57555451867e284b741c4a89fc6e8380f019d47dae61429c3cbd23418f25b7ec02cab67d9923c20057bd3130302b5d94c85105f7673158bba836aa96eecf14282a8c2a89b7e6a09d0e3d5099d25b5affa7de612d606c0ba0dd6e125ce9beef6d5bfb94ab84290110b61155834f17a1c1e44a4f0c22f378dad41482a12a61653b6bc974e430f30b29d5751b58ea4057e4977285df8cfd986dd6cd153c2633963a9fd1cfbe4d0036a2a7b0d70a6050d764689a8dbc0fa2ccdd37edd81efd26d90fecd9fe5b2dc25d5aba9b161266cd8a0c5fe223f20a1abdbdde806f0204b3b989d73ec3e9fdc42629430af85ae2509c7eadcda3a57c4086d0f58bc31cf208537fff24ffa78cebbac026645faaa93072d5ca424bb934da91121d7ca343766e48f58ec2ec2896b9c5d4a96bbc2ec3161f9a86faf28dfbbb79847278d7cde3067e353566853b4b21ae9f34ec949e998a33bc0c0fae7bef9029e88ee4c0cafbe5b4fc66d22804cee78a122b1f40fa6f92566b90dd90d474068822f7f4d4ef2f8c6eb6a2df98130bdddcf0d361437b47e20859a5c43b83ddb81aef6358d905359ba0a684297ec98e2a236113c252a66657977099d97617818aec466705c2feb6650dc4628e40ec928e5a23da65f19f7faff574c1a632f5ac33aad4820729ca501d61813c4568ff1461845300069502f04e39a60123d7941d711027bdbc7e7bb6a5c21d94bcc8c62ed6a647ce8255c6c4a0461faaacaa8a280fb5340e2ccf9ec09f99025b6ce5840061dc327324e358319dde9990d8c3e57d396125035436c3c7ddfbf35a5ac11213dc045b19817216955e09b5aed37d8684be500e6dc5a7c023d14f3aa7783ddd6e3aab977ffd9677cbaeb8703d79a1caff68d692c899ff461f65967c62894fac1a9e9d17dcfd132badcc832a5285e3f4add92ae207382d3e876c3b54e5ee3421e8a2f9cb4690822afa580b9986a812d8d72a5e3abef1a3aea4cec8e2ef1b7cb24d0cce6f9247eb02c98d3b8ec24e1320eae7146f207fa739188a7c4cfe3b34c4b191d9a5cf2fc07d1b6f6de7983e720441bcef22f1e318329da66b124d6d664e81a69f838a942ddb22c316c8114d93f0d1c357edd8a959af45042fa9548bf86bac6040f2f0ae78893d15c6aafd7c631508d62b1dd0add79647608a302402b2108cbc196e0c7d475b543e5d0d92b945886e6b906ee5895d5d9d33a86716382b7e3b245b704f45feca69299fc4d2dc4179894a1cd08deb25c8ce08d77ef76206282701890ce1775eb137cec79935f61ed8649ede51171e58951e4d397de6550787e90d10401d5fb014c9560b4956e4c20141b26a73d4030859d3da7bb89a10ff74d019ad6705af1a24a99155ee11ea52a4d714a45ca59c719a236dd464e0e034efdb266edd5e8209f295a5eabede5421d7f8ed7c7bae9f6381672d2eae7cd0288e9f70861aaa6bc8c2d93efee9836f1f0a9ad8b51b289b4b3a8ec7764ed63d9eb4365d7e30e7bda85067b392d1b80b58c2cdeb6043aa7fe62c990e6b709f4408e828dd9a46942f8909881043c8e1fe8e6c196c109725eac8a14f8d948122504bbdb6f3a9db8b0cfa447918c7700d6d726f6c9cb11f18ec52b61517bf78a49307860f33fdb416b155c4d2da98868bae4d25f5b0e0d4d2ebe09dcd3ebe1f6e21bc54a592acc0dee85ffe7447a63d6d0159a2ae8cc2a57784164c2be5adeed7f90c03e67880963e425d21431810ce6b09c21ac6c0e2fd8667d7e82773bd5e7f15fbae9a86add1ab097465570dda3d67efc4504f4b1da5fb5f4b7a58d2a84ca5d4b3be2e409df78f235069295a3f9c8d6bdf725612ca783341cb274ebf104a908977553c739a9e429f3b9e21965f20d09d2c004c4115ade28d7308ce8ad0be9962fd61ae1d4ed2f126c6050f7c8f1c04003f178d6b5406d69291f207f9f3cd276fd436869cc60a3dc65e91fd4999d1b3e9baf4ac890751db870345b9a5e6f9d435f5de77b17c2bc1dfa6ffa9bf6725ff21d790914ebd065854b86eb345267c633535ca0bdac20b9f8ce9c01d0d93736704bbb9112edf2e731670f68dc1941d80e758423118f50562bebdcdcfe77373f3dca1f1ad78a2a3e5be6aecdafe8a99565d93c307d63c00d81ef57f247d133782a2f76bb1e5f178189cc88f2a10a3fa25c34d787d1882256255df33062e7a6473ad05858fe6df4864b61ff5e5b1faaa163f636fc884034b70e3d97a572968b269f2f58eb93215956e109afcabbaa3d757bcbf898aed2d29d51e3a4ed79ad3d979f70583d2601fa48d1e2fe65760de1e698bb4ac389d8f251631063b54e7e36f73b0d36e56de391e136cb574ed087467609ad320f10e422290569196a29eda9f081d242e865daac9f49e1ab4c24b066331889a2b8eba9d73897245ffb42886e4768f6cfcf6b01ff5d11f4f81b62834cbf77cb2fc1b59126031d733269c50a2ef1104e16ebd4dcb53ab2881e1361ba2ac3ba3b24fddf9d8122cc3138d2e136c3a405fac4740b747b06e7c86dc45691b5be363fda2f88c7d44f20c010e40c7e9df9a0eaeeb35837a8b6417fb85fcdc32187cbf97adaefccdfda2eacf126fc21714f114822612879ecc61c6e5ca6229ea2bb92b4f6019793ae54dbfdd8a9be7a306b2c0bbe65971058446903a597d5797ec358abd1d9c7f9e471152872e65011e32eba5777e0a7c17e42be41e76cb2906a397461b9a164acbcbcd6fdaccc76a68eac19a593c16d491b7b690fd02d8960a4058176f6ea4480c942f195dfd7cb0ac7387ffbcd75373089981826101b1a828174e81efe7fe6dc284765911f3ab81e50e9c50c3919d11247dc29a2183cc0e95d5fb21fc1b93c70044a139c19a7526b368dbfa62ce59bacadd8df29599366c6b0074b0f513a00a5ecfd07ba339d71507fa43a70c54394716f23085b4f05af3961ef28e1400d565171f42f0eaac9e65cbec624b3ebcceab01c3062d9a3b476a35924f950752989f05be0eb8b6e8864ba30fe9dcfad88e9ecaf609c3a039e9c476f9d2bd13bb008ba4c5c8d1ce94ca18e009f3edb8ca87f4f81c7d6248ea594bfe89a3a8ad6f64b2147d8532d957db3daf14290f3af2da9bd0ecc95adac99cb0ce056fac4b2ba10ab2a93e4b3431941d29c4b435da1bc6218a984dd9206c4e0b1d1fa207bf90ab7eb174659d00da540d789b9c935c90a682fc0c85321fe8e64f9e85ada76df3929aa4e5ee6670b95163b924b6dfb00582e6322ce53e3be958f486e914d0f4943f52c7f35476ae166bb3a052e96d8843f7b72b62bf4b4896ca1e30c2f158759d65a99c46892fd5802a141fff361be88a84c0c35a5681b9a1a206d23dfc741d929f3c4fd079560691eb9587cde44bc9850e45cac126cb1a0dd0d7e9fa166b833723bb034aef9565393a5924e254f553ec421c0dfcb0107684e1304cb759913dbd11d3753d8680c5b1c9d4be9291ba4a225adf0d1728ebc51e95f574f120b74e8149de7fd9e2a530b60fd8ad156bf8874807cd06ab3401a4918d88de63668097bf962901e94737b8ec59d923bf8bdd91c234484ac7d23be92b9ebd860adb6c25f5ef85a9aaa501a9df741963fdfed7dfdc87eef74e2d576a0631cea4a41d6a38ba29bf6821773ee5eded5cffac52d8645f8e8e66d34d78f3413236ee387bcdff94599ece51f6446eb51f2a663181c88565c0e5d7e84f503acd01d48e884e5bcf77f089352e6a57d90293e3b09007b04a2446b51050dcfc59d99e4f9d5f59f46a5e5e526817be79a13ebd39c510d54b47eb43b63feb0e821bc8c67291d500fe69da5e72912943e9f0bbe35e16da2fa33c1b67ddd0999af5b09751d994c6ed4c71c9b5003f18a12e74f3616114ff3bca4bc32d9ceaf6407a3250ec81e8d8e79247f4c532624998cc87d265903aa7b62dd6ee3fa77de6887dc5a297410b944f6c6584f130860b5bea9f496bc19c0f3d4c6a70d80a6a5ce1c1e56dffe11064316daf9328dab32c50431c03939a7de49353d02f3d32cf8c8e2be0bb538f9e118f43d8ba6e1c86cf2b2b0fed4b7233d89bc6804f5337fed7f38d03058e67e686de0098643705c6733b9d5a8ab9fa3e29f0375cecc6bc6a13fc62a9d0ab2b2bf7dd8238950f5af1c276a034d2454e4c4d13053608c8c74f8a071a8432c3094f5156d1a94c57748e612a37671e8b576deab0de96b1cc6ad8849ba6cd10e7a4a38266f7e999227dc150aaf10f47d552288f51a58f9bcc454dc8ef4e274c5f5c884b85a61ec53686cb80ef4971a1ffa82de0e12689b86e42630e00e4df28d252221f1f3f63367ce5c8de4bb7112b5005df417af97ead8c55b7ea6f5583ae56adfe96b82b4e3bca5adf385a995e9d5d425302d54cce3e274a3036644953426c74067f40a9072f3ded0c5e2dc329d2ee3443987f87f95510f627b9918644df3348444c0b3bfd64e94a90e3cabd3e6e902a1d20b53be4cf7c10bfd102058f01913574486a1705fa6335cf4c8a42618d3d67e0fb3afceb81b982b7e12481ed1cd2d858ec2c6c652ace1f37a443c17f735bb474d61a96a969406c567061c45783ab55c7f448d17f9279452aaedcb8fa7ba3577710bc383424101ebc78d7d98b138687cee6946ed44e3d911dc1e1f467dc5a58fc8461cad14044e966a3ca7bcd8784f49f2fe2273fa05aa9cdd0be2e5d1aeb95c0be8100b2188a0513bd810087f19da88cee563ca0eb42c77943163924b12a71fce4c40f0801e6f7dde2abf023bcc956fde4bc9761effea81bd0949f7041447c3fda29fe692c20e1d7f1a09eb2ebe938bda7bfecf92bbdf03b7cd78564e820585f8c7f6ed6a7be2e166c8f3cc7a2c75985471a3d13b44d642cc60f2d7075a22f877fe650d2a0e168cb97a8edeba4f3ec0c01b1086459678fa4bf33ce298d50a7a9ef56d784c1ca784a708469b35865cbb2357d7e8c45efe5a38530e5bf48388a1be80ff9f93f5f57c4113b6d0d51cc7193ea1c82be44e9b5554581f615819570fe0af8b452416bc290ae889e7c3dc9ccdd5d42f778fc28692ef8170eaf0a29ebae8d5d78a67360e3491bc53c08e84782dc3996a73575d23ec3423188ceb49d735a124d7b9b35c354c02a6b85568db215962b17bb41fc4ede7b066f707dd3e0e056de749c5e806994b22a63c63abcf7ea9d8221d0b119a8fe6280bd430ce3df16d3637d3d8780d2bec63f9a76023a1523585436fb8128587fd611f0e9bf44d472a67e05759b330056a696118c0081cbb4ea84ecf5d8cdba04e3fbd3b9f57878ee47b37352bb5fcf1d2e8dd934a128a297c1a967df84e91e98e3abaa5329047b4a6673fa391df603e517b258ea47125da879285b9daa10950982895d88a3eb1d12000f2f7e2daae82c032685d781e9fefe6fc0aecd19bc49774555c435f4e74e9c7a0adb5854f9bb115ba7297eb7586f2c4c5483842d81c2530a46584b378ba638f4ea2c3d602bc840d304e265790e0b59c183e68d4349dc2d33c6c0fb321122eb532c8a409595f5603ed9469cf16a0ad36363cc71a4526aa9eff4f257d5c6b99a8851b44b175ebef26cafe310f49a540fa7a33a5bfa24bb2726b07c0760fa480de5e76a8fa77978ed98db6bf9b3c4271256e745c2ba3ac64f536e82bc6d7f279752130c96df2c70cd1c5c2245d83983d22414814c7a6fbdba74850d77bb0f923dae72b12db5544ef71573e586df2f745282c9a79b626c109aec5972ef2776c10f960a48cc6610169064ebb250b59e2cfe43b3e7e5ce4a0a513cc97f135b722437d9d41f0a3c7ae6771c9944b6ccc6bcf165606fc7330cbd5aa0979c666e383ebaf57b9085d08ff2021bb996cd49ef0121d1e7669953c20dfc45166c5c42c000799461c86698e74c990ecd321ecfea488f9b7c9ea63b282b01013720749516100b292a55b8881135f8a8f4ac013704418e7e1af14eb7c9717e5b9f36bacceaa754573e4fb0d926955ff7b9096eb5ab87984a98731975855d560c3cd90de05ed60a3c5ed49c354a66b6fe3a89c48cd3d3454fdbc84736c582957d2245963699e5e7205d8e66df69e11db0fdea5452f8bf195a0f3f249787c175623a80baad5b4b23f416cc97f525fb7b0e3b1514d53a2a2d0ffb0675c14f0686df53cc4519bd8fae67ba4e71a70083dc2707b5fda8a0b4eaca1166931dd583dbb620541ce86f8acef15cfb4ee94f8c774e304bfbf4d731f01c8f7825a539c19fc8956c386dfb88a7a56ce998f42221bf17f40bf30cf90a7365e5ec9a86a3d8cb67ae5fd8e4e0a2d79cdf6a721fb6adc83e9ec79791705299496b41f32d669d548b8b70841f2a47395739c1afa2773c926f52d209250c8ea38ee212f6f657623b3e4333feb614c458a30635246cd7c936f82fecbec8af34892471d937a446315762c23fd4870f0357821d92d24efbf303a1956e9f0bd0e998797b19272ec6c16e151caeca4fa1eda53cd2dd6f100e7fdaae269f051ed2584267b3dad4862e2abd9615991e1f93d72cddd94ec2dd9c90d2c2e0ec5c804549c5efab8f1be9c3193fdbf1edb16188193854c2048b49ebfa4a7af1df3f6dced89112a5cff4d536e0c55e96c5d42d48b2c5a52094dfbe0327534bc0c9135fdff357b81317ebbf2b3b15ae6eef260d361a232b9e722a6f434b7b4d8185cd6739ae79e3f451b9fa94f21a6eecb9868ab0307bd798ccdc0d4108c26a10347a198db3ab154435e83253e3100ca411a2e01e260aac327d73f391ac172038494dc21a440a4769a74bca99c74678db9faab1b35d098a3e8cdd7b32ff840905d650165bd5ad7629b7dab925433fb8f98870ea9ddf60417b754750bf5f7e79a45b4e50f52434b5274352935d0aa7a26e5cd73f8c31199f5bdd9fba714e5a14ef235126ce7ef0b6ee3f2f607d0e51ed64d8692adb0292e1bb0e24a781d63cd9eaa9af595559f116f111790b91cbfbd20f0ee51b667112f4a3048252f9897d8bd3bda0a3c07e313531b27504ad7367a5764be07b86b7b586347f4fce4ccd6c6c9204ecf790503dd7151bd6a230e7bc7454278ffd1fc020633b01e25c8d6e854cf3bbd187c420d8ee5265c4f481de4e2ab64d9e8293a961d2c65baf3c75372e826496cc9d457ae7900ea2bb5d61ec2f9be982bd6e34147df9f39546e90e6e5ec588feeac6bbf276330185236968500da1c9d515b6b82495009763be7ae775a79f25d90b15c83b6388eb8295f3017e8594a1d8b5061f59e6c1e838ce4760caae47c6ba957511b7c862d3310565be2ceade3699fd3bed9c0f742194fe971dbc9e81e5b6ffd8a6e6861221e02f3b2163fb9b15e4091598c75e6cab3c53e1c5b30cffe8e06362324321ca4b9fcef1c5f128bd7f7f2e99286a51d8c45148f1da8b8aec3d2121c048704e409df2fb4acd66bcd39a8a965a0ffaded8f29d364f17921c606b435b9856f32b84924a38d4f985255de65c0163b147e5c8f1cf3e8ea364287728823282baed78084babec4a81ce1f6c8601dd217fd3b989f9ee5907fdbcdde4e4ea3e0b3c869de2273031155649aaa485f7901e711bf76e4a31427d2d13544a9c848b5fe028ab807229ca3b522ccb0c4479825a9edfcf2b9a3cbe9d0e15a71194e9f2352a094423d8c65b135bce0d106226beffe0355fd2fd6aa5f5c736ab67064bedc2a66ad61820230f007f45f55621d46d1c02533aeacb148554328bc9c73d63c43884ab9d993bc1771e568b5d4c8c0a0a59eebde5e6a1d564d00f7e97a25f49d125aa497c980e85aa2667726c1526d111639517c8cfb43baf76687c139a25759ec40b2cb9edc0c49c9fe89f868897b0d96dace3582f9cc0cf65640d70c8f2f3e3fc9dbbafb08a6788038d019f5e17988f411985371b8b13c80f68c72f431fe19963300e6710dcf36b0a5e7f81354dc7fab6f9d2bfaee81491777b019e4bb0dcef357ee9dbd828971effd356ab12b324913ab2436713d7ae17637f0c3402da3a266e0c77d20dd92cce75ef19912b7d64048db1d73bf4a48837f4fefec6c0c75c16dcf939d94da83c3baff410ee517af0f5a86945d575898ffd29ccd76aef1e27f01a928bfe460b263be91dbb5d139d65c6c3235be53a80806a19df47811dc4f21d5ea4791a173f7bb68ca2c0779f755f53f420a1592624d59374acb5234741174034ebb4e8ce80594a0f1995742b91b5a21a1caab6cdce1f0f3ebfad8828c314a6da6cd60dd17cf462de2c92e9387ed68fb25576527f0a060e24c6b4559c29aae580422399c8e1a98359ffd84fd88fb3b96cc540f1a337eba7c0cf9c2e9585817a8beec6ef65f7091e18eeb25b27339afb1f7e42e655995ab444e080cf65202ced4e1367efe8903f8da8aee7f4f95014e487d470a52bac0e4aee63414ebb35a955d277b1970339bd89de17a592ad3068c6c417468e120b50b55f14e33f0d2422046030125750f0b9db58ca79a7941b275ed8fa442afb9638a6b09004c21e11cbd104616b01ff638e275fd8a650e257c42dfdccbef84eb6fea54a01bd9a670a46939cbe17ead533aa60effc88d361f2a0630fc4aaa39be7a90c42bc6823378f6a3de1e897a94acd1c4a9cb0336ea994a5c483d0bb9c43a337d10b61837d67ea0dfa1d366a53e94b73c220fd83d5c8e34a2f8e3e1242cb3ecaf4e6d257ef46d7230f705702a889e6f8fbd604f867b7a1e9998d3e6d65847f2142129a7c6c64d20fe03234a75a08c84ed303571edd0e8ae5cecb101f308ef81f39063c72ed990bca7171a58ad0875372671020356d52db43460c9e0f801e38e1ce14d94a8b7f155dd037bdcd5ba4c3cfd2592ed0bf1bb2bb61855541e72126ac93a2996a1ed834a1026ed0de4759a3cc2b5028096b9b17443c2c655cd99fe0998b94455f7625d64ee941b577330f0add63d7d64d2a5ec0e392f6a30ef2dc21b767d2847ecc325b886ae3f6589dfa5462a53d0d3bcf66d148e664509b4a66d782a04e07d205e715797855563e11415ff5b43254c32594d123c6076363fdc98d96f9cd148cf117bfbd52b3178ae7c9c986c5c2fab840621a7398a8f720c992fae0c82514ea4d1e00c2352fe483c49e3ea65184379fe6419c68e94a673963e5fdede7fcd538b02f00dd9e3b0fb3b60b7df164190a39f42d7933d7136ae6d7364a5d6abd858bfdaed6ae7cd82d9c0f44c451fd1a97341d5e5c98fa6d7daaabc2e2de7134f41ab64f3ca5e85860ac10a44f8ad1a4924a595000de8e0367a284a27083a2a66752e93a57a3898a34bfc61d35824ba0de84b2acb4c148ae436f461a2cfbf09c32cf0dcfc15f91157cd5ae43520b2e0fe3a312b18e98694d28794059792f0fba85767e887657e8fed7b415c8d3864cf55832d6d4b7b7f6a81ce73056b56348869b4109a53cee5979e5d0e244c0fa54d1c955adae39f89107ee1a63748d19afd09d1a1afd08fc2c531e10b9dfe72d287913022a1c132c393dd7a1297b5de0338003ba64bf7be8c2ca67f858ef0c8e7aaed000f2352ae3a21110e1876443ce49592161f232e85492307b29610a87725c1146396817919dd7ec4840526506a9f28ed298dc8ecc060f9c068ebcb8192fdd5a651ce3c45c99786910b7ac54cdad33cf4302c552e7443c103342ef9eab2db1850426caaf11c741b517323ea3c9db4ebbc3a94f1de9a4b1aaa4e24b66619285f3079de35730eafa8125ce07db8bc947df864ca2a8f607ddc40da8169de0403205ab195ee69765e4a5a2801b1cd95a7e0cc626b706199a3f98a47a3410e21bf631e17ac4841da9ea330605f9ea46ac5d7b0130fe49be4feb18d28aa9d3fc6668b6fa72bc37d2f2202c3cb72880359f1b925f0715a4d5322d5a1cb2191d469199534d5e883d6026c0f81b24cdafc897f433605794ede17872620d3196810e95703162e3e48c3d5457071250690932831f744493120be1d0663dba49809244a744cacc70371939694d1e86460adfac093a0aa7da26bad1d5afee4add3f27b166afa8c8e05511deaae1ede08a506b61d30f2478d0f6758587ae0a1e7711b13ac9665cc4663c99c642b981100a9fb294894def150c42b2b7512ac4d734223b454319fdb56ab65647cfb4d09bd562cd19e1d1da164be50b56afa7eeab771e3ca148235436a8285968826549d13456b3f3586ccfdbb2ea6bf47ec0b638e16d2f6a26a458994a0a3186479a41789f7593cb96e4a6426d0b28171b53015a1f9e43ba4abf220f43d32d4dd2c50a29cb9ddedf755e886d4bad2983d4a791820627c093a17efe9f0151be524d86f87c818bbe7b8f6b1af44d6a8654276343230d7e2662745a7762eb2c775d2554c0c5625317f84c0993d30a51cd446b99b4e962040086659ef2fc21ce3eaed8a90520ef595b536b2eaf1a7bebb40b5dd2dfb7d2b2308ec1b8a1778a50d25e10ce0710192399fbad08362ee62bbd6782f24b2c39f93a940825a3d5e76de66f0a61abaa6d998738035b503161628808e1cd43514dce60d416752c82f1d058a4ebf53b01303add5029eaba2b5861984823fd4606627d48701fa8099e7e8caa0311d8522adb4aa1b4521fb792b0dbe5c449f479e76759a944aef9a70392a87a3a48cd5208da4ec07a8e3d63a55e505f735565b953131e419838b725a6c6a30ad25c4454b53756516894819eba9f6ea832aca2db26cb47c2dc74da258c7188876cb7870cb424834bb30a7dee0cb516aa1f49505f9203017f3c5908a75d61db774c0ff9074ba8f29ffa282234d4be2820513eb5301dfe87c53c13963cb751a0813ebfd399a0bc0a61da365fea42e289da8a795224987d8404912b2ed6e86a5d620280672104a20ac45bed1a43450548dc3f08e3e8629b56e585c1a647fea7a0d2996869b472316619ce625938612fb0eeb185d373178bbf41aab078c1126ce83f8e99df687d0b5636abb58dfa5775094ed5e78a27cd083fa5ff779461806a636a0c5b0526257408759d500a30ac37bfe6912067935cb81fdbb2eacf4cc1003b2eb96fca52121f0ff6ee0a40ed3ea99884d9e13d5ea3a0b6d46b7817e4298b3055576e74a1e5877d98e5eb7498c4b5f7aee7f94e1345bcffa52da8c41c1ca9e04d006b616f3c6ce85fd6933cd88708c24b8f41db4f98d8ed2eaf60ac29f7885e86d98d5c1252775cdc3f6acacb4a8b8f224ff008f597e2c7a9d115aac8b803c95d9d5e09b1e39e236a829e8f2a5fd2412961a3f6c3ea2b5ebd9b5a76de75164c57e6ff626e7d1259756206fdf7dc4fbfd794d5c4c216a6ed4ed020120740d64bb64508526a238367364b2aa9df44f5d1eb9deb5c84b4dbeaeed0d2d4b2bfe96a66092086f02f4698991ae75d9a8349d4f5498312f06599db3238bb5efba764e6a5458e5cf2f9e79699cce8cb470a81532791f5e23a9ea0b165ecbcb6c0522b01595dbdcf5c6d8ffb08c1ff53cd00af6fc47dffa3f99d995505a108d8516b7ad1a3217f80373cb6ebd1bc8b961f8a897d3fb3931bafece7c3f6679f380a6908cbb885bca8b262807cac47f3de06dbd49460062bef6f3a86dc0b652b09212104e4b21d2d817f38ab7727dba7bc6514acbe58cde534659ef803d44892a0721919b34b2f2012fee2d5f23803eaae569db16fba1689653b9df9a36612242f761ab99830594ba0da6557917ef3286b93598a76155a42d324821e4e7364664ea3d0be19f96e78f81a0023f88dc5cf902595ba5e8f4db195d6fa17877accbb56172b46ebd3c62f8bce70e45d241261067ef2ebda6ca7a1067ed7c0f42f3dce2c9020cb3738892a01ee3f9e2ed32a4e18975735e447111e0d1c8fbdbf19e1abd3ce34a1dc570be05be5a5be56ae98e39f9a82af35fa4d9d55f2e2cac65bf42ac173cdfbab695f7b0ef7979d339597c7ab4bd685a7d4063ad92fb6cce5156aaf67b62f708c6ac096abe3f7aac8f7db11f2d1d7d450f41f8388418d7430432b86433bb21e3bd56220e13e0b0430ab802b6b0a8565d0d1ff8f544c4edff037258dbc19d01c5daec95d12f39b5e86fbac66318ccd360ac29e444fa1d5be7cd1751cf74f9c2c915ff453dc6aaa3c33a35b6c12d45cb53a0fc2a02a6fa01133aaf4a0dd30db6f6caf7e6bcf1e1e9a0f1b7d412c62f53c66e333d69769d01407916b77404b30c112fffca7cd8a8d4fb79b4203995a89e6668f9c6ec479d7ecea11b24273044f70022b43501db6ac69708c761c6c988d7bc0d42399b7464d8cc5d8831a794ed9261b2d915d4126274a60053e4274c2e3a6def31cae032d1e21fb246e703332acb88af1ed86f8c2b25db9fd95574670b41aea18bba020a437c2b667402b6eed5597e432191c0e1c03b36c6cd40a8d09396fc2f14cac5f10e6412d2f3c92d64acfdb859272809460c911765fd05058526c70a217e2c24ff65d98b6c241c8b600704090f373a7e8a28dc5a39a06ba55996e4f1c724ffa18088731cca5542944d300712caf8945f1ea4f463c1771981b7aa3774d39a36b9b41276b2ca91bcd8ee66c709860bd37c0a122c2ca5f88d367221b0c28bb39c9488ea19aed2bdbf946ee3b8818a74e113f4278821c0ca8b762485fd9b3c4722811e4b3c6565dd2701c48870eaa9e53a9ac0f6d51ef6b0912a04da62813a4db0a05c2cb6ea95397362eac0d98770c07b5bc19ce7fadbbaff621d9fca1738025b5a7f2f77c5e3b2cc0c93e84caec60819423d54264b9e22d5b5c2d6114bec00d6f8af5326593e1dc66903a5e6a2175f34c356f93a354f8d4299be7c2558a63c48ad5f32b1841cfcab22310ff189a167ed015a4c6bf072ac817a33d9ca7bd775b3ffdcb499d6d02309e4b6bfdeab167b48385f325c7c292c7ce24301b210416c762662cb7ead0c4323854b47377a098d618709babb32496c738967ef188f2793dd8bccf0353994f30a4e977c33ffedfda1ac2085fe3014111dbf52543e12fbd625d60736477984d17a6dd4a13eaf3f9866dee2004ff29cd2cc173f6f50deeba1d8156c6abc7843f0880f78e3d71ab67a3c3cbdb3d83f63e6ff26995cfb0d2f82f04614c1017a22c1b37d9253d2812ec8947273933a16e756d7b155c27001e003734f6edda3fd3901bbc43c0e9f0b95dabe56cf621e48835f60232ed03a35ce0383839e9400c47ba2f8197262996dacb2e2040baa4942c6eae7c41ffd789565b514705e7b0c9c977175eec940f9308f7a73b782ca96826786c52076d78d9f7ab383271fccc79dc626c0872d9d44e7a9791a91a7b575f173e80e3518909ad43f2be1d87ef84467ff0ce6805c5742c86b8c0f59db69fe9279140c733269398d244957ffd851ff3337a47423728477f500f23dee22c1ec3b1a47f4abc1114d854e294c32a58f0dbed14a6dfb2da10f23db91deaa0463c85097f89f35e66df9462ed81f8d21544e04e315d9f2f1522f097dfe0f99e8e38c4ed46ccd289818e88b6233818984825533e3df0f1a50e0c705100751de4423940e5194001da2fe1fe7637894645e63a7f369f1b496c86dc03bc45539504bf932af29caa1f9e5b5a423461c9ca729ae32dc17401315165decf8d31a16a8bec2cb195687dac9edbbce54e628e56628b5d6cea8189b6fe74f5ea64659503e507e9369eb8704eeded44c13db7c6234ba926e5217b10a8cbc24fc4d5a62a155c8865e5cbbb50237fce9aea27b4dcec2e537c5fa85e1487ba2eac4235ebf039cc388ba531a73d7cf8053a730020c28981041335098878707f5dd243efc85c5bf367ea4e6137941e5e7f33502896f3e96aef90742914b75794b016f444a2942e8969cea74946f2d9756be8960fbc9259ee1f9ad5ab5fd9ffb4118c38bc9dcc0c57be78243149f97205f257964d0ecef86b13f337e359d64ff4c28970174141b7a3da294e3a02c47f9b396301995a0b30c98c649ac93db38e21ab02b4b53f332eb9d4d701480c3ecbca376d28dcb9afdbc038eb1bd01c61713e651b67f919c2a21d2a5a7808f047b3e9dc80a5732aaa2a2e44fbbb5ef0f12a462f7fde7b35911a093337a2212d7b89a646707c1540bd30520ce9c76e27bd9a4badb6cdbeacdde63705609daf3ec677016ac903b1ed532bcc6c6aa04a4ed460203b543de3502d9a08eac8ff2e5050b2ebf7e945788edfe54763429fe5f61f203d8930252974d015a839aa9af08a103e16ebedad3b40903a7630ecd2b1169671ef16b62d95088f40802c06bb9fdf6d9af9cbc4664bf315873587a40ada1111708f108d32225ef942b1c2698ea4f4511dd65220e948eee2173386a3a1bf5d40dc8763ce7a6e5dfcf465095748f98ab12d88d4a3b8c234ba061da4fa5d62609486602ab6acac261df47c10c4dbfcb34fa74b4dc5ddd790e6ebae70e78a8d91b3b27ef1c2fce69b8213dd6602a561f0f028887c7f281144cc174897fe984c6b505f574a8a6497b355a79eab20fa51a799e307ef2149f11a487c0d70e109f06f278980c783a228fd7bcf101cc8bede7b5f04a62dda7bdaad051bf54f7dc554bb4f7bef818b49fbaf03f286b241ddf9b1bd9f56b906a79e048cb1b6c6bf61c52012d75413d17db77081cd8bcbdadea215fe75a407ee08a1c934ef417e4916d1b420d7cc41c439ad4819c598c5bbee43fc6656630af5b769c6141530bac485f030fb6a931295e36383de95d1ff8c1b98134817dab21d2a3441cb1b53a9f5ff35125a21160e6a158fb1fe46426b851b14d4cda6b165c948b0de81e99b64ae5491536c4168a7e014bc5a82f45ee5fc1408e3704162ef8d9f0357eb957b030669c224c7083812a4e98a19e56c34f15479a1c37cd14d54a9b8d639121ec1141d528827288258dff22588c4bf3818734012ce6f9df0bdf3892fa3c94a93cbd1b98ef97ac559d26149d2a890eb1f1b03da3e6e57ed536ce57f49820bfe7b36085d50b20036dd78b4ec2802b8d0fe69ff3824f83eec5d7438dcada434c970cfd3ee0981aed8511b2f9ce0dac5f0d62508145a199da8f4c22d0c530aaee13b9a01c97f9dd05d298c3ea86c624e5417c1ffbc5d1693c2e082eb082489cd93dbe69be14a2b7c7c29aef641d3c8c09175753c312dd508b49b639994756c6a5ac3b31b63e4e25edc3eb9286b97206a54b7ed4ffc0fad9e9e7cf1f93314ff541b8b2429edb9d3dae666ab02b79f7141a33114514eed3df620d73193b0c627fcb2371fa8db2f1ac57cffb9ef1ecf96ffe2e42b623647b9b3e4d095ec4cbec40590e43f1e36b2c7cdd68961c754a592c1232fb09217381d69791caba9c6251b203e0ec821bb9d5a2be0fdd832fcc4776ea142622215faa33d60ced13ac881d38617d286fcd64e369b757233def4b1f0cbb8dd991ed69aca55a570e43927cc90eec323678af208b9ca408c2393548b85de2cf9725f844a28e2717b26892b62ca6b218fe161dd40a8302d00b4be78a8860dd0c9c6bd462f44d93d90a0df0e1e6dc3abc0a9d4b75ed0ca4256bd402b343df53498032db70ace031d6410465af56daac62f2a76e465546eb3d0e470f70ddbcfff2f284f3c2882cb36befa10ca1f5329a1060c774462d2c868b6923eceea27e3729586332e432f12a08ff5bf7d0d4dd5cb790e29967945dc45dd698cc6042b3c26dc68f8a4b9252560786cc1cda881ce133e8a1aa3fd86bfd8b405c925ad7b497732ead7195faee8fd389f1b8241761da16d61a6199fcf542344621e9ef8838505fc93e6a86edbfb836975901be206bd8f4dd737d124512873d29a6ab49feb66b50a3741c746506b0ee057749bd97751eb48cedbe5de6c4f1c6bfe36803639a7ec27ef2d9cbf998b6046f3a6a6d16767c67819d5ca8979cdb1cf0d11fe6bd1bcf15b91a61698e6f2df08c56bc347cca8f64c16db04cf845e1bb6cd3bb46b157961194d952d4d2e46053b9c6dad9e23267b578e725f0dce7fbf87351767583d3ce898a773974cd02d22e04e95c03cabce322e4507eb6d547f16e69992d754c3d686838331a85dafe6748735fddef5e113cbd2c5c34f4f51b199f38cb702513c8107c29b16cf202db7c08472802c0876df17a889f3f1913e7609bda97445018f1979bbf0fdd4a1b69797f2f3f57a478d9aea3c141a5ad812cd606b0067875ba5c875aa5de74fdd7081fd2274f23c96c4c3b08fb736c69a4a212bdc93ec8ecb03a1fc48cce31062ebd27295296eaa8c34c2fc4ac1882b3adf910036e45f735d621c06ecc365ee4305306587c508073f5281c0f510080b4f7c1b84b26765f228f26fd2fd6925dccb3ff116f0035090ec8eedeabb9afc5d425b49abbad44cffabdca62873c21dec2f67e65062ba9fb61d0596716106e57818fb638ef8feb5febee3f08abfeac5f299d23d47a8372c40f981ecf03634658108bfe69967d571aef5b607add838de869dcf482bc90c326c167d32a8c30344436118011a138079899b0531b63498c84227d18a8d728454487ffedd4aae47499ae607cebdd290b059edf88e05d95a124d38fe3dc73b53ba8587cb454df69941f55a17c3768487482a41f8df974e40e2e5b3ac7aca504adf32ded46682ebd782f1bafe621781045ecd492547725949b7aa03828b555623586945cf1e99c57c31f4ddd274bbdeab1cfd25398ea8f91baa2b7185ae07d8cf335d261ce5a94cff9c85e76786123ece395c7f0738c5b370d1650e4625c7d9741e89091879e9e8f0934a3252f0423ef9abbcb79a5806cd2032ec942366602f6d32a05d0e513dfda77aeb88606e2e555fc2d0bf5bb4817eef47dc6af845b3d52a11262d552158c301de491ffddf3aa7b74a5a0e79265d6c171e5cdb9ede7bb9672b1d97f4a1ecaf59b22948dbf0075a6ab4e55177c955c63da8a8ac0ecb05507bd29c975f127d9d6cb097b31b5ab105c70e0a51a1451f98817b78e3cd67a55998b7d741175a115a83bd10d0b14ea2a167021fe9b775859003d37703360b582d938c7ca4a43e575c3da52961b1ed33eb766c1de323f61e4d49800ca61d5033edfdb5bfe5595bcab4e5ac635c58b6d1fe65c9520d99ca16a06b39784f40cbef34d702da58cce0ea26b3d78fe335f3354c8c7be8d24a70a994409d88cce54a76e8f16875282bd14f96879cad0daa348d434fb6fbb5f31d0bcdb22c95cbf3a32ea760b95009f59b915c173dc934312afd5f424fb21c8f381dfe47275609f3de197b75d9c5b4a883e2748d91d61666edd5640751d8c15c68a50662ac6c2263f5328a59527d692dd8810ca1a3cdb8ba1351ccace5d26cc5407dbca21a0977c1e43a17be68114c4021a1be5ee67daff6bb51b0f479ad293678b77bde87686f97fa67843ff4c882a23bf031300072f35396d6653373eb78dffef777280c03c8d908adab5d675353fed0ef6e05b28380956681c0d8653f59ca74648a87ef6ef5eb247cf0dc3513a5acfbcc4b8bc9b47b3cbc982f6ba7f9c9b7267c8286bcb4c2f78e159784585ce43de9f96b421863eb9fc99f8c7c1049a828c08407376ee551f13751fa4a537fe0412aa7ef910631bff391ac4824fd930902ea0a37fa657bed33c9c348fbb8e35f7f79d31544513cd982744ec92a87ba03bed2673017a231a21fa85990e212e25f9f60712a5013d174ffc235675971dab9dc64181161160ed4f8fdde326165cd50fe22cc0f3d0cc7aacbab8506b709de4c646076fa9421829e132f6f0dc5d75b024a0c6ba65319dda73b1fc31d28676ac2dd65a7f2af94d301aad785e8671f7a013dc7f89751cf802cd94425b4e2b75538d64a5c7d3d21c4d9f0edd245b5cc5a0ff65bed6f03b38725d67c8dec1106575d01b8992da4541b65c22b943f700a637b37d7cf3c6f3a960a99b39b03b1764805b6b46a4acff5509db5d8163735a34ba0513f86e00af165c55bdf76aaf2c3d4fe0d6f323b68fcdb586795e3faec80629a7525f41569ec6a6349cb6ca5abe9a1ad34555337c1e010c603fbb41e3a9c6092034d08135465327e6d09afaf59e525a3ccefcfc7db30af320c481ab61b2d08b1549ad25f87434dd62ed04fde5f03520c0e4757b3e2cbd211d0a34c566cb934370272d0992850bf4dcd4669b641341c5df1f3c8f9039cb7ea3a47c7f00643e7c8552f003123837d905a2bfdfd89eb05e64dd35c63954c947360aaafe0f75cd044f25fe93072c9855a8d9727a48b56b637f130b8cd08cb025302eacc75494972a48d0f251ed0fa18ed6a16f2f65cc819698fca978a5d1908e04abc425b7c934899a8a8f40130cd1f7b4a4109c87bda382a3b831b74d49bc7e934cf56fb122c4adb3dd04bf68aa7152205744290526dfc4af79adbdeb1c0a5fa054aeb897a3a363ca2761b2dedd765a6dd4a456bd5f24ff5442ce73f151daef6784e5f6c451d72dc6a1ebb9335762c4ca3f521a83bf2a967d57a03b3c9efd8262c7c40e2b5f844af1d01c51763e0cfe3c841e9e13a1799c0b82f5cba73787f6197c97bc9b248a5c73f2786fae1c1c5b07534b4e587eba620a8c349994fe1f54072e76d0fd6107dc76c05d36ef776802003a270327cb9d4c70f4c0497684d3a778370a3b4940d8aad94af19859d995369a5b5120403c4bde18fa6357bd1a0b4768e5d1b6e97864bcd6cf483142a1397799e9c35d20ce25f957dbe71b6e57b1ce484dff3113d6b2576fd79b8d806a048cf4d4ecf080c2997770b53cec23ddf867b61c843207675d1bb405899957aa4785f30a060423f7ecb999fa3c432155562267846d75311a02caef16ae48b3765b7f6d97503f01a04389f3072e8fdd70db42f949812c6a82bb25b557ad456d35ffac48d9058dce3845c8ab57c470cce241eabbff4d294cca6a71e6cb3746195d409992fc28d3b7f2f28980ce8f44d8fafb6d71a0e7e5272c48922d6feedf8e843cd55c038bb954e157f4b3c0a6ad655db38bccf19e4b23fbef3eec243ce504536d324c2f09869af28e319d607381fad0c2b40eca13cc512e3902bf46b4030f56defb4ff9304932ecfbefa3bcfb1060d0596c55593481cb522281efe1a707f9129f631fdb2d618fe7fc1432ac8d37f78e361ddd5df3473f70d5cd0d72b6cccee5e4ad8ec4f3647c823a572e13fe535457eced4cac8ced92d8003965cdeaf6441cbf30be350c590f5ac9fda54ca5b08747526d9758deb99bb9a82a2876e8655daa607f96e8d848409abb3dbcbea51c30f8773bd76d9c522312297823e6cb831fb24a4ebc2b76637fd8799d1ff57946002bc044495ae6cc3a23797fea3a88a6652feeb4b652b856f556d817a0761bf9c1010e07799c023f7b9b614d66490ac18c953fc6400dfc844f2e9222c2f81fdb4c975e8fdd80f6541d94d9b26ee857eef394d9b982b38c84a752cc4a0783a4981cbe59ba16fb44f2d3e3a9dd1a183d127d21cbd874ba66ecec5d58e4b29a41cd838c1617730440c044b2ae515a2b33edcbb413c48e1dbd7529524c8f89dfcb25389d26a0d45679e47ca1ab86bdad0d091261606fc9c35ab117d81e84e355d5b84fc452fc12e99d9f66eb35e885dfb80a46a16fdaff08c2d239d413f5f2da99cd75a3fc3ee40f48db739163374cf48c81dea3e21d944813e28bb485c33e5c8ffbf28d2384253736fee1e9acc529d7f0b87053036606d8889127b0ab04c335fbb6c0255d038f71fd91d848b055f86833a0f1c5c03152b4de416ac1891433724c05182fce553b45a6a3b338076671266513cc5d63b2658b00bb11a98684c01aec1b50ae2631c7308681149175acb44e2430893d4e0c48ca7a39fd892b83d7ec73b658ff68c9e716d5b171c5c61d4418d24caa3ed27b8803af107a7e1b07f925630c8bb9366da71984a7ca5350fb6432f9bc57eef351fd533d826bc96e5249349d31ae1953b7171951bda95813695ca3da6b22320cac584751909ba302dc91a6d22131600f01d96bfc2838f26fc02f4d430a73fcc25552c948b8ac85724d3719987896aca4a36209576b5b9a33a56fb3aa166957e690e60d4</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      来看看我在公司里都干了啥
    
    </summary>
    
    
      <category term="journal" scheme="http://oodtoodt.github.io/categories/journal/"/>
    
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="chronicle" scheme="http://oodtoodt.github.io/tags/chronicle/"/>
    
  </entry>
  
  <entry>
    <title>Graduation-Project-note</title>
    <link href="http://oodtoodt.github.io/2020/04/11/Graduation-Project-note/Graduation-Project-note/"/>
    <id>http://oodtoodt.github.io/2020/04/11/Graduation-Project-note/Graduation-Project-note/</id>
    <published>2020-04-11T00:44:18.000Z</published>
    <updated>2020-07-29T02:34:48.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可用的技术"><a href="#可用的技术" class="headerlink" title="可用的技术"></a>可用的技术</h2><p>目标跟踪<br>目标识别<br>关系识别</p><p>最后这点最为重要，所以我们所有的跟踪或者识别技术都是为我们关系识别服务的——需要什么样的接口完全依赖于我们的需要罢了。<br>所以我们来看关系识别</p><h3 id="Referring-Relationships"><a href="#Referring-Relationships" class="headerlink" title="Referring Relationships"></a>Referring Relationships</h3><p>重新看了一遍，这篇老板推的关系推断对我并没有什么帮助。他的本质是把NLP或者说模式识别跟目标识别联系在一起，如果需要一个名次去指代的话，那就是visual grounding：它需要机器在接受一张图片和一个 query（指令）之后，「指」出图片当中与这个 query 所相关的物体。<br>很有趣的一点是这里用到了心理学：「受到心理学中移动聚光灯理论（the moving spotlight theory）的启发，通过使用谓词作为从一个实体到另一个实体的视觉注意转移操作来绕过这一挑战。」</p><p>有一点点稍微的借鉴意义；<br>如果我们已经固定了整个query，那么算法就退化为某种识别了。所以不是没有一点意义。</p><h3 id="Relation-Extraction"><a href="#Relation-Extraction" class="headerlink" title="Relation Extraction"></a>Relation Extraction</h3><p>信息抽取在自然语言处理中是一个很重要的工作，特别在当今信息爆炸的背景下，显得格外的生重要。从海量的非结构外的文本中抽取出有用的信息，并结构化成下游工作可用的格式，这是信息抽取的存在意义。信息抽取又可分为实体抽取或称命名实体识别，关系抽取以及事件抽取等。</p><h3 id="Visual-Reasoning"><a href="#Visual-Reasoning" class="headerlink" title="Visual Reasoning"></a>Visual Reasoning</h3><p>Visual reasoning是个非常重要的问题，由于ResNet等大杀器出现，visual recognition任务本身快要被解决，所以计算机视觉的研究方向逐渐往认知过程的更上游走，即逻辑推理。</p><h4 id="时间关系推理（Temporal-relational-reasoning）"><a href="#时间关系推理（Temporal-relational-reasoning）" class="headerlink" title="时间关系推理（Temporal relational reasoning）"></a>时间关系推理（Temporal relational reasoning）</h4><p>是指理解物体／实体在时间域的变化关系的能力。受启发于Relation Network，本文提出了Temporal Relation Network（TRN），用于学习和推理视频帧之间的时间依赖关系。relational resaoning一直是近期研究的热点，从图1中我们可以看出对于视频来说时序关系是重要的。</p><h5 id="TSN-（-Temproal-Segment-Networks）"><a href="#TSN-（-Temproal-Segment-Networks）" class="headerlink" title="TSN （ Temproal Segment Networks）"></a>TSN （ Temproal Segment Networks）</h5><p>视频里面的连续帧是存在很多冗余信息的，所以dense temporal sampling是不必要的，sparse temporal sampling比较合适。所以TSN的思想之一就是从长的视频中稀疏采样一些帧，然后再聚合起来，这样就能建模长时间域了。另外一个思想，TSN借鉴于two-stream的结构来同时建模appearance和dynamic。</p><h5 id="Relation-Network"><a href="#Relation-Network" class="headerlink" title="Relation Network"></a>Relation Network</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们需要了解visual reasoning的问题</p><blockquote><p>视觉推理最重要的一点就是状态的转移，这种转移往往是通过visual object之间的relation的形式，eg，被人握住的瓶子，那条狗边上的人。但现在Visual Relationship最大的问题有三：（1）现有VG数据库标记太差（2）relationship的种类数量太庞大，不像单纯的物体分类，relationship几乎很难通过标记穷尽一张图上的所有relation，理论上所有object pair有relation，尤其是空间位置关系，任何同一图上一对物体之间必定存在。尝试unsupervised方式？（3）multi-label，两两物体之间的relation不唯一，人可以同时牵着狗/在狗旁边/看着狗/。。。现在的visual relationship/scene graph框架主流还是单分类。</p></blockquote><blockquote><p>作者：汤凯华<br>链接：<a href="https://zhuanlan.zhihu.com/p/60418025" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60418025</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可用的技术&quot;&gt;&lt;a href=&quot;#可用的技术&quot; class=&quot;headerlink&quot; title=&quot;可用的技术&quot;&gt;&lt;/a&gt;可用的技术&lt;/h2&gt;&lt;p&gt;目标跟踪&lt;br&gt;目标识别&lt;br&gt;关系识别&lt;/p&gt;
&lt;p&gt;最后这点最为重要，所以我们所有的跟踪或者识别技术都是为我们关
      
    
    </summary>
    
    
      <category term="project_notes" scheme="http://oodtoodt.github.io/categories/project-notes/"/>
    
    
      <category term="home" scheme="http://oodtoodt.github.io/tags/home/"/>
    
      <category term="GP" scheme="http://oodtoodt.github.io/tags/GP/"/>
    
  </entry>
  
  <entry>
    <title>Redis-quick-start-notes</title>
    <link href="http://oodtoodt.github.io/2020/04/10/java-%E6%8A%80%E6%9C%AF%E6%A0%88/Redis-quick-start-notes/Redis-quick-start-notes/"/>
    <id>http://oodtoodt.github.io/2020/04/10/java-%E6%8A%80%E6%9C%AF%E6%A0%88/Redis-quick-start-notes/Redis-quick-start-notes/</id>
    <published>2020-04-10T08:35:10.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>。</p><a id="more"></a><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>二进制安全的字符串<br>lists<br>sets<br>sorted sets<br>hashes<br>bit arrays<br>hyperLogLogs<br>streams</p><p>INCR、DECR，atomic，原子增减操作<br>get、set、getset设置并返回原值，mset设置多个值，mget亦然<br>exists、del、type</p><h2 id="Redis-expires"><a href="#Redis-expires" class="headerlink" title="Redis expires"></a>Redis expires</h2><p>可以在时间到了之后删除key<br>可以用秒或者毫秒<br>解析都是1毫秒的<br>保存了过期的时间在硬盘上<br>可以以后缀的形式来在create<br>px和pttl是毫秒的形式</p><h2 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h2><p>是用的Linked Lists，即链表实现的，更看重插入删除的效率。<br>如果需要大量的查询操作，你可以用另一种叫做sorted set的数据结构。<br>可以在恒定的时间内以恒定的长度获取到整个lists</p><p>可以用LPUSH来向一个list的头上加元素，RPUSH相反，在尾巴上加元素</p><p>LRANGE会提取整个列表（从头到尾）,需要两个参数，第一个元素和最后一个元素的位置（负数可以从最后开始）另外没有RRANGE</p><p>lpop,rpop</p><p>ltrim可以设定新的list的范围</p><h3 id="blocking-operations"><a href="#blocking-operations" class="headerlink" title="blocking operations"></a>blocking operations</h3><p>是为了解决polling(轮询)的问题而生的，polling有这样的问题：<br>强迫Redis和客户端处理无用命令，之后面临着处理更多无用调用还是等待更长的延迟的问题。<br>BRPOP和BLPOP：如果列表为空，它们将能够阻止，仅当新元素添加到列表中或者用户指定的超时时间到达时，它们才回返回到调用方。<br>可以指定多个list，返回第一个有响应的<br>BRPOP返回值和RPOP略有不同，它是包含了两个元素的数组，超时返回null<br>客户端以有序方式提供服务，第一个block的先被served<br>有兴趣可以查询RPOPLPUSH和BRPOPLPUSH，前者是更安全的队列，后者是阻塞变体</p><h3 id="自动创建和删除key"><a href="#自动创建和删除key" class="headerlink" title="自动创建和删除key"></a>自动创建和删除key</h3><p>指无需为添加删除元素之前是否有key（比如某个list）而操心。比如说c++或java，使用前要判断是否为空等等。适用于所有多个元素组成的数据类型。<br>注意，其中的唯一例外是流数据不会在删除元素时自动摧毁某个键</p><p>当然，类型还是要相同的。</p><h3 id="Redis-Hashes"><a href="#Redis-Hashes" class="headerlink" title="Redis Hashes"></a>Redis Hashes</h3><p>可以理解成为HashMap<br>hmset、hget、hmget(hget的array版)、hgetall、hincrby(指定增量)，hvals<br>值得注意的是，小散列（即一些具有较小值的元素）以特殊方式在内存中进行了编码，从而使它们具有很高的存储效率。</p><h3 id="Redis-Sets"><a href="#Redis-Sets" class="headerlink" title="Redis Sets"></a>Redis Sets</h3><p>sadd添加<br>smembers查询，sismember<br>集合非常适合表示对象之间的关系。 例如，我们可以轻松地使用集合来实现标签。</p><p>对这个问题进行建模的一种简单方法是为我们要标记的每个对象设置一个集合。 该集合包含与对象关联的标签的ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;sadd news:<span class="number">1000</span>:tags <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">77</span></span><br><span class="line"><span class="comment">//逆关系：用给定标签标记所有新闻</span></span><br><span class="line">&gt;sadd tag:<span class="number">1</span>:news <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>我们可能需要包含标签1、2、10和27的所有对象的列表(注意，必须全部包含):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sinter tag:<span class="number">1</span>:news tag:<span class="number">2</span>:news tag:<span class="number">10</span>:news tag:<span class="number">27</span>:news</span><br><span class="line">... results here ...</span><br></pre></td></tr></table></figure><p>sunionstore执行多个集合之间的联合，并将结果存储到另一个集合中<br>scard指集合的基数<br>srandmember可以不remove随机取元素（还有取重复/非重复的元素的功能[?)</p><h3 id="Sorted-sets"><a href="#Sorted-sets" class="headerlink" title="Sorted sets"></a>Sorted sets</h3><p>理解为正map…就是会依照value给key排序的set<br>zadd(注意是可以更新的，返回值0更新，1新增)<br>zrange、zrevrange WITHSCCORES、zrangebyscore、zremrangebyscore(范围内有多少个)<br>sorted-sets有个次排序资格：字典序，并且可以依照字典范围操作，有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrangebylex h [a [b</span><br><span class="line"><span class="comment">//注意[和(的问题</span></span><br><span class="line"><span class="comment">//非常重要，因为可以用作通用索引</span></span><br></pre></td></tr></table></figure><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>不是实际的数据类型，而是在String类型上定义的一组面向位的操作。<br>位操作分为两类：固定时间的单个位操作；对位组的操作，例如计算给定范围内设置的位的数量<br>优点是存储信息时节省大量空间<br>setbit、getbit(超出范围始终视为0)<br>bitop执行按位运算<br>bitcount执行填充计数，报1的位数<br>bitpos第一个1的位置(of a string)<br>bitpos和bitcount都可以在字符串的字节范围内运行，而不是整个长度上运行</p><p>bitmaps的常用情景是<br>各种实时分析<br>存储于对象ID相关的空间高效且高性能的布尔信息</p><p>比如说记录网站用户每天访问。每次访问都可以按一个bitset的1，这样每个用户就都有一个字符串，bitcount就可以获得给定用户访问网站的天数，只需几个bitpos调用，或调用和分析bitmap client-side，就可以轻松计算出最长连续访问网站的人是谁。<br>【个人理解，就是循环跑bitpos计数。对于0很多的情况会很快。<br>可以用每个key存储M位的方式分割bitmap，使用bit-number MOD M即可。bit-number/M就可以访问。</p><h2 id="HyperLogLogs"><a href="#HyperLogLogs" class="headerlink" title="HyperLogLogs"></a>HyperLogLogs</h2><blockquote><p>本质是一种算法，引申为一种数据结构。<br>是一个<em>基数估计</em>算法，比如说一个集合｛0, 1, 3, 3, 4, 5}，其基数是5，而个数是6。因为3重复出现了两次。基数是个去重统计。通常用来统计一个集合中不重复的元素个数，例如统计某个网站的UV，或者用户搜索网站的关键词数量。数据分析、网络监控及数据库优化等领域都会涉及到基数计数的需求。<br>其空间效率非常高。</p></blockquote><p>HyperLogLog是一种概率数据结构，用于对唯一事物(技术上讲就是集合的基数)进行计数。它以内存为代价来交换精度。您只需要使用恒定数量的内存，使得误差小于1%。<br>尽管技术上HLL是不同的数据结构，Redis仍然视其为string，：可以用get、set等指令。<br>概念上使用HLL就像使用set。但HLL不是真正添加元素进去，因为数据结构仅含有一种不含实际元素的状态，它的API：<br>看到新元素，用PFADD加入。<br>想要检索pfadd添加过的数目的当前近似值时<br>一个例子是每天计算用户在搜索表单中执行的查询（唯一）</p><h3 id="其他重要特征"><a href="#其他重要特征" class="headerlink" title="其他重要特征"></a>其他重要特征</h3><ul><li>可以逐步迭代大型集合的键空间</li><li>可以在服务器端运行lua脚本以改善延迟和带宽</li><li>Redis也是一个Pub-Sub服务器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DB" scheme="http://oodtoodt.github.io/categories/DB/"/>
    
      <category term="Redis" scheme="http://oodtoodt.github.io/categories/DB/Redis/"/>
    
      <category term="documentation" scheme="http://oodtoodt.github.io/categories/DB/Redis/documentation/"/>
    
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="DB" scheme="http://oodtoodt.github.io/tags/DB/"/>
    
      <category term="Redis" scheme="http://oodtoodt.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>java-Spring-Boot-notes</title>
    <link href="http://oodtoodt.github.io/2020/04/08/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java-Spring-Boot-notes/java-Spring-Boot-notes/"/>
    <id>http://oodtoodt.github.io/2020/04/08/java-%E6%8A%80%E6%9C%AF%E6%A0%88/java-Spring-Boot-notes/java-Spring-Boot-notes/</id>
    <published>2020-04-08T03:04:37.000Z</published>
    <updated>2020-07-14T02:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>我放眼望去，满眼都是Auto几个大字。<br>大抵就是用的时候查一下，还不会就Stack Overflow请。</p><a id="more"></a><hr><p>[安装Spring Boot]&lt;-安装maven&lt;-安装choco<br>准确的说只需要jdk和maven就行了<br>写一份奇怪的pom.xml(Project Object Model),maven开始疯跑，最后success<br>？应该有warning啊，warning呢。<br>输入了错误的指令，然后maven居然搞得跟真的一样装了一堆依赖…真吊啊<br>写了一个奇怪的java</p><blockquote><p>@RestController，@RequesetMapping是固定（刻板）注解，而且是mvn的，不是Spring Boot的（所以该学的还是要学的），前者便于人理解代码顺便告诉Spring是web(@Controller)，后者是提供了路径信息，告诉Spring所有带<code>(&quot;/&quot;)</code>的HTTP请求应当被map到home方法。<br>第二个类级别的注释是@EnableAutoConfiguration,让Spring Boot在基于加载的jar依赖来「猜测」你想要如何配置Spring。因为spring-boot-starter-web添加了Tomcat和SpringMVC，所以自动配置会假定你要开发一个网络应用然后套一下Spring的预设定。不仅仅是Starters里面的会被加在设定集里，其他的也可以。<br>main方法就是启动方法，和java一样。我们的java方法调用SpringApplication的run。SpringApplication会引导应用启动Spring,也就启动了自动配置的Tomcat网络服务器。我们要传一个Example.class作为run的方法来告诉SpringApplication这是主要Spring组件。args也会被传递来公开命令行参数<br>然后mvn spring-boot:run或者直接用ide的run去跑，就可以访问localhost:8080来看hello world了</p></blockquote><p>接下来是关于配置…<br>忘了写笔记真是误了大事。</p><h3 id="构造系统"><a href="#构造系统" class="headerlink" title="构造系统"></a>构造系统</h3><p>（Maven）<br>默认继承defaults from Spring Boot</p><p><code>&lt;properties&gt;</code>可以覆写需要的依赖</p><p><code>&lt;dependencyMangement&gt;</code>是管理器，如果dependencies里的dependency自己没有声明version元素，那么maven就会到dependencyManagement里面去找有没有对该artifactId和groupId进行过版本声明，如果有，就继承它，没有报错。如果自己声明了那就无视这个管理器<br>scope=import可以使得依赖不再单一继承<br>但这样就不能覆写属性了，你需要在管理器里，spring-boot-dependecies entry之前添加你需要的属性作为dependency</p><p><code>&lt;plugins&gt;</code>标签可以打包项目为一个可执行的jar</p><p><code>mvn spring-boot:run</code><br><code>mvn package//完全自包含可执行的jar</code></p><h3 id="结构化代码"><a href="#结构化代码" class="headerlink" title="结构化代码"></a>结构化代码</h3><p>如果一个class没有在一个package里声明，它就应当在default package里。default package通常不鼓励使用。</p><p>@SpringBootApplication通常放在主类中，它隐式定义某些项目的一个基本「search package」，比如如果你写JPA应用，你应当用它来搜@Entity。<br>如果你不用它，那@EnableAutoConfiguration and @ComponentScan annotations 也可以。</p><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>更推荐用Java-based的配置而非xml的sources。我们通常推荐你的主要source是a single @Configuration class。main方法是首选的<br>搜索<code>Enable*</code>批注解决你可能的代码遗留的XML配置问题</p><h4 id="Import-更多地Configuration类"><a href="#Import-更多地Configuration类" class="headerlink" title="Import 更多地Configuration类"></a>Import 更多地Configuration类</h4><p>你不需要把所有Configuration放在一个类里，@Import可以用来import更多地Configuration类，有选择的，你可以选择@ComponentScan来自动选择所有的Spring组件</p><h4 id="Import-XML-配置"><a href="#Import-XML-配置" class="headerlink" title="Import XML 配置"></a>Import XML 配置</h4><p>用@Configuration，然后用@ImportResource</p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>Spring Boot会自动根据你的依赖来配置。<br>你需要选择是否允许自动配置，使用@EnableAutoConfiguration 或者@SpringBootApplication 给你的@Configuration类（只用一个）</p><h4 id="逐渐更换自动配置"><a href="#逐渐更换自动配置" class="headerlink" title="逐渐更换自动配置"></a>逐渐更换自动配置</h4><p>自动配置是非侵入的，你不需要为更改自动配置后代码会玩完而害怕。比如如果你想加入自己的DataSource bean，那么默认的嵌入式数据库就会退出。<br>如果你需要了解正在应用哪些配置和原因，可以用–debug开关启动你的应用。这样可以启动调试日志。</p><h4 id="禁用特定的自动配置"><a href="#禁用特定的自动配置" class="headerlink" title="禁用特定的自动配置"></a>禁用特定的自动配置</h4><p>你可以使用@SpringBootApplication的exclude属性来禁用他们<br>@SpringBootApplication(exclude ={DataSourceAutoConfiguration.class})<br>如果该类不在类路径中，则可以用excludeName属性并指定完全限定的名称。如果你更喜欢@EnableAutoConfiguration，exclude和excludeName也可用。最后，你还可以用spring.autoconfigure.exclude属性来控制禁用列表<br>（你可以都用<br>（不建议直接使用这些自动配置类</p><h3 id="Spring-Beans和Dependency-Injection-依赖注入"><a href="#Spring-Beans和Dependency-Injection-依赖注入" class="headerlink" title="Spring Beans和Dependency Injection(依赖注入)"></a>Spring Beans和Dependency Injection(依赖注入)</h3><p>如果将应用程序类放在根package中，你可以@ComponentScan而无参数，你的所有应用程序组件就会自动的注册为Spring Bean。<br>@Autowired进行构造函数注入，如果有构造函数则也可省略<br>注入，使用构造函数注入会使得构造的被标记为final，随后无法更改</p><h3 id="使用-SpringBootApplication-批注"><a href="#使用-SpringBootApplication-批注" class="headerlink" title="使用 @SpringBootApplication 批注"></a>使用 @SpringBootApplication 批注</h3><p>许多Spring Boot开发人员喜欢他们的应用程序使用自动配置，组件扫描，并能够在其“应用程序类”上定义额外的配置。 单个@SpringBootApplication批注可用于启用这三个功能，即：</p><ul><li>@EnableAutoConfiguration：启用Spring Boot的自动配置机制</li><li>@ComponentScan：在应用程序所在的软件包上启用@Component扫描（请参阅最佳实践）</li><li>@Configuration：允许在上下文中注册额外的bean或导入其他配置类</li></ul><h3 id="跑你的程序"><a href="#跑你的程序" class="headerlink" title="跑你的程序"></a>跑你的程序</h3><p>打包成jar并使用嵌入式HTTP服务器的最大优势是可以像运行其他应用一样运行你的程序。调试也会很容易。<br>用Maven的话</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar target/myapplication<span class="number">-0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br><span class="line"><span class="comment">--启用了远程调试支持的话</span></span><br><span class="line">$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=<span class="number">8000</span>,suspend=n \</span><br><span class="line">       -jar target/myapplication<span class="number">-0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br><span class="line"><span class="comment">--最简单的的话</span></span><br><span class="line">$ mvn spring-boot:run</span><br><span class="line"><span class="comment">--MAVEN_OPT操作系统环境变量</span></span><br><span class="line">$ export MAVEN_OPTS=-Xmx1024m</span><br></pre></td></tr></table></figure><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>spring-boot-devtools模块可以包含在任何项目中。<br>运行完全打包的程序时将自动禁用它。重新打包的存档里不包含devtool。</p><h4 id="属性默认值"><a href="#属性默认值" class="headerlink" title="属性默认值"></a>属性默认值</h4><p>开发过程中的缓存可能会适得其反，所以<br>spring-boot-devtools模块自动禁用缓存选项。<br>缓存选项通常由application.properties文件中的设置配置<br>Web开发中如果你希望配置日志记录可以打开spring.http.log-request-details</p><h4 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h4><p>每当classpath上的文件更改时，使用spring-boot-devtools的应用都会重新启动。<br>分叉…<br>LiveReload…<br>DevTools上下文的「关闭挂钩」会在重新启动期间关闭。</p><p>如果发现重新启动对于您的应用程序而言不够快，或者遇到类加载问题，则可以考虑从ZeroTurnaround重新加载技术，例如JRebel。 这些方法通过在加载类时重写类来使它们更适合于重新加载。</p><h5 id="条件评估的变动会被log"><a href="#条件评估的变动会被log" class="headerlink" title="条件评估的变动会被log"></a>条件评估的变动会被log</h5><h5 id="排除资源"><a href="#排除资源" class="headerlink" title="排除资源"></a>排除资源</h5><p>Thymeleaf模板可以就地编辑。默认情况下，更改<code>/ META-INF / maven，/ META-INF / resources，/ resources，/ static，/ public</code>或<code>/ templates</code>中的资源不会触发重新启动，但会触发实时重新加载。如果要自定义这些排除项，则可以使用<code>spring.devtools.restart.exclude</code>属性。例如，要仅排除<code>/ static</code>和<code>/ public</code>，可以设置以下属性：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.restart.exclude =static/ **，public/ **</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我放眼望去，满眼都是Auto几个大字。&lt;br&gt;大抵就是用的时候查一下，还不会就Stack Overflow请。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/categories/java/"/>
    
      <category term="frame" scheme="http://oodtoodt.github.io/categories/java/frame/"/>
    
      <category term="spring boot" scheme="http://oodtoodt.github.io/categories/java/frame/spring-boot/"/>
    
    
      <category term="java" scheme="http://oodtoodt.github.io/tags/java/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
  </entry>
  
</feed>
