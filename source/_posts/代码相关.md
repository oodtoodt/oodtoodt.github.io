代码相关
7.20 10:16



小tip:
+ provider设计模式的核心概念是入口程序将某个对外提供的服务接口转嫁到不同的provider去实现,而被选择的provider并不是通过继承服务接口去实现服务,而是通过另外的独立的继承途径去实现.相比接口继承实现模式,provider模式提供了更多的可扩展性和灵活性.
+ 数据存在ctx里，这个ctx全名OperationContext操作上下文，可以setData(把指定的数据类型的数据存进去，还可以getData取出来)
+ 封装了流式操作，用ExecutorFactory。(表示链接在一起的步骤链，将按注册顺序执行，如果需要，可以返回最后一步结果的Future，以便与vertx正常链接（compose/map 链接）)
+ ValidationUtils中的valitdate是用来确认是否实现了validatable接口，然后根据这个接口来判断新的错误(两层thorw吧应该就算)
+ 注意waitfor可能有多种实现，看到逗号分隔的式子时先看前面的waitfor之类的参数
比如一个参数的是操作本身
两个的话第二个会收到第一个的返回值
+ ~~经验总结的话，失败是Future.succeededFuture()，有点...有点奇怪。~~
+ recover是直接变化前面的future状态！！懂了吗，前面的状态！因为可以获得一个cause，所以在特定的Exception的情况下，可以交给logger让他记录一下，future改成一个succeededFuture，如果没有记录就是正常跳出，仍然变成一个failedFuture！
这是个特性，可以用来跳过一些判断，比如有一个「如果登陆失败，应当作无事发生」，就可以logger一下，但是仍旧当作succeed继续跑。
+ 所有accountProvider.xxx()的操作都是数据库操作。
+ 有一说一，很多函数（方法）大量出现，要找到规律（即用法）和不太相同的注释。有一点问题是我每次都不写接口或者类，只写调用的方法名，其实有些难理解的，比如上一条tip提到的，如果写出来的话会好很多。
//TODO+1
+ fireAndForget:发后即忘，发送方和接收方彼此隔离。不会阻塞地等待消息

---








authAnonymous，第一个中函数，create a session在服务器上或者创建一个新的账号，这个账号还会和B.net账号link。
首先都在Executorfatory上做
+ 先验证error各种null/empty的情况
+ 找到账号。若无则创建一个，创建用createAnonymousAccount
+ 检验该账号是否被ban
+ 若无B.net账号，创建一个(匿名anonymous的)
    + 检查一下创建的sessiondetail，然后加进ctx里，顺便给ctx里的account赋一下这个bnetA
+ 更新账号link(link,devices)
+ 更新gld版本
+ 生成session
+ //==sujun==//session存到redis中
    + 用sessionprovider.saveSession，需要把session转为SessionCacheInfo
+ run()


出现了不认识的authFirstParty

然后这个throws好恐怖啊
我就是想知道这个validate到底是确定什么jb的。

auth+GameCenter/GooglePlay/Gplus/Kakao/Nintendo
都用到了authFirstParty，长得都一样，用到函数的参数不太一样，后面提。

link+GameCenter/GooglePlay/Nintendo
用linkFirstParty，在自己信息的基础上，还要3个String bnet账号/密码/登陆token
作用是link a user with credentials

linkBnet不同，是用linkBnetMasterAccount，还要带gamesenter/googleplay/nintendo的参数

linkForce+GameCenter/GooglePlay/Nintendo
用linkForceFirstParty，同上

linkForceBnet同上，多两个异常判定

Force：发生冲突时，通过将账号与提供的用户id关联解决。
与第一方关联的所有外部账户从源账号转移到目标账号
Bnet account 和 两个blades account link，解决了选择账号

---

refershToken
ExecutorFactory起手。
userinfo gldversion判断空
token必须经过2/3的生命周期才可以refresh，容易倒推得：tokenExpirationSeconds是应当死亡的时间（token到期时间） - 1/3 * 已经存活的时间 < 当前时间，则报错too soon（说明还没到2/3存活时间）
accountProvider.requireAccount，扔给ctx（上面也有过，就是找到账号）
处理账号link问题
获取Bnet权力，避免一直refresh而获得不到的情况
更新ban状态
更新gldversion

refreshSession，注意
生成session如果gld是新的,避免token带有旧版本gld
//==sujun==
session存到redis

---

createAnonymousAccount
创建一个匿名Blades账号。会创建一个匿名B.net账号然后link到blades账号上


好，爷又不会了。就离谱，我才反应过来这里的大部分东西都是接口变量，那他到底用谁的实现呢。
上面根本找不到就离谱。
上面找到的是ctx，ctx就算资源的一种了，那再想知道是谁在调用根本就是天方夜谭，怎么会有这种设计
我再想想。
可能就是不想让人知道是谁在调用吧，很成功.jpg。用的人必须注意不能用错。
这里有一个奇异的设计，就是用list来存某一个数据，对，是一个数据。叫ExternalAccountId

fireAndForget现存的用到的地方有些有限，存疑。


---

tryCreateAnonymousBnetAccount
试图创建匿名Bnet账号
调用CreateAnonymousAccount函数
这里问题又来了。
还是一样的该死的问题，为什么用接口变量.函数?那么用的到底是哪个函数？
懂了，全都是在初始化的时候干的，这就是接口的用处了。根据初始化时候使用的变量来调用。

~~里面有个future.recover，文档写的是「返回另一个future的结果来处理这个future的失败」，里面是出错(logger.error)的时候返回了succeededFuture(null)，外面用的是e->Future.failedFuture(e),老实说，存疑吧。~~
（后面注释是失败也当无事发生，意思就是创建会做，控制一下返回值。
懂了，写在tip了。

---

很关键，被苏老师强调的函数。
FirstParty翻译待定/甲方、第一方/首次参与（大概率前者），这里用第一方翻译。

authFirstParty
    在由第一方凭据标识的用户的后端服务上创建会话
直接executorfactory
+ 先确认error
+ waitfor Validate signin details
+ waitfor 取blade账号(account),用associated的第一方账号
    + 从ctx中取出externalAccountId(用一个waitfor赋给后面的操作)
        + 用id检查账号不存在/创建被禁止 跳error
        + account放进ctx
        + //===add By Sujun
          区分账号的类型是Gplus还是kakao（否则设空？）
+ waitif 处理账号link问题
+ waitif 处理ban问题
+ waitfor 登陆BNET账号，失败也当无事发生(这里就是recover,控制一下返回值)
+ 如果找不到account，尝试通过master buid找到ExternalAccountId(bnetid)，反向找到account(如果存在这样的联系的话，即第一方凭据绑定bnet master buid，这个id绑定一个存在的account)，注意到取不出来(没有这种联系)或者登陆失败都会返回一个Future.succeededFuture()
这里没有做处理，我感到奇怪。
+ 3 * waitfor 更新账号状态（创建如果需要(应该就是之前的处理了),更新link，更新devices
+ 2 * waitfor 获取权限（获取Bnet权力），增加ea资格:master account(tryUpdateAccountEntitlement)、early access
+ waitfor 更新gld
+ //===Modified by sujun sessioncache更新

---

吐槽:怎么函数变得一个比一个长了...

---

tryProvideReceiptEarlyAccess
提供early access entitlement基于receipt（订单)

+ 确认有ios receipt且处于gating
+ ExecutorFactory启动
+ waitif get entitlements associate to account(如果玩家无master且无联系)

以下大量recover警告！
+ waitfor get 绑定在receipt的下载id
    + 如果已经有了gating early accss,无需check，return succeedFuture(new AppleDownloadIDResult(null,false))
    + 否则用appleReceiptProvider.getDownloadId(receipt).recover，后面就是神奇的recover
    + 我懂了，就是如果是服务器请求Apple问题的话，当作无事发生继续运行。
+ waitfor 检查备用终点(if needed)
    + checkEndPoint
    + Logger记录一下receipt第一部分(长度11)
    + recover getDownloadId备用host是否连通
+ waitfor 如果找到有效的未分配gate，给user entitlement
    + 如果gate有user了，就不给。如果空闲但是不匹配就是hack行为，不给
    + 注意给account新增entitlementId的方式和格式，给完了recover一下。
+ waitfor 如果entitlement给出了，更新gate并绑定相应user
    + 更新gate注意方式。最后save一下，带recover

---

linkFirstParty
将第一方或B.NET主帐户与经过身份验证的用户相关联。
凭证可能已经与另一个Blades帐户相关联。 在这种情况下，将返回冲突以及两个帐户的用户ID。
如果未检测到冲突，则将帐户链接在一起（blades服务器帐户和B.NET帐户），并返回合并帐户的会话。

ExecutorFactory启动
+ validate * 3 确认一波信息
+ waitfor 确认登陆细节
+ waitfor 检查有无冲突问题。先用函数查到冲突的账号，id加进accountLinkresult中
+ waitfor fixBnetAccountStatus（检查账号link问题
+ waitif 无冲突，新的一层ExecutorFactory
    + waitfor 取account、ExternalAccountId，向前者add audit note，saveAccount
    + waitfor 获取bnet session token
        + 第一个参数内:
        + 取account，如果玩家现在有一个bnet**匿名**账号，设bnetSessionDetailsFuture为bnetAccountProvider.authAnonymous()
        + 如果有一个bnet FULL_ACCOUNT，用账号密码，就用账号密码通过，空bnetLoginToken就bnetAccountProvider.loginGameAccount，否则.auth
        + bnet account是no_account/GAME_ACCOUNT则无link必要，session remain null(succeededFuture())
        + 返回bnetSessionDetailsFuture.recover
        + 第二个参数内:
        + 验证参数中传递的凭据是否与当前经过身份验证的帐户（currentMasterBuid）相同的Bnet帐户。用Account.findExternalAccountId()和bnetSessionDetails.getMasterAccountBuid()
    + waitif 用external account credentials登入Bnet game account，if gameAccountLoginexecutor!=null，.run().recover()即可
    + then 确认第一方账号没有link到不同的bnet master account中。
    事实上就是用当前ctx中的BnetSessionDeatils(中间轴件)与取出来的Account.findExternalAccountId的Master accountbuidid比对一下。
    + waitif **link game account if required**.总是required，不过bnet不允许link匿名account into game account，另外可能因为服务失败一直无法创建bnet
        + if 检查各项需要的:selected_session_details,!isBnetAnonymous(),BnetSessionDetails,getMasterAccountBuid
        + selectedSessionToken=((BnetSessionDetails) ctx.getData(SELECTED_SESSION_DETAILS)).getSessionToken
        + rejectedSessionToken=BnetSessionDetails.getSessionToken
        + linkResolveGameAccount(Link a game account with a master account. Force keep the game account identified by the selected session token.)
        + 最后保存session details

        ~~如果你仔细看，就知道这里就有了SELECTED_SESSION_DETAILS和bnetsessiondetail的区别了,hhh~~
    + then **add audit note确认账号已link，更新bnet account state**
    + waitfor **Commit link to Blades account提交link** updateAccountLink（这里很奇怪，因为经验是之前都会绑定和device一起update）
    + waitfor **Get entitlements from BNET (works only if user has master account)** BnetAccountManager.tryUpdateAccountEntitlement（即获取权限，或者说获取Bnet权力）
    + waitif **Refresh刷新 the login token** bnetAccountProvider.getLoginToken
    + then **generate生成 session** authenticationHandler.generateSession;accountLinkResult.setSession(session);accountLinkResult.setLoginToken(loginToken);
+ then ()-> accountLinkResult
+ run()
(后面主要是调用不同的接口了，没有什么很迷惑的地方，我就直接贴了。)

---

linkBnetMasterAccount
link a master Bnet 账号和一个已认证过的用户。我们希望用户有一个game/anonymous account linked to blade account。
如果用户有第一方游戏账号，客户端提供第一方credentials以使我们获得游戏账号session token for linking resolve
可能credentials已经被另一个账号绑定，冲突会返回二者的id
无冲突就link，返回session。

斜体表示和上面不同的
BetAccountStatus有这几种：
NO_ACCOUNT：没有和blades account绑定的account
ANONYMOUS：blades account 和一个匿名B.NET account link
GAME_ACCOUNT：blades account和一个external(外部?)B.NET game account link
FULL_ACCOUNT：blades account和一个master B.NET account、一个或更多的game account link

ExecutorFactory启动
+ validate * 3 确认一波信息
+ waitfor 确认登陆细节
+ waitfor **检查有无冲突问题**。先用函数查到冲突的账号，id加进accountLinkresult中
+ *wait if **如果冲突，set login token** bnetAccountProvider.getLoginToken().recover()*
+ waitfor fixbnetAccountstatus
+ waitif 无冲突，新的一层ExecutorFactory
    + waitfor 取account、ExternalAccountId，向前者add audit note，saveAccount
    + waitfor 获取bnet session token
        + 第一个参数内：*直接返回，无需用bnetsessiondetailfuture做recover*
        + 取account，如果现在有一个bnet匿名账号，return .authAnonymous
        + *如果是一个game_ACCOUNT，则按传进来的平台扔loginGameAccount()*
        + 其他情况均succeededFuture，~~值得一提的是，这里的注释和之前一样，但是实际代码有些区别。~~后面的注释就正确了。

        + 第二个参数内：
        + *这里直接赋值给了selected_session_details，没有其他的任何操作。而linkFirstParty却是先判定null，中间还有个throw，最后才赋值。*
    + waitif **link game account if required，仅当user当前有master account时运行** *区别是没有recover*
    + then **add audit note确认账号已link，更新bnet account state** 完全一致
    + waitfor **Commit link to Blades account提交link** 完全一致
    + waitfor **Get entitlements from BNET (works only if user has master account)**  完全一致
    + waitfor **由于可能更改了session details，需要generate 新的login token** getLoginToken.recover
    *区别：不用ctx里的selected_session_details，而是用ctx的bnetsessiondetails* 老实说我不知道搞这种活有什么用
    + **generate session** 完全一致
    + run
+ then ()->accountLinkResult
+ run

---

linkForceFirstParty
将给的用户和外部账号link。发生冲突时，通过将账号与提供的用户id关联解决。
与第一方关联的所有外部账户从源账号转移到目标账号
Bnet account 和 两个blades account link，解决了选择账号

ExecutorFactory启动
+ validate * 3
+ then **一个可用的buid required to perform a first party link** validateBuid(userInfo)
+ waitfor **Validate signin details**
+ waitfor **检查冲突问题** *不同之处在于这里如果没有冲突账号会throw error"FIRST_PARTY_LINK_NO_RESOLVE_REQUIRED"，否则存下冲突账号*
+ waitfor fixbnetAccountstatus
+ waitfor **获取bnet session token** 这里和linkFirstParty几乎一模一样，区别是*当遇到no_account/game_account时， "throw an error as these are invalid states"*
+ waitif **登入BNET游戏账号if using 第一方credentials** gameAccountLoginExecutor.run
+ then **接上** accountForceLinkHandler.setup 第一个参数是target，第三个是source。初始化就是第一个用ctxAccount，第三个用刚才存下的冲突Account
+ waitfor * 2 **save audit notes to both accounts** saveAccount把刚才那俩都给存起来
+ waitfor **把source的account links转移到target中** transferExternalAccounts()，后面遍历link挨个存到数据库里
+ waitif **Link B.NET accounts if required** if shouldlink，linkResolveGameAccount.这里的link和正常的link区别是判断特别少，取双token也是从目标和源各取一个sessiontoken，建议自己对比一下。
+ waitfor * 2 又更新一遍数据库...."**Save our updated accounts in Dynamo DB now that the B.NET account has passed**"
+ waitfor **Get entitlements from BNET** target的，其他一致
+ waitfor **Update the gld version of target(kept) account with the source(ditched) account's GLD version if it is newer** 说白了用目标往源里更gld（注意顺序吧
+ **Refresh the login token** 完全一致，这里就用的ctx了
+ **Generate session for selected account** 如注释。

---

linkForceBnetMasterAccount
找茬开始了

这里就不写流程了，直接找不同。

前面一样
+ *在get b.net session token的时候，如果获取到的是game——account，3检查。最后如果是full、no则throw*
+ *不需要gameAccountLoginExecutor.run()*
+ transfer都一样，之后就出现了区别*会存了之后再link bnet，而之前是先link再存*
+ *refresh the login token的时候没有判断，不是用SELECT而是用ctx.BnetSessionDetails*注释写道:***Since we might have changed our session details we need to generate a new login token***这里倒是跟之前那个一样。

---

fixBnetAccountStatus
**此方法处理account验证是否时可用的bnet state，fix it if necessary**
+ 取externalAccountId(betn_master_account)
+ 检查BnetAccountStatus.GAME_ACCOUNT是否等同于account.getBnetAccountStatus且有externalAccountId
    + 如果等于，就说明是FULL_ACCOUNT，account.set，.addaduitnote。
    + return accountProvider.saveAccount
+ return succeededFuture(account)

---

checkLinkingConflictOrProblems

ExecutorFactor.create()
+ waitFor()
+ waitFor()
+ then 

---

苏老师可真是出了个大难题
看Executor的代码
Executor通常由空Factory进行动作，实际由实现了Executor这个接口的BaseExecutor进行动作。
其中，通过一个`List<ExecutorStep<?>>stepList`进行步骤安排。ExecutorStep是实现了Validatable的抽象类，自带一个`<TResult>`作为这个步骤返回值的类型，核心是apply，意义是执行当前步骤或以前一步骤的值作为参数执行当前步骤。代码逻辑的核心是给previous.setHandler
.setHandler:
失败则给当前future继承fail(p.cause())，成功则用抽象方法apply = executeStep(previous)，trycatch一下，然后把当前的future绑定到apply上。
返回当前future

核心就是executeStep，有多种实现，分别对应比如链步骤、等待步骤等6种。

说白了就是在每两个Future中间插进一个apply来完成不同种类的Executor动作，比如Waitif。即使只有一个要插在前面一个apply。
以waitstep的实现举例，给定previous(就是当前future)，若无waitstep建立一个TPrevious变量，其值为previous.result()，返回waitStepWithPrevious执行此值，否则执行waitstep
推翻了我的结论，令我感到困惑。且不管‘异步步骤’这个类，为什么作为.sethandler(a)，a是previous？明明handler后面是要等待前面的future完成后才会跑的。
回过头看BaseExecutor的run过程，发现先给出chainIterator，while next,nexeStep=Iterator.next()，尝试确定可行性后就是current=nextStep.apply(current),current=null就直接apply。

这样就好了，无参数即run序列的Chain中第一个，执行的是executeStep(null).
make sense。即apply执行一个null的future(虽然不知道能不能，能跑就行.jpg)跑完了就可以直接跑第一个序列了。
第二个时，第一个和第二个是相关联的，此时apply是executeStep(previous)，即取的第一个执行完的future的future，第一个跑完了、完成了apply，就可以跑第二个了。刚才困惑是以为executeStep里绑定的是当前future。

有了上述内容就可以看waitif、waitfor和then了
双参数和三参数本质没有区别，三参数执行WaitWithCallbackStep，双参数执行WaitStep
waitif(condition,operation):新建变量`stepToexecute=new WaitStep<Void,Tresult>(opertion)`,waitStepWithPrevious = opertion
stepList里add `ConditionalStep<TResult>(condition, stepToExecute)`

然后其实ExecutorStep是用不到的，用到的是它的子类的子类们。比如第一层子类BaseConditionalStep，第二层ConditionalStep，其核心逻辑很简单，super(condition),this.step = step.第一层则会用不同的方法实现executeStep，先检查condition，如果有则先执行condition，然后根据这个bool判断是否执行下一步。注意即使是条件没过，也可以继续执行。

嵌套层数过多，需要画图。

不过我已经懂了。现在来看.then
我们需要的是带previous的版本，ChainStep。现在我们有前面一个future和当前的future，现在run。
由于apply只是个外部的临时变量，所以不会在list里面，current就是之前的里的，nextStep就是.then。~~先给出前面的值，.result()，result作为结果量，.complete(连带着参数从.then传进来的（之前的值）作为参数跑，~~注意nextStep用的是ExecutorStep，所以要用对应的apply，当然，会用对应的executeStep。
给前面的future.setHandler()，中间量apply是executeStep执行出参数的future值，~~apply执行完就可以跑当前的future啦。~~
apply根本就不是什么中间量，而是用当前future的结果执行下一个Step的future！于是说ret才是个空值，那么有人会问为什么return ret？

我也不懂啊！断点走起来

懂了 大佬给future都重写了一遍，绑定了mdcHolder，你看到的那个就是默认的空future，

setHandler也改过了，经过一番难以言喻的函数，本来里面是个{Future{unsolve}} 就变成了 {Future{result=null}}

正常的经过sethandler就可以变成result=null，而且也会走正常流程，sb的就直接过去了，step into进不去我人傻了。

进去了，走waitstep

---

以下用到provider用p.代替，用到detailsprovider用dp.代替
Guild用G代替
Details用D代替
Cache=Ca
And=A
update=u
guild=g
response=res
require=req
Member=Mem
Message=mes
master=mas
Characters=Ch
Collection=Co
validate = v
Applications=App

GP是连接bnet/snqu
而GDP是连接数据库的
applications - 申请
response分有无current两种
有current：Details、members、application
response的组成:details、members、是否超出最大申请数

Guild - Controller
很明显的可以感受出来，这边就是把各种方法结合在一起实现某种功能，大部分接口都是Provider或者什么实现出来的。


- getGuild 用提供的guildID
+ p.requireGuild() 取得工会
+ getGMemWithUserIds 添加成员
+ p.getApplicationCount
+ dp.getGuildDetails
+ GuildResponse()

getCurrentGuild
**如果玩家在guild里就返回公会成员列表，否则返回此玩家的公会申请//如果被ban了，则返回一个APPLIED的申请但是对工会不可见**
+ p.getCurrentGuild
+ dp.getGuildDetails
+ 取得成员
+ **如果找到了guild，立刻创建guild response**
+ **如果找到，检查此玩家是否有申请** gP.getCurrentGApp()
    + 无申请，response设一下
    + 有，还大于1，warn一下，返回第一个

updateGDACa
尝试在DB中对GD进行多次读-更新-写操作,用的操作很奇怪，FutureUtils.executeWithRetries(,gdp.uGD,responseRef::set)
gP.uGDCa

leaveG
+ 判断是否为Grandmaster
+ **获取玩家的rank**reqGMem
+ **保证guild PVP score更新完成，Grandmaster影响这个更新**
+ **给Grandmaster找下家**
+ gMesBoardP.postMes()
+ deleteUserGExchanges

grandMasLeaveG
+ 会内无人
+ 会内仅1人候选
+ 会内好多人候选
+ getGMemWithUserIds()-> addall(),找到所有等级最高的成员
+ **如果会内无人，则删掉guild，不过不删掉guild message board，方便可能的会话**
+ 一人直接给
+ 多人，找到pvp奖励最多的人中资历最老的成员
+ 给此人权限，让原会长leave。

uGrandmasSince
**更新会长任命时间戳**

uGpvpTrophiesOnGmLeave
**保证guild pvp score更新完成。和grandmas时间戳**
与上面的区别在于会取一个gpvpT...handler.removeGMem

uGpvpT...Onleave
与上面的区别是不需要更新会长任命时间戳

getGMemWithUserIds
+ gP.getGMem
+ **bnet 返回只含buid，我们必须加进userid**     aP.getAIds()
+ 通过map映射添加

deleteuserGExchanges
**删除guild exchanges(交流?交换?交易?)**
+ cP.getCh
+ 为该玩家的每个角色都删掉GExchanges

searchG
+ gSearch.setLimitMax
+ gSearch.setNameATagWithSeparator(?)
+ **这是唯一用到BNET中的guildDetails的地方，其他的都用数据库的内容。（存在缓存主要是为了允许对其字段进行自定义字段搜索，但是可以在搜索结果中显示它）** gP.searchG
+ GCoRes

kickUser
**封装了从系统中踢出一个用户，增加了目标buid不正确时恢复的功能**
+ Function = gP.deleteGMem
+ 执行动作with成员解决方法(?)

banUser
**封装了从系统中ban一个用户，增加了目标buid不正确时恢复的功能**
与上者不同的就是gP.banUser

vUGReq
**确认更新guild的request**
*放一放，一会看*
先看request类型是否是AdminUGReq，不是的话就要后面做侮辱性语言检查，称做亵渎检查
确认guild 名称、短描述和长描述问题
...亵渎检查长短描述。



getGMemSlotsLeft
**G中还能加入多少成员(插槽)**
+ guildGLD.getMaxMem-gP.getGMemCount

getGGrandMasUserInfo
**检索会长的玩家信息**
取buid、通过buid取得account，然后validate一下，就可以返回了

generateTagId
**给提供的公会名生成TagId**
这里用到TagIdGenerator，看着参数搞就行

approveAsManyApplicationsAsPossible
**就跟名字一模一样的用处（**
逻辑很简单。getGApplicationsWithUserIds,getGMemSlotsLeft,然后根据申请日期给申请排序，遍历所有申请每次容量-1，如果无位置剩余就拒绝申请，有就接受，注意每次接受与否都会做两个动作:
gP.approve/denyApplication
gMesBoardP.postMes()

拒绝所有申请
就这么简单，比起上面不需要容量的限制，只需要遍历即可。

getGApplicationsWithUserIds
**检索该工会的所有申请**
+ gP.getGApp
+ aP.getAccountIds
+ GAppCoRes.updateUserIds()

reqFirstCh
**req 一个玩家的角色列表，返回第一个。**
*Guild support only one character per user currently* ~~存疑，这里之后问一下苏老师~~ 问过了，一个user只有一个character

uAppOnTypeU
**依赖公会type更新申请**
type:开放、需要申请、关闭
如果之前需要申请，之后开放/关闭，按对应方式处理所有申请即可


执行动作with成员解决方法
**这个是用来解决这样一个问题的：匿名用户加入到公会中，升级到第一方后其"匿名buid"会转化为"game buid"，但是公会仍然引用匿名buid，但是很多操作因为系统使用ganmebuid而会失败。此方法通过从bnet检索行会成员列表来匹配其userid来进行用户的反向查找，而不是依赖于用户账户上的buid(第一方buid)来进行禁止/踢动作的正常工作。**
+ 注意recover可以用来做恢复
+ 整体逻辑看下来，只有做recover的时候，才会用到这个反向查找。
这里稍稍存疑。

Controller=C
GMan:
getCurrentG
return gC.getCurrentG

getG
validate之后gC.getG

createG
+ validate非法
+ 取徽章icon，取地区
+ 确认名称、长短描述的长短、codepoint有无错
+ 如果需要仓库，存取一下仓库。取下钱包
+ pay一下
+ 亵渎检查（wtf，为什么先支付再亵渎检查，也无妨，后面才更新
+ 生成tag,gC.generateTagId
+ 取得角色
+ 业务验证(角色是否有资格进入公会)
+ remove该玩家的所有guild申请
+ 创建guild//sujun添加区域参数
    + uGDOnCreateG
    + 更新仓库钱包
+ return 这个guild

看完这个我觉得一个东西迫在眉睫，就是什么是character，什么是user。

---

character

苏老师nb啊，每个character只有一个user（说反了）
说得通说得通。
这样很多逻辑就很显然，甚至非常容易了。

---

uG
+ validate参数非法
+ **需要获取当前guild来得到guildid、gmesboard的准备信息**
    + gP.reqCurrentG 此时有oldGuild和update的req
    + gC.uAppOnTypeU (就是根据type更新申请)
+ **更新guild和其details，然后postmessage**
    + gP.uGWithoutName
    + uGDOnUG
    + gMesBoardP.postMes()
+ return ugRes

leaveG
+ validate
+ gP.reqCurrentG
+ gC.leaveG

kickGMem
逻辑就是
+ 取一堆信息:gP.reqCurrentG,gC.reqFirstCh,aP.getAccount
+ gC.kickUser()
+ **fireAndForget of 公会pvp分数update，使其不会干扰当前call** fireAForget
+ gMesBoardP.postMes
+ gC.deleteUserGExchanges

banUser()
改中间函数即可

searchG
validate后gC.searchG

getGApp
validate,gP.reqCurrentG,gC.getGAppWithUserIds()

joinG
**加入不需要申请的公会**
+ validate
+ cP.getCh
+ 检查加入的公会是否存在(名字如此，检查的却是最大值)
+ **remove该玩家的所有申请**
+ gP.joinG()
+ fireAForgetUGPvpTrophiesOnJoin
+ gMesBoardP.postMes

applyG
**注意申请也是有上限的**
+ validate
+ cP.getCh
+ gP.getGAppCount
+ 确认最大值
+ **reomve该玩家所有申请**
+ gP.applyG
+ aP.getAccount
+ app.setUserId
+ return net GAppRes(app)

---

approveApp
+ validate+三连(gP,aP,gC取当前G，当前Account，Ch)
+ **取出还有多少空位(slots)** gC.getGMemSlotsLeft
+ **如果无空位此时denyall**
+ gP.approveApp
+ fireAndForgetUGPvp...
+ **post 批准**
+ **批了之后满员也denyall**
+ response

---

denyApp

---

明日规划：inventory-market-fulfillment-globalshop-characterManager-shop
建议先看shop

关于guild-s2s
