代码相关
7.20 10:16



小tip:
+ 数据存在ctx里，这个ctx全名OperationContext操作上下文，可以setData(把指定的数据类型的数据存进去，还可以getData取出来)
+ 封装了流式操作，用ExecutorFactory。(表示链接在一起的步骤链，将按注册顺序执行，如果需要，可以返回最后一步结果的Future，以便与vertx正常链接（compose/map 链接）)
+ ValidationUtils中的valitdate是用来确认是否实现了validatable接口，然后根据这个接口来判断新的错误(两层thorw吧应该就算)
+ 注意waitfor可能有多种实现，看到逗号分隔的式子时先看前面的waitfor之类的参数
+ ~~经验总结的话，失败是Future.succeededFuture()，有点...有点奇怪。~~
+ recover是直接变化前面的future状态！！懂了吗，前面的状态！因为可以获得一个cause，所以在特定的Exception的情况下，可以交给logger让他记录一下，future改成一个succeededFuture，如果没有记录就是正常跳出，仍然变成一个failedFuture！
这是个特性，可以用来跳过一些判断，比如有一个「如果登陆失败，应当作无事发生」，就可以logger一下，但是仍旧当作succeed继续跑。

---








authAnonymous，第一个中函数，create a session在服务器上或者创建一个新的账号，这个账号还会和B.net账号link。
首先都在Executorfatory上做
+ 先验证error各种null/empty的情况
+ 找到账号。若无则创建一个，创建用createAnonymousAccount
+ 检验该账号是否被ban
+ 若无B.net账号，创建一个(匿名anonymous的)
    + 检查一下创建的sessiondetail，然后加进ctx里，顺便给ctx里的account赋一下这个bnetA
+ 更新账号link
+ 更新gld版本
+ 生成session
+ //==sujun==//session存到redis中
    + 用sessionprovider.saveSession，需要把session转为SessionCacheInfo
+ run()


出现了不认识的authFirstParty

然后这个throws好恐怖啊
我就是想知道这个validate到底是确定什么jb的。

auth+GameCenter/GooglePlay/Gplus/Kakao/Nintendo
都用到了authFirstParty，长得都一样，用到函数的参数不太一样，后面提。

link+GameCenter/GooglePlay/Nintendo
用linkFirstParty，在自己信息的基础上，还要3个String bnet账号/密码/登陆token
作用是link a user with 证书

linkBnet不同，是用linkBnetMasterAccount，还要带gamesenter/googleplay/nintendo的参数

linkForce+GameCenter/GooglePlay/Nintendo
用linkForceFirstParty，同上

linkForceBnet同上，多两个异常判定

---

refershToken
ExecutorFactory起手。
userinfo gldversion判断空
token必须经过2/3的生命周期才可以refresh，容易倒推得：tokenExpirationSeconds是应当死亡的时间（token到期时间） - 1/3 * 已经存活的时间 < 当前时间，则报错too soon（说明还没到2/3存活时间）
accountProvider.requireAccount，扔给ctx（上面也有过，就是找到账号）
处理账号link问题
获取Bnet权力，避免一直refresh而获得不到的情况
更新ban状态
更新gldversion

refreshSession，注意
生成session如果gld是新的,避免token带有旧版本gld
//==sujun==
session存到redis

---

createAnonymousAccount
创建一个匿名Blades账号。会创建一个匿名B.net账号然后link到blades账号上


好，爷又不会了。就离谱，我才反应过来这里的大部分东西都是接口变量，那他到底用谁的实现呢。
上面根本找不到就离谱。
上面找到的是ctx，ctx就算资源的一种了，那再想知道是谁在调用根本就是天方夜谭，怎么会有这种设计
我再想想。
可能就是不想让人知道是谁在调用吧，很成功.jpg。用的人必须注意不能用错。
这里有一个奇异的设计，就是用list来存某一个数据，对，是一个数据。叫ExternalAccountId

fireAndForget现存的用到的地方有些有限，存疑。


---

tryCreateAnonymousBnetAccount
试图创建匿名Bnet账号
调用CreateAnonymousAccount函数
这里问题又来了。
还是一样的该死的问题，为什么用接口变量.函数?那么用的到底是哪个函数？
懂了，全都是在初始化的时候干的，这就是接口的用处了。根据初始化时候使用的变量来调用。

里面有个future.recover，文档写的是「返回另一个future的结果来处理这个future的失败」，里面是出错(logger.error)的时候返回了succeededFuture(null)，外面用的是e->Future.failedFuture(e),老实说，存疑吧。
（后面注释是失败也当无事发生，意思就是创建会做，控制一下返回值。
目前比较

---

很关键，被苏老师强调的函数。
FirstParty翻译待定/甲方、第一方/首次参与（大概率前者），这里用第一方翻译。

authFirstParty
    在由第一方凭据标识的用户的后端服务上创建会话
直接executorfactory
+ 先确认error
+ waitfor Validate signin details
+ waitfor 取blade账号(account),用associated的第一方账号
    + 从ctx中取出externalAccountId(用一个waitfor赋给后面的操作)
        + 用id检查账号不存在/创建被禁止 跳error
        + account放进ctx
        + //===add By Sujun
          区分账号的类型是Gplus还是kakao（否则设空？）
+ waitif 处理账号link问题
+ waitif 处理ban问题
+ waitfor 登陆BNET账号，失败也当无事发生(这里就是recover,控制一下返回值)
+ 如果找不到account，尝试通过master buid找到ExternalAccountId(bnetid)，反向找到account(如果存在这样的联系的话，即第一方凭据绑定bnet master buid，这个id绑定一个存在的account)，注意到取不出来(没有这种联系)或者登陆失败都会返回一个Future.succeededFuture()
这里没有做处理，我感到奇怪。
+ 3 * waitfor 更新账号状态（创建如果需要(应该就是之前的处理了),更新link，更新devices
+ 2 * waitfor 权限更新:master account、early access
+ waitfor 更新gld
+ //===Modified by sujun sessioncache更新

---

吐槽:怎么函数变得一个比一个长了...

---

tryProvideReceiptEarlyAccess
提供early access entitlement基于receipt（订单)

+ 确认有ios receipt且处于gating
+ ExecutorFactory启动
+ waitif get entitlements associate to account(如果玩家无master且无联系)

以下大量recover警告！
+ waitfor get 绑定在receipt的下载id
    + 如果已经有了gating early accss,无需check，return succeedFuture(new AppleDownloadIDResult(null,false))
    + 否则用appleReceiptProvider.getDownloadId(receipt).recover，后面就是神奇的recover
    + 我懂了，就是如果是服务器请求Apple问题的话，当作无事发生继续运行。
+ waitfor 检查备用终点(if needed)
    + checkEndPoint
    + Logger记录一下receipt第一部分(长度11)
    + recover getDownloadId备用host是否连通
+ waitfor 如果找到有效的未分配gate，给user entitlement
    + 如果gate有user了，就不给。如果空闲但是不匹配就是hack行为，不给
    + 注意给account新增entitlementId的方式和格式，给完了recover一下。
+ waitfor 如果entitlement给出了，更新gate并绑定相应user
    + 更新gate注意方式。最后save一下，带recover

---

linkFirstParty
将第一方或B.NET主帐户与经过身份验证的用户相关联。
凭证可能已经与另一个Blades帐户相关联。 在这种情况下，将返回冲突以及两个帐户的用户ID。
如果未检测到冲突，则将帐户链接在一起（blades服务器帐户和B.NET帐户），并返回合并帐户的会话。

ExecutorFactory启动
+ validate * 3 确认一波信息
+ waitfor 确认登陆细节
+ waitfor 检查有无冲突问题。先用函数查到冲突的账号，id加进accountLinkresult中
