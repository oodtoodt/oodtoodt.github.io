代码相关
7.20 10:16



小tip:
+ 数据存在ctx里，这个ctx全名OperationContext操作上下文，可以setData(把指定的数据类型的数据存进去，还可以getData取出来)
+ 封装了流式操作，用ExecutorFactory。(表示链接在一起的步骤链，将按注册顺序执行，如果需要，可以返回最后一步结果的Future，以便与vertx正常链接（compose/map 链接）)
+ ValidationUtils中的valitdate是用来确认是否实现了validatable接口，然后根据这个接口来判断新的错误(两层thorw吧应该就算)
+ 注意waitfor可能有多种实现，看到逗号分隔的式子时先看前面的waitfor之类的参数
比如一个参数的是操作本身
两个的话第二个会收到第一个的返回值
+ ~~经验总结的话，失败是Future.succeededFuture()，有点...有点奇怪。~~
+ recover是直接变化前面的future状态！！懂了吗，前面的状态！因为可以获得一个cause，所以在特定的Exception的情况下，可以交给logger让他记录一下，future改成一个succeededFuture，如果没有记录就是正常跳出，仍然变成一个failedFuture！
这是个特性，可以用来跳过一些判断，比如有一个「如果登陆失败，应当作无事发生」，就可以logger一下，但是仍旧当作succeed继续跑。
+ 所有accountProvider.xxx()的操作都是数据库操作。
+ 有一说一，很多函数（方法）大量出现，要找到规律（即用法）和不太相同的注释。有一点问题是我每次都不写接口或者类，只写调用的方法名，其实有些难理解的，比如上一条tip提到的，如果写出来的话会好很多。
//TODO+1
+ 

---








authAnonymous，第一个中函数，create a session在服务器上或者创建一个新的账号，这个账号还会和B.net账号link。
首先都在Executorfatory上做
+ 先验证error各种null/empty的情况
+ 找到账号。若无则创建一个，创建用createAnonymousAccount
+ 检验该账号是否被ban
+ 若无B.net账号，创建一个(匿名anonymous的)
    + 检查一下创建的sessiondetail，然后加进ctx里，顺便给ctx里的account赋一下这个bnetA
+ 更新账号link(link,devices)
+ 更新gld版本
+ 生成session
+ //==sujun==//session存到redis中
    + 用sessionprovider.saveSession，需要把session转为SessionCacheInfo
+ run()


出现了不认识的authFirstParty

然后这个throws好恐怖啊
我就是想知道这个validate到底是确定什么jb的。

auth+GameCenter/GooglePlay/Gplus/Kakao/Nintendo
都用到了authFirstParty，长得都一样，用到函数的参数不太一样，后面提。

link+GameCenter/GooglePlay/Nintendo
用linkFirstParty，在自己信息的基础上，还要3个String bnet账号/密码/登陆token
作用是link a user with credentials

linkBnet不同，是用linkBnetMasterAccount，还要带gamesenter/googleplay/nintendo的参数

linkForce+GameCenter/GooglePlay/Nintendo
用linkForceFirstParty，同上

linkForceBnet同上，多两个异常判定

Force：发生冲突时，通过将账号与提供的用户id关联解决。
与第一方关联的所有外部账户从源账号转移到目标账号
Bnet account 和 两个blades account link，解决了选择账号

---

refershToken
ExecutorFactory起手。
userinfo gldversion判断空
token必须经过2/3的生命周期才可以refresh，容易倒推得：tokenExpirationSeconds是应当死亡的时间（token到期时间） - 1/3 * 已经存活的时间 < 当前时间，则报错too soon（说明还没到2/3存活时间）
accountProvider.requireAccount，扔给ctx（上面也有过，就是找到账号）
处理账号link问题
获取Bnet权力，避免一直refresh而获得不到的情况
更新ban状态
更新gldversion

refreshSession，注意
生成session如果gld是新的,避免token带有旧版本gld
//==sujun==
session存到redis

---

createAnonymousAccount
创建一个匿名Blades账号。会创建一个匿名B.net账号然后link到blades账号上


好，爷又不会了。就离谱，我才反应过来这里的大部分东西都是接口变量，那他到底用谁的实现呢。
上面根本找不到就离谱。
上面找到的是ctx，ctx就算资源的一种了，那再想知道是谁在调用根本就是天方夜谭，怎么会有这种设计
我再想想。
可能就是不想让人知道是谁在调用吧，很成功.jpg。用的人必须注意不能用错。
这里有一个奇异的设计，就是用list来存某一个数据，对，是一个数据。叫ExternalAccountId

fireAndForget现存的用到的地方有些有限，存疑。


---

tryCreateAnonymousBnetAccount
试图创建匿名Bnet账号
调用CreateAnonymousAccount函数
这里问题又来了。
还是一样的该死的问题，为什么用接口变量.函数?那么用的到底是哪个函数？
懂了，全都是在初始化的时候干的，这就是接口的用处了。根据初始化时候使用的变量来调用。

里面有个future.recover，文档写的是「返回另一个future的结果来处理这个future的失败」，里面是出错(logger.error)的时候返回了succeededFuture(null)，外面用的是e->Future.failedFuture(e),老实说，存疑吧。
（后面注释是失败也当无事发生，意思就是创建会做，控制一下返回值。
懂了，写在tip了。

---

很关键，被苏老师强调的函数。
FirstParty翻译待定/甲方、第一方/首次参与（大概率前者），这里用第一方翻译。

authFirstParty
    在由第一方凭据标识的用户的后端服务上创建会话
直接executorfactory
+ 先确认error
+ waitfor Validate signin details
+ waitfor 取blade账号(account),用associated的第一方账号
    + 从ctx中取出externalAccountId(用一个waitfor赋给后面的操作)
        + 用id检查账号不存在/创建被禁止 跳error
        + account放进ctx
        + //===add By Sujun
          区分账号的类型是Gplus还是kakao（否则设空？）
+ waitif 处理账号link问题
+ waitif 处理ban问题
+ waitfor 登陆BNET账号，失败也当无事发生(这里就是recover,控制一下返回值)
+ 如果找不到account，尝试通过master buid找到ExternalAccountId(bnetid)，反向找到account(如果存在这样的联系的话，即第一方凭据绑定bnet master buid，这个id绑定一个存在的account)，注意到取不出来(没有这种联系)或者登陆失败都会返回一个Future.succeededFuture()
这里没有做处理，我感到奇怪。
+ 3 * waitfor 更新账号状态（创建如果需要(应该就是之前的处理了),更新link，更新devices
+ 2 * waitfor 获取权限（获取Bnet权力），增加ea资格:master account(tryUpdateAccountEntitlement)、early access
+ waitfor 更新gld
+ //===Modified by sujun sessioncache更新

---

吐槽:怎么函数变得一个比一个长了...

---

tryProvideReceiptEarlyAccess
提供early access entitlement基于receipt（订单)

+ 确认有ios receipt且处于gating
+ ExecutorFactory启动
+ waitif get entitlements associate to account(如果玩家无master且无联系)

以下大量recover警告！
+ waitfor get 绑定在receipt的下载id
    + 如果已经有了gating early accss,无需check，return succeedFuture(new AppleDownloadIDResult(null,false))
    + 否则用appleReceiptProvider.getDownloadId(receipt).recover，后面就是神奇的recover
    + 我懂了，就是如果是服务器请求Apple问题的话，当作无事发生继续运行。
+ waitfor 检查备用终点(if needed)
    + checkEndPoint
    + Logger记录一下receipt第一部分(长度11)
    + recover getDownloadId备用host是否连通
+ waitfor 如果找到有效的未分配gate，给user entitlement
    + 如果gate有user了，就不给。如果空闲但是不匹配就是hack行为，不给
    + 注意给account新增entitlementId的方式和格式，给完了recover一下。
+ waitfor 如果entitlement给出了，更新gate并绑定相应user
    + 更新gate注意方式。最后save一下，带recover

---

linkFirstParty
将第一方或B.NET主帐户与经过身份验证的用户相关联。
凭证可能已经与另一个Blades帐户相关联。 在这种情况下，将返回冲突以及两个帐户的用户ID。
如果未检测到冲突，则将帐户链接在一起（blades服务器帐户和B.NET帐户），并返回合并帐户的会话。

ExecutorFactory启动
+ validate * 3 确认一波信息
+ waitfor 确认登陆细节
+ waitfor 检查有无冲突问题。先用函数查到冲突的账号，id加进accountLinkresult中
+ waitfor fixBnetAccountStatus（检查账号link问题
+ waitif 无冲突，新的一层ExecutorFactory
    + waitfor 取account、ExternalAccountId，向前者add audit note，saveAccount
    + waitfor 获取bnet session token
        + 第一个参数内:
        + 取account，如果玩家现在有一个bnet**匿名**账号，设bnetSessionDetailsFuture为bnetAccountProvider.authAnonymous()
        + 如果有一个bnet FULL_ACCOUNT，用账号密码，就用账号密码通过，空bnetLoginToken就bnetAccountProvider.loginGameAccount，否则.auth
        + bnet account是no_account/GAME_ACCOUNT则无link必要，session remain null(succeededFuture())
        + 返回bnetSessionDetailsFuture.recover
        + 第二个参数内:
        + 验证参数中传递的凭据是否与当前经过身份验证的帐户（currentMasterBuid）相同的Bnet帐户。用Account.findExternalAccountId()和bnetSessionDetails.getMasterAccountBuid()
    + waitif 用external account credentials登入Bnet game account，if gameAccountLoginexecutor!=null，.run().recover()即可
    + then 确认第一方账号没有link到不同的bnet master account中。
    事实上就是用当前ctx中的BnetSessionDeatils(中间轴件)与取出来的Account.findExternalAccountId的Master accountbuidid比对一下。
    + waitif **link game account if required**.总是required，不过bnet不允许link匿名account into game account，另外可能因为服务失败一直无法创建bnet
        + if 检查各项需要的:selected_session_details,!isBnetAnonymous(),BnetSessionDetails,getMasterAccountBuid
        + selectedSessionToken=((BnetSessionDetails) ctx.getData(SELECTED_SESSION_DETAILS)).getSessionToken
        + rejectedSessionToken=BnetSessionDetails.getSessionToken
        + linkResolveGameAccount(Link a game account with a master account. Force keep the game account identified by the selected session token.)
        + 最后保存session details

        ~~如果你仔细看，就知道这里就有了SELECTED_SESSION_DETAILS和bnetsessiondetail的区别了,hhh~~
    + then **add audit note确认账号已link，更新bnet account state**
    + waitfor **Commit link to Blades account提交link** updateAccountLink（这里很奇怪，因为经验是之前都会绑定和device一起update）
    + waitfor **Get entitlements from BNET (works only if user has master account)** BnetAccountManager.tryUpdateAccountEntitlement（即获取权限，或者说获取Bnet权力）
    + waitif **Refresh刷新 the login token** bnetAccountProvider.getLoginToken
    + then **generate生成 session** authenticationHandler.generateSession;accountLinkResult.setSession(session);accountLinkResult.setLoginToken(loginToken);
+ then ()-> accountLinkResult
+ run()
(后面主要是调用不同的接口了，没有什么很迷惑的地方，我就直接贴了。)

---

linkBnetMasterAccount
link a master Bnet 账号和一个已认证过的用户。我们希望用户有一个game/anonymous account linked to blade account。
如果用户有第一方游戏账号，客户端提供第一方credentials以使我们获得游戏账号session token for linking resolve
可能credentials已经被另一个账号绑定，冲突会返回二者的id
无冲突就link，返回session。

斜体表示和上面不同的
BetAccountStatus有这几种：
NO_ACCOUNT：没有和blades account绑定的account
ANONYMOUS：blades account 和一个匿名B.NET account link
GAME_ACCOUNT：blades account和一个external(外部?)B.NET game account link
FULL_ACCOUNT：blades account和一个master B.NET account、一个或更多的game account link

ExecutorFactory启动
+ validate * 3 确认一波信息
+ waitfor 确认登陆细节
+ waitfor **检查有无冲突问题**。先用函数查到冲突的账号，id加进accountLinkresult中
+ *wait if **如果冲突，set login token** bnetAccountProvider.getLoginToken().recover()*
+ waitfor fixbnetAccountstatus
+ waitif 无冲突，新的一层ExecutorFactory
    + waitfor 取account、ExternalAccountId，向前者add audit note，saveAccount
    + waitfor 获取bnet session token
        + 第一个参数内：*直接返回，无需用bnetsessiondetailfuture做recover*
        + 取account，如果现在有一个bnet匿名账号，return .authAnonymous
        + *如果是一个game_ACCOUNT，则按传进来的平台扔loginGameAccount()*
        + 其他情况均succeededFuture，~~值得一提的是，这里的注释和之前一样，但是实际代码有些区别。~~后面的注释就正确了。

        + 第二个参数内：
        + *这里直接赋值给了selected_session_details，没有其他的任何操作。而linkFirstParty却是先判定null，中间还有个throw，最后才赋值。*
    + waitif **link game account if required，仅当user当前有master account时运行** *区别是没有recover*
    + then **add audit note确认账号已link，更新bnet account state** 完全一致
    + waitfor **Commit link to Blades account提交link** 完全一致
    + waitfor **Get entitlements from BNET (works only if user has master account)**  完全一致
    + waitfor **由于可能更改了session details，需要generate 新的login token** getLoginToken.recover
    *区别：不用ctx里的selected_session_details，而是用ctx的bnetsessiondetails* 老实说我不知道搞这种活有什么用
    + **generate session** 完全一致
    + run
+ then ()->accountLinkResult
+ run

---

linkForceFirstParty
将给的用户和外部账号link。发生冲突时，通过将账号与提供的用户id关联解决。
与第一方关联的所有外部账户从源账号转移到目标账号
Bnet account 和 两个blades account link，解决了选择账号

ExecutorFactory启动
+ validate * 3
+ then **一个可用的buid required to perform a first party link** validateBuid(userInfo)
+ waitfor **Validate signin details**
+ waitfor **检查冲突问题** *不同之处在于这里如果没有冲突账号会throw error"FIRST_PARTY_LINK_NO_RESOLVE_REQUIRED"，否则存下冲突账号*
+ waitfor fixbnetAccountstatus
+ waitfor **获取bnet session token** 这里和linkFirstParty几乎一模一样，区别是*当遇到no_account/game_account时， "throw an error as these are invalid states"*
+ waitif **登入BNET游戏账号if using 第一方credentials** gameAccountLoginExecutor.run
+ then **接上** accountForceLinkHandler.setup 第一个参数是target，第三个是source。初始化就是第一个用ctxAccount，第三个用刚才存下的冲突Account
+ waitfor * 2 **save audit notes to both accounts** saveAccount把刚才那俩都给存起来
+ waitfor **把source的account links转移到target中** transferExternalAccounts()，后面遍历link挨个存到数据库里
+ waitif **Link B.NET accounts if required** if shouldlink，linkResolveGameAccount.这里的link和正常的link区别是判断特别少，取双token也是从目标和源各取一个sessiontoken，建议自己对比一下。
+ waitfor * 2 又更新一遍数据库...."**Save our updated accounts in Dynamo DB now that the B.NET account has passed**"
+ waitfor **Get entitlements from BNET** target的，其他一致
+ waitfor **Update the gld version of target(kept) account with the source(ditched) account's GLD version if it is newer** 说白了用目标往源里更gld（注意顺序吧
+ **Refresh the login token** 完全一致，这里就用的ctx了
+ **Generate session for selected account** 如注释。

---

linkForceBnetMasterAccount
找茬开始了

这里就不写流程了，直接找不同。

前面一样
+ *在get b.net session token的时候，如果获取到的是game——account，3检查。最后如果是full、no则throw*
+ *不需要gameAccountLoginExecutor.run()*
+ transfer都一样，之后就出现了区别*会存了之后再link bnet，而之前是先link再存*
+ *refresh the login token的时候没有判断，不是用SELECT而是用ctx.BnetSessionDetails*注释写道:***Since we might have changed our session details we need to generate a new login token***这里倒是跟之前那个一样。


