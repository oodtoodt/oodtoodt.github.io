---
title: 面经-从零开始（
date: 2019-09-24 21:06:49
tags: 面试
---

我可能就是所谓的鼠目寸光、井底之蛙吧

---
<!--more-->

## 58

直接去世

### 一面

强行问了问项目，本来就没什么，问计算器实现，怎么处理表达式，然后问了点算法，图上的最短路和迷宫的最短路，问一些点怎么都扩起来。有些紧张，没把东西表达好。
然后就是令人窒息的计网和操作系统，问完了我基本上就死亡了

#### 怎么把一些点括起来

凸包呗。凸包可想象为一条刚好包著所有点的橡皮圈。用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边型，它能包含点集中所有的点。
Graham扫描法
就用个栈，不断判断栈顶的两个点连的线与下一个点在左右，右说明栈顶不是凸包的点，左继续进栈
判断c是否在直线ab的两侧（一个大矩阵）[[x1,x2,x3],[y1,y2,y3],[1,1,1]]
若上式为正，在左侧，为负在右侧，0则在直线上

#### 为什么数据库选择b+/b树而不是红黑树

B树查找平均
B树高度小 磁盘io小（树的深度过大会造成磁盘IO频繁读写）【存储在内存中才会使用的数据结构】
局部性原理 
B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来

#### tcp如何保证传输有序

TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等
其实就是如果来了乱序的就排个序

#### c++在openfile的时候，文件指针指的是什么

文件指针指向的是一个结构体的地址。
在上述结构体中，有个叫_fileno的核心成员，该成员就是由open()获得的文件描述符（它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。打开文件时系统向进程返回的一个文件描述符）
标准IO函数fopen()本质上也是对系统IO的封装

#### 多线程有了解吗
不了解。
见另一篇。

#### 数组为什么比链表快

首先数组是连续的，CPU缓存会把一片连续的内存空间读入， 因为数组结构是连续的内存地址，所以数组全部或者部分元素被连续存在CPU缓存里面， 平均读取每个元素的时间只要3个CPU时钟周期。 而链表的节点是分散在堆空间里面的

## 盛趣

盛趣就很神秘了。且不谈为什么只有一面+hr面，我一面的时候基本上都在附和，在被动的接受和被引导，莫名其妙的就进了人生第一次hr面，也许是自己是比较早的，占了一个先机？不过机会不大。
哦，一面的问题也很神秘。

### 一面

就特别神秘。
数组的复杂度？vector的复杂度？

#### vector有一个容量，每次超过了都会翻倍容量复制一遍对吧，那么我当前有N个数和一个空的vector，你要复制多少次呢
正着推了一个2^n-1，给了些提示，后来看我思路实在不对，就问你猜一个，盲猜2n，就明着来了。说每次其实都是由上一次的一半构成，那么你这么一算n/2+n/4…+n/2^n那么其实=2^n-1/2^n=1对吧

#### 一个非常神秘的点集问题
##### 给你一些一维的点，如何求[a,b)闭集上的点有哪些 有序怎么做 无序怎么做
我当时直接说的二分，其实大概是直接找就行的吧

##### 如果变成二维呢
先说按这个正方形左下角建一个坐标系然后挨个点查，然后提示下又滚回刚才二分的操作。

##### 那么这是一个近似的解对吧，我们如何优化这些近似，或者说有O(1)的算法吗
这里的O(1)很可能是指我二分的logn而言的，其实大概一个是O(n)一个是O(nlogn)？可惜我当时听了之后直接人都傻了。
直接遍历点刨除某些点就行？
不懂——到现在都觉得特别迷。

#### 迭代器失效的本质是什么
当时答，erase就会失效。面试官非常婉转的告诉我，如果有一个指针，new了一个对象，然后delete掉了，那么会不会失效？会的。为什么还需要迭代器来模仿一个本来就存在的事件？（意思就是你说的是对的，但是是p话）

向容器中添加或者删除元素的操作可能使指向容器的指针、引用、迭代器失效。一个失效的指针、引用、迭代器将不再表示任何元素。

在向容器添加元素后，如果储存空间未重新分配，指向插入位置之前的元素的迭代器、指针、引用有效，但指向插入位置之后的将会失效。
在从容器删除元素之后，指向被删元素之前元素的迭代器、引用、指针仍有效。尾后迭代器也就失效。
所以对容器进行操作之后，对迭代器需要更新。

##### 或者这个问题是 迭代器的本质是什么
把标志控制的循环和计数控制的循环统一为一种控制，即迭代器控制，每一次迭代操作中对迭代器的修改就等价于修改标志或计数器
容器迭代器：类似于数据库中的游标（cursor）,屏蔽了底层存储空间的不连续性，在上层使容器元素维持一种“逻辑连续”的假象。

#### 有序数组，分析一下快排的复杂度？
一通操作啥都没分析出来，当时对partition真的是思路不清了，就应和着下去了。（越说越觉得凉）
N^2，因为变成了一条链，深度是N而不是logN了。

##### 如何变快？就如何优化掉这个N？
小数组切成插入排序（我只记得这个了
随机化快排（从中间开始）
三数取中（类似中位数的思想）
三向切分（针对大量重复元素数组而言）
优化递归（并不是重点）

#### TopK怎么解？
堆 更好的呢？ partition

##### 那么这个partition的复杂度怎么样？
首先了解partition的原理
取 a[l] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。
假设每次都会是二分，则是n/2+n/4+n/8+…不超过2n和vector那个一样。

#### 蚂蚁对爬问题
##### 撞到就回头，最后掉下去，问你都掉下去，要撞多少次？
答不出，苦思

##### 各种提示，问题最开始要先想什么？
答简化问题，化成小问题
实则是先从最简单的情况想一想，找一找规律

##### 结论
对爬问题的关键在于分析出撞到和没撞实际上是一样的。想到了就是海阔天空。但是我当时却是在面试官的引导下找规律推出来的….
哎

### hr面

瞎聊。不过表达上还是有很多东西没表达出来。我还是更适合酝酿酝酿，事后尤其是自己本来就蛮有发言权／蛮有话说的那种话题我能想到不少可以说的，可惜当时没讲。
然后就是我太紧张，声音都变了，而且越说越嗡鸣。
重点大概还是你有什么经历，投了什么岗位，更在乎什么，加班的看法，对矛盾的处理之类的吧。

## 网易

同样有些神秘的体验。
先把我们聚集到一个小会议室里，以为要群面结果是各自写个二分的代码，分别去寻各自的面试官。
面试官都在各自的房间里，房间十分敞亮，外面是开阔的视野，正值3点的天明媚而有些刺眼。与面试官面对面相坐，那桌子是完全透明的，我没有仔细的观察他的房间，就投入了各种解决不出的问题之中。
四个问题就答出一个，第一个支支吾吾瞎jb扯，后面两个透露出对操作系统的不熟、对面向对象编程的不熟等等。
面试官还不错，就是我有点紧张。
hr面就那样，瞎聊。

### 二面

#### 迷宫问题

迷宫问题有啥，不就是bfs吗？

##### 进阶优化

如果这个地图很大，有什么办法对bfs优化吗？其实58问过，我当时没放在心上还以为答得不错。

	双向bfs


	A * 算法（以及迭代加深的ida * ）

A * 算法的关键在于启发函数，启发函数的优劣直接影响A * 算法的效率。          f(n)=g(n)+h(n); 
一般的（简单的），我们选用曼哈顿距离作为启发函数。

##### 高级操作
如果当前的地图非常巨大，但是可以允许预处理的操作，要怎么做？
>影响计算寻路路径的不是时间，而是计算路径所需的上百个单元格所占的空间。寻路是需要内存来运行寻路算法，还需要额外内存来存储寻到的路径。运行寻路算法（A*,开集或闭集）所需的临时空间经常会比存储这些寻到的路径所需的空间更大。通过在同一时间内只进行一条路径计算来限制游戏中的计算量，可以将你需要的临时空间降到最少。

	所以普遍的折中做法是服务器端只做近距离的寻路，或通过导航站点缩短A * 的范围。


	更优的算法：B * 算法
Bstart 算法原理： 一般寻路的方向 上、下、左、右
1、根据开始和结束2个点确定移动的方向
2、每走一步都需要确定一下方向
3、如果中途遇到有障碍物，根据当前位置和终点的位置，确定移动方向，变成2条线路
4、这2 条线交替向终点方向移动
5、如果中途又碰见障碍物了，继续分2个线，此时四条线交替移动
6、最先到终点的就是最终的路线；

几个比较模糊的思路：

	缩点
1）预处理：将地图按N * N大小划分区块，其中N为阻挡格数。找出每个区块与周围四个区块在边界上的互通点，然后在区块内使用Normal A * 对找出的点做连通性测试并将结果保存下来；

2）层次A * ：如果我们将预处理步骤中的区块作为Normal A * 算法中搜索的一个阻挡格，那么4096 * 4096大小的地图，当N=32时的搜索域将会降到128 * 128。在客户端执行寻路请求时，寻路线程使用预处理得到的数据，在区块一级做一次A * 找出路径经过的区块互通点，再在每个区块内使用Normal A * 得到互通点之间的路径，最终得到完整路径。

	优化A * 
JPS，事先处理出不能经过的（障碍）四周的点，联通成图后不断A * 


如此我们甚至可以步入更古怪的世界：路经压缩

总之更多的就不多再提了，已经蛮深的了，先这样吧（


#### 一个类扫描线问题...
给出多个玩家上线时间和下线时间（固定），他只能在这个区间里做任务，问，现在要查询某一个时刻有哪些玩家可以做任务，你来设计一下
说下我的设计，我就上线一个map，下线一个map，然后靠map会排序的特性瞎搞nlogn
##### 如果当前的这个时间无比精确，你有更好的想法嘛
##### 如果我这个时间非常长，几天几周，你有更好的办法吗
感觉面试官变来变去其实是想说不让用扫描时间的方式（不让用map的方式hhh）
这个我没怎么好好想就被面试官跳过去问下一个问题了。。。

#### cache的实现

只需要写需要什么函数就可以了。（那需要什么呢？）

cache是什么？是缓存。缓存是干什么用的？是用来使得重复访问不会每次都重查，那么这东西像什么？页面置换

LRU什么的搞一下啊。好歹有个这个思想吧。没有。知识并没有在这里串联起来。哭了。


#### 智能指针的实现

首先了解智能指针是什么，在非常清晰的理解了之后才好写出代码。

首先要实现引用计数类，然后实现指针类
放在一个里应该也可以

就是构造的时候初始化1，拷贝就++，赋值的时候左边--，右边++，析构的时候—，特判0时候删除域

##### 各种函数

当时脑子一壶就不记得拷贝构造函数怎么写了

```c++
class temp{
    private:
    //数据成员
    public:
    //成员函数
    temp(T *p){}
    temp(const temp &other){}//拷贝构造
    temp &operator=(const temp &rhs){}//重载运算符
    
    temp(temp &&t){}//移动构造函数
    temp &operator=(temp &&test)//移动赋值
        
    T &operator*(){}//解引用重载
    
    ~temp(){}
}
```



### hr面
印象比较深刻的就是会问你对游戏行业的理解，结果我说了我对游戏这个时长的理解，总有些答非所问。
我提问也是问的游戏行业的理解，人家就答的很在点子上。
别的基本上没啥，薪资啊，地点啊，处理矛盾啊，项目经验啊，未来规划啊，投过什么公司啊，之前的一些经历啊，就还有个比较扎心的如果把你安排到初级开发工程师你会怎么样的问题……

## 百度
直接去世呢
面试官人特好。无论从哪个方面来说都特好。
只是就我个人而言面试官说准备的不够充分，还指出了种种不足，我觉得都说的蛮对，以致于我最后没什么问题可问。

### 一面
「你精通c++啊，那么来问几个问题」
#### 说一下static的作用
全局静态变量在声明他的文件之外是不可见的
但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。
那么这个函数只可在本cpp内使用
对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。
##### 刷刷刷
写下一个没看懂也没记住的东西，问这是什么。不知道。
大概印象里应该是写了个函数指针？不过怎么跟static扯上关系的呢。

##### 嗯，那我这个东西要怎么赋值呢

画画画。一个静态类成员。

瞎答，死！

#### 那换一个，说下const的作用
（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；  
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；  
char * const p p指针不可更改
const char * p p内容不可更改
char const * p p内容不可更改
只修饰左边的，
（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；  （最后 () const{}这种)
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

差不多其实就行了，这个好像没啥

#### 实现一个智能指针
只写一下几个函数的实现就行了

思路理清楚：

构造为1，拷贝构造++，赋值的时候左边--，右边++，析构的时候—，特判0时候删除域

我tm再重复一遍，拷贝构造++。我要被蠢死了。当时脑子里是浆糊吗。

```c++
template<typename T>
class shared_ptr 
{
	T* m_ptr;
	size_t* ref_count = 0;

public:

	shared_ptr(T* ptr = nullptr);
	~shared_ptr();

	shared_ptr(const shared_ptr& other);
	shared_ptr& operator=(const shared_ptr& other);

	size_t GetCount();

	T& operator*();
	T* operator->();
};

template<typename T>
shared_ptr<T>::shared_ptr(T ptr)
	:m_ptr(new T(ptr)),ref_count(new size_t(1))
    {}

template<typename T>
shared_ptr<T>::~shared_ptr()
{
	if (--(*ref_count) == 0)
	{
		delete m_ptr;
		delete ref_count;
		m_ptr = nullptr;
		ref_count = nullptr;
		std::cout << "引用为0，调用析构函数" << endl;
	}
}

template<typename T>
shared_ptr<T>::shared_ptr(const shared_ptr& s_point)
{
	if (this != &s_point)
	{
		this->m_ptr = s_point.m_ptr;
		this->ref_count = s_point.ref_count;
		++(*this->ref_count);
	}
}

template<typename T>
shared_ptr<T>& shared_ptr<T>::operator=(const shared_ptr& s_point)
{
	if(m_ptr == s_point.m_ptr)
	{
		return *this;
	}
	else
	{
		if (--(*ref_count) == 0)
		{
			delete m_ptr;
			delete ref_count;
			m_ptr = nullptr;
			ref_count = nullptr;
			std::cout << "引用为0，调用析构函数" << endl;
		}
		m_ptr = s_point.m_ptr;
		ref_count = s_point.ref_count;
		++(*ref_count);
		return *this;
	}
}

template<typename T>
size_t shared_ptr<T>::GetCount()
{
	return *ref_count;
}

template<typename T>
inline T& shared_ptr<T>::operator*()
{
	if (this->m_ptr)
	{
		return *m_ptr;
	}
}

template<typename T>
inline T* shared_ptr<T>::operator->()
{
	if (this->m_ptr)
	{
		return m_ptr;
	}
}
```

#### list,vector,map,unordered_map

##### 底层实现？

双向环状链表 ，数组，红黑树，哈希表（拉链法的）

##### 添加元素会发生什么？（都是怎么操作的？）

对于序列式容器（vector、deque、list），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。使用erase方法后，返回的是下一个有效的iterator。

往某个位置插入一个元素，则这个位置之后的元素都要后移，因此后面的迭代器都会失效；如果引起内存的重新配置，所有的迭代器都将失效。



对于关联容器（map，set），删除当前的iterator，仅仅会使当前的iterator失效

插入一个元素，并不会对其他的节点造成影响

##### 那么迭代器会怎样变化？

#### 你说你了解内存，那么我

画画画。

```c++
int main()
{
	vector<int> v;
}
```
这个东西放在栈区还是堆区？

一般的STL内存管理器allocator都是用内存池来管理内存的，所以某个容器申请内存或释放内存都只是影响到内存池的剩余内存量，而不是真的把内存归还给系统。这样做一是为了避免内存碎片，二是提高了内存申请和释放的效率——不用每次都在系统内存里寻找一番。
真的让容器把不用的内存归还给系统的话，只能自己写一个allocator，并在容器的模板参数里使用它，而且STL的标准容器确实都留了这个接口。
不过要意识到这样做给程序性能和系统内存带来的影响。

##### 你来实现一个申请栈区的函数

画画画。比如说我现在有一个

```c++
char ch[1024*1024];
```

来，在这里申请内存。

不会。

##### new指定存储位置（placement new)

一般来说，使用new申请空间时，是从系统的“堆”（heap）中分配空间。申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这就是所谓的“定位放置new”（placement new）操作。 
定位放置new操作的语法形式不同于普通的new操作。例如，一般都用如下语句A *  p=new A;申请空间，而定位放置new操作则使用如下语句A *  p=new (ptr)A;申请空间，其中ptr就是程序员指定的内存首地址。考察如下程序。  


#### 如果我当前有一个整机存的下的数据
用什么存比较好？

##### 为啥不使用B+树？

嗯B+树更优秀一些。

啊不行，我写不下去了。


#### 来写个后序遍历非递归的形式

#### 来个树上最远两点距离

#### 现在有个人爬山，你来建个模
他从早上9点到晚上9点，从山脚爬到了山顶
睡了一觉。
又从早上9点到晚上9点，从山顶下到了山脚。
问，不确定速度的情况下，会不会在某一个时刻，站在同一个台阶上。
你来建个模

？？？

##### 不可教也
这里面几个变量？
我们可不可以用这些变量画二维图来观察关系？
那么时间一定是一维了，剩下的呢？画画画，x轴时间
y轴地点。好。那么你来画上山下山两条曲线。随便画。
那么？
有交点，说明什么？

问题的本质其实是相遇问题。
