---
title: 名词解释-1
date: 2020-04-16 15:05:16
tags:
---

什么是基础？这就是基础
<!--more-->

## http、tcp
http连接=以http协议为通信协议的tcp连接

http短连接=以http协议为通信协议的，请求一次就断开的tcp连接

http长连接=以http协议为通信协议的，请求多次才断开的tcp连接（这个是为了通过减少建立tcp连接的次数达到节省两端资源的目的）

tcp/ip和http都是协议是约定好的规范，他们位于网络5层模型的传输层（tcp）和应用层（http），tcpip表示的是一系列协议。规定好的协议总要操作系统实现了才能使用，而socket就是操作系统实现的，tcp/ip协议族的接口，用于创建一个套接字。
可以理解为，通过网络读写的文件描述符，socket、bind、listen、accept、connect一系列都是操作系统提供的接口用于实现tcp协议相关的功能。
tcp协议可以让两个进程通过三次握手建立稳定的通信信道，发送字节流，
而http协议建立在tcp协议之上，也就是说tcp协议可以让两个程序说话，而http协议定义了说话的规则。

作者：渣硕
链接：https://www.zhihu.com/question/39541968/answer/87821283
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

看了一圈，http确实就是tcp上层的东西，但是确实可以单独拿出tcp不用http来自己跑web

## 同步、异步、并发、并行、阻塞、非阻塞

>同步 不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，称这些程序单元是同步执行的。 例如购物系统中更新商品库存，需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的。 简言之，同步意味着有序。
>异步 为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式。 不相关的程序单元之间可以是异步的。 例如，爬虫下载网页。调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无需相互通知协调。这些异步操作的完成时刻并不确定。 简言之，异步意味着无序。 上文提到的“通信方式”通常是指异步和并发编程提供的同步原语，如信号量、锁、同步队列等等。我们需知道，虽然这些通信方式是为了让多个程序在一定条件下同步执行，但正因为是异步的存在，才需要这些通信方式。如果所有程序都是按序执行，其本身就是同步的，又何需这些同步信号呢？
>并发 并发描述的是程序的组织结构。指程序要被设计成多个可独立执行的子任务。 以利用有限的计算机资源使多个任务可以被实时或近实时执行为目的。 
>并行 并行描述的是程序的执行状态。指多个任务同时被执行。 以利用富余计算资源（多核CPU）加速完成多个任务为目的。 并发提供了一种程序组织结构方式，让问题的解决方案可以并行执行，但并行执行不是必须的

你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
最关键的点就是：是否是『同时』。

---
其实售票大厅更在意的是旅客一个一个的到窗口去买票，因为一次只能卖一张票。

即使大家一窝蜂的都围上去，还是一次只能卖一张票，何必呢？挤在一起又不安全。

只是有些人素质太差，非要往上挤，售票大厅迫不得已，采用排队这种形式来达到自己的目的，即一个一个的买票。

至于每个旅客排队时的状态，是看手机呀还是说话呀，根本不用去在意。

除了这种由于资源导致的同步外，还存在一种由于逻辑上的先后顺序导致的同步。

比如，先更新代码，然后再编译，接着再打包。这些操作由于后一步要使用上一步的结果，所以只能按照这种顺序一个一个的执行。

关于同步还需知道两个小的点：

一是范围，并不需要在全局范围内都去同步，只需要在某些关键的点执行同步即可。

比如食堂只有一个卖饭窗口，肯定是同步的，一个人买完，下一个人再买。但吃饭的时候也是一个人吃完，下一个人才开始吃吗？当然不是啦。

二是粒度，并不是只有大粒度的事物才有同步，小粒度的事物也有同步。

只不过小粒度的事物同步通常是天然支持的，而大粒度的事物同步往往需要手工处理。

比如两个线程的同步就需要手工处理，但一个线程里的两个语句天然就是同步的。

所谓异步，就是步调各异。既然是各异，那就是都不相同。所以结果就是：

多个事物可以你进行你的、我进行我的，谁都不用管谁，所有的事物都在同时进行中。

一言以蔽之，同步就是多个事物不能同时开工，异步就是多个事物可以同时开工。

注：一定要去体会“多个事物”，多个线程是多个事物，多个方法是多个事物，多个语句是多个事物，多个CPU指令是多个事物。等等等等。

阻塞和非阻塞
汽车可以正常通行时，就是非阻塞。一旦堵上了，全部趴窝，一动不动，就是阻塞。

因此阻塞关注的是不能动，非阻塞关注的是可以动。

两两组合
所谓同步/异步，关注的是能不能同时开工。

所谓阻塞/非阻塞，关注的是能不能动。

通过推理进行组合：

同步阻塞，不能同时开工，也不能动。只有一条小道，一次只能过一辆车，可悲的是还TMD的堵上了。

同步非阻塞，不能同时开工，但可以动。只有一条小道，一次只能过一辆车，幸运的是可以正常通行。

异步阻塞，可以同时开工，但不可以动。有多条路，每条路都可以跑车，可气的是全都TMD的堵上了。

异步非阻塞，可以工时开工，也可以动。有多条路，每条路都可以跑车，很爽的是全都可以正常通行。

是不是很容易理解啊。其实它们的关注点是不同的，只要搞明白了这点，组合起来也不是事儿。

回到程序里，把它们和线程关联起来：

同步阻塞，相当于一个线程在等待。

同步非阻塞，相当于一个线程在正常运行。

异步阻塞，相当于多个线程都在等待。

异步非阻塞，相当于多个线程都在正常运行。


## WebSocket(阮大)
初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？

答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。

举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。

这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用"轮询"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。

轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。

WebSockets是一项网络技术，它允许HTTP服务器和HTTP客户端（通常是浏览器）之间的全双工套接字式连接。

## HTTP（阮大）
主要是看到HTTP2.0，感觉需要过来解释一些
### HTTP1.0
#### 请求格式
```h
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```
第一行请求，必须在尾部添加协议版本，后面多行头信息，描述客户端情况

#### 回应格式
回应的格式是"头信息 + 一个空行（\r\n） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。
```html
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```
常见的Content-Type字段的值总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。
比如`test/html; charset=utf-8` （加了参数

#### 缺点
HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。
TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。
为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。

### HTTP1.1
1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。
客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。


1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。


使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。
对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。
因此，1.1版规定可以不使用Content-Length字段，而使用"分块传输编码"（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。
每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。
```html
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0
```

1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。


另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。
```html
Host: www.example.com
```
有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。

#### 缺点
虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。

### HTTP/2
注意他不叫HTTP/2.0，因为下个版本就是HTTP/3

#### 二进制协议
HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。

#### 多工
HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。

这样双向的、实时的通信，就叫做多工（Multiplexing）。

#### 数据流
因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

#### 头信息压缩
HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

#### 服务器推送
HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

## SSL/TLS(阮大)
不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。

（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。
（2） 篡改风险（tampering）：第三方可以修改通信内容。
（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

>但是，这里有两个问题。
（1）如何保证公钥不被篡改？
>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
（2）公钥加密计算量太大，如何减少耗用的时间？
>解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

因此，SSL/TLS协议的基本过程是这样的：

（1） 客户端向服务器端索要并验证公钥。
（2） 双方协商生成"对话密钥"。
（3） 双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。

具体过程请看：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html

## h2c
字符串“h2”标识HTTP/2使用传输层安全性（TLS）`[TLS12]`的协议。 此标识符用于TLS应用层协议协商（ALPN）扩展`[TLS-ALPN]`字段以及识别TLS上的HTTP/2的任何地方。 “h2”字符串被串行化为一个ALPN协议标识符，作为两个八位字节序列：0x68,0x32。

字符串“h2c”标识在明文TCP上运行HTTP/2的协议。 该标识符用于HTTP/1.1升级头字段和任何标识HTTP/2 TCP的地方。 “h2c”字符串是从ALPN标识符空间中保留的，但描述了不使用TLS的协议。 谈判“h2”或“h2c”意味着使用本文档中描述的传输，安全，成帧和消息语义。
————————————————
版权声明：本文为CSDN博主「The_Hungry_Brain」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u010129119/article/details/79361949

## RFC
Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。
想要清晰透彻的了解协议，最好通读一遍协议本身。


## frame
以往的HTTP，我们习惯了和head /body 打交道。而在HTTP2，取而代之的是幀（Frame）。它将会成为协议中的最小通讯单位——所有的数据，head，body都会打包到Frame内发送。Frame 有很多类型，比如 header frame, data frame （以后...，不本文就会继续讲到）。