---
title: 训练专题

date: 2018-08-29 16:47:45

tags:
 - shujia

categories:
 - acm

---

持续更新区域赛的题。。大概会更新的吧。咕咕咕

<!--more-->
---

*2018-09-05 Wed 00:14 *更新到第22次训练



---

# 暑期训练

## 第一次训练。

emmm 08年的题感觉还是比较容易的。

我还没拿到题琦神就已经看出A题是水题了，裸的上升子序列。

在lyy手写板子的时候我看出i题是个水题，求抛物线最大值的b/2a....之后顺利切掉。

然后lyy去切了b题的fb，大体意思求1w个小于1w的数中，四四gcd为1的数量。lyy直接莫比乌斯反演。这题我以后可以补一下。（凉了）

e题就是求凸多边形的面积，虽然题意极其zz，但是毕竟是简单板子，lyy大佬10m敲好。

然后一开始以为f题是裸的并查集，结果发现有一个并查集的去除一个点的操作，结果被暴力o(n)给水过去了。。令人窒息。正解应该可以o(1)的，没卡。大体就是不动那个被去除的点，而是用离散化的那种方式把他指向新的点。

h题看都没看，就被琦神切了。

看了很久的c，总觉得别人都过了我们没过哪里不对。征得琦神的认可后照着二分图板子抄了一会，发现结束了=。=明明才做了三个半小时！

回去补c，b题可以回头看，h，d和g了解一下就行了。大佬带飞啊，没什么压力。

写完了发现不是二分图最大匹配啊。有问题。

然后搜了一下发现是模板题啊。

------

### 2 - sat

sat是逻辑学术测验！（口胡）
是Satisfiability问题，通俗地说就是是否可以有满足所有条件的方案？2-sat即为最多含有两个元素的集合。
可以用o(nm)的染色法，求出字典序最小的解。下面是o(m)求任意解的解法。
算法过程如下：
tarjan缩点，反向存边，拓扑排序，构造方案。
缩点很好理解：一个强连通分量里的点被选中一个就相当于全部被选中
反向存边，其实也算好理解，

> 若图中存在边< i, j >，则表示若选了i必须选j。可以发现，上面的9种限制关系中，后7种二元限制关系都可以用连边实现，比如NOT(A[x] AND A[y])需要连两条边< x, y' >和< y, x' >，A[x] OR A[y]需要连两条边< x', y >和< y', x>。而前两种一元关系，对于A[x]（即x必选），可以通过连边< x', x >来实现，而NOT A[x]（即x不能选），可以通过连边< x, x'>来实现。
>
> > 简单的说，有这么几种情况：ab不能同时取；不能同时不取；要么都取要么都不取；a和a'必取a。

下面几道例题。（其实只有一道，另外后面还有一道）

------

##### poj3905

我们做的那道题。意思是有一些人在选举，这些选民在某些人选上或没选上的时候会高兴，给出每个人要求的二元组，问有没有满足所有这些人的情况？

```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<set>

using namespace std;

const int maxx=10005;
int n,m,k;
int a[maxx];
int ans = 0,cnt = 0,pos = 0;
int l = 0,r = 0;

const int MAXN = 2005;
const int MAXM = 2500010;
struct Edge {
    int to,next;
}edge[MAXM];
int head[MAXN],tot;

void addedge(int u,int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}
int Low[MAXN],DFN[MAXN],Stack[MAXN],Belong[MAXN];//belong:1~scc
int Index,top;
int scc;
bool Instack[MAXN];
int num[MAXN];

void init(){
    tot = 0;
    memset(head,-1,sizeof(head));
    
    memset(DFN,0,sizeof(DFN));
    memset(Instack,false,sizeof(Instack));
    memset(num,0,sizeof(num));
    memset(Belong,0,sizeof(Belong));
    Index = scc = top = 0;
}

void Tarjan(int u)
{
    int v;
    Low[u] = DFN[u] = ++Index;
    Stack[top++] = u;
    Instack[u] = true;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        v = edge[i].to;
        if(!DFN[v]){
            Tarjan(v);
            if(Low[u] > Low[v]) Low[u] = Low[v];
        }
        else if(Instack[v] && Low[u] > DFN[v])
        Low[u] = DFN[v];
    }
    if(Low[u] == DFN[u])
    {
        scc++;
        do{
            v = Stack[--top];
            Instack[v] =false;
            Belong[v] = scc;
            num[scc]++;
        }
        while(v != u);
    }
}
int solvable(){
    for(int i = 1; i <= n*2; i++)
    {
        if(!DFN[i]) Tarjan(i);
    }
    for(int i = 1; i <= n; i ++){
        if(Belong[i] == Belong[i+n])
        return 0;
    }
    return 1;
}
queue<int> q1,q2;

int main()
{
#ifdef LOCAL
    freopen("/Users/ecooodt/Desktop/c++ and acm/_集训2/sp_1/c.txt","r",stdin);
#endif
    freopen("c.in","r",stdin);
    while(~scanf("%d%d",&n,&m))
    {
        init();
        for(int i = 0; i < m; i++)
        {
            int a,b;
            scanf("%d%d",&a,&b);
            int aa = abs(a),bb = abs(b);
            if(a > 0 && b > 0)
            {
                addedge(aa+n,bb);
                addedge(bb+n,aa);
            }
            else if(a < 0 && b < 0){
                addedge(aa,bb+n);
                addedge(bb,aa+n);
            }
            else if(a > 0 && b < 0)
            {
                addedge(bb,aa);
                addedge(aa+n,bb+n);
            }
            else if(a < 0 && b > 0)
            {
                addedge(bb+n,aa+n);
                addedge(aa,bb);
            }
        }
        ans = solvable();
        printf("%d\n",ans);
    }
    return 0;
}
```

----

## 第二次训练。

我tm，写了好久的丢了。

这次训练只有我和琦神。

琦神先切了G题，中间遇到了一点小问题，被顺利解决。
题意是给出一定数量的火柴棍，要求用尽所有火柴棍问能摆出的最大和最小数字分别是多少。主要是最小数字。起初我以为在后面必然是0或8，后来发现10的情况就是22，那么后面应该也会有这种情况。
琦神用第一位特判，后面的分情况直接暴力出来了。
挺考验代码和思维能力的，我后来写了下，基本上就是琦神那样的代码了。

然后我做了C题。C题意思是有一些猫狗爱好者，如果是猫爱好者必然会讨厌狗。猫爱好者会想留下一只猫并且想扔掉一只狗（给出对应序号），狗爱好者同理。起初我们当然会想到昨天做的2-sat问题，显然这里有一些关联但是并不大，因为不满足「有满足所有条件的解」以及「存在逻辑关系，如不选a就要选b」这样的，所以不是2-sat问题。
用猫狗建图会陷入误区之中，因为猫和狗是没有关系的，或者说有过于复杂的关系（对于每个爱好者来说都会向不同的猫狗间连线）
应该用爱好者建图。这时关系很显然，有冲突者连线，则猫爱好者和狗爱好者会在二分图两边，这时求最大独立集（任意两个顶点不相连的集合）即是答案。

B题意思是有一些证明，可以通过成环或者证明之间相互包含（相互证明）来验证其正确性，问给出一些证明关系，应该加入多少证明使得所有证明成立。
把证明视作点，证明关系视作边，则容易看出是问加入多少条边使得图强连通。
稍微讨论了一下，琦神就发现答案必然是缩点后出度为0的点，后来稍稍思考了一下，答案是出度和入度为0的点中数量最大的那一个。正确性显然，如果强连通则强连通内所有点入度出度均不为0。
但是还是wa了两发，发现存在一个点的情况自身就是强连通（自己为真），但是因为入度出度均0答案会出1，特判后还是wa，我去写D题，琦神很快找到问题所在：强连通缩成一个块后没有入度出度，相当于一个点的情况，特判后就过了。
tarjan我写的很少，这个题我还是要写一下的。

D题是扩展欧几里得问题。
有这样一个式子
$$
x_i = (a · x_{i−1} + b)\ mod\ 10001
$$
给出x1,x3,x5...x_2T-1，要求x2,x4....x_2T。
根据式子可以得出：
$ x_3 + 10001k= a^2 x_1 + (a+1)b $
$ x_3 - a^2 x_1 = -10001k + (a+1)b $
左右调换即是扩展欧几里得的形式。
写的时候没有注意ll，一直在爆。而且忘记了系数不能为负。
注意求的时候只需要求一个整数解而没有求其所有整数解。对于这个题来说，b = b0 + 10001k，而更新b的时候是b = b0 - 10001/d....又因为整数，所以其实求出来的b = b0 - 10001 * k 模一下就是b = b0。

I题计算几何模板题……？被琦神随便就过了。。
回头去看一下吧。

J题怼了好久，有点没把握好时间复杂度。
问题意思就是给你一串数，问有几种循环出现的情况，是否有冲突。
举例来说：3441321234，就只有一种循环方式，第一个44出现的时候就说明必然中间分开，1重复出现的时候必然就是这一段的循环。
起初没理解题意，在琦神的帮助下大概了解了。
通过每个重复出现点给出的信息（44就是说只有一种，如果434就有两种可能，可以排除另外的两个可能）——来依次缩小整个答案的范围。
代码很简单，就求每个数上一个出现位置(l)和这个出现位置(r)，然后可以直接映射（也可以不映射）% n到0～n-1区间中，把0-l,r-n或者r-l之间的元素更新为不可以的起始点。
>复杂度十分奇怪。可以发现在整个更新过程中似乎只访问了(n-区间长)的个数，算起来的话复杂度应该是区间个数 * (n-区间长) = n * 区间个数 - 区间个数 * 区间长，sum _ 区间个数 * 区间长度 = n，大概一看的话好像是n^2的复杂度啊，怎么都感觉很迷。

假装o(n)好了。
这个题还有o(n)（确切）的解法，是滑动窗口（尺取法！）。可以放到对应的专题里做。
这里就不展开讲了。


A题二叉树 E题动归 F经典floodfill搜索 K不知道是啥。

----

## 第三次训练。

可以说是lyy单打了。我毫无作为，甚至拖了后腿。

B题交互式问题，看了很久眼看着别人都过了自己不会，扔给lyy去写了。

G题阅读题，拼一些块，使得满足条件。只有横过来和竖着两种形态。我连wa2两发。

H题暴力贪心

I题模拟

J题暴力。。。问给出一些文字，能否通过一种一一映射，使得映射过的文字元音和辅音相隔？就枚举26^5*26^2然后优化。



回去补题，这次被老板叫去安排后续计划了，没什么时间补了，补个交互式问题好了。

### 交互式问题：

大概就是你先给出一个输出，系统会告诉你正确与否这样。也就是说，正确与否取决于你的输出，这时候你的输出变成了输入....

上题。

cf680c

你去猜[2,100]中的一个数是不是质数。每次你可以给出一个数，系统会给你这个数是不是现在正在猜的这个数的因子。

比如系统这个数是30，那么你猜2，5，15，都会回答yes，而17则会回答no。

要求在20条询问内得到结果。

因为要20条询问，那么可以先缩一次范围，用2、3、5、7试一下是否是因子，如果没有就是素数，如果有大于2个就不是，如果是1个接着枚举19次质数是否还是因子，最大能得到大于100的质因子只有两个的这种数。质因子大于两个的一定被两个的情况包含（都不是质数），如果这样的判断之后依旧全no，那么一定是质数。

注意尽量不要排除某种情况，比如试过2357之后依然还要试2357就只能用4、9、25、49这样代替，其余同理。

```c++

    /*
      ID: oodt
      PROG:
      LANG:C++
    */
    #include<iostream>
    #include<algorithm>
    #include<cstdio>
    #include<cmath>
    #include<string>
    #include<cstring>
    #include<map>
    #include<vector>
    #include<queue>
    #include<stack>
    #include<set>
    
    using namespace std;
    
    const int maxx=10005;
    int n,m,k;
    int a[maxx];
    int ans = 0,cnt = 0,pos = 0;
    int l = 0,r = 0;
    int vis[105];
    string ss;
    
    const int MAXN=10000;
    int prime[MAXN+1];
    void getPrime()
    {
        memset(prime,0,sizeof (prime));
        for(int i=2;i<=MAXN;i++)
        {
            if(!prime[i] )prime[++prime[0]]= i;
            for(int j=1;j<=prime[0]&&prime[j]<=MAXN/i;j++) {
                prime[prime[j]*i]=1;
                if(i%prime[j]==0) break;
            }
        }
    }
    
    int tryf(int d)
    {
        cout<<d<<endl;
        fflush(stdout);
        cin>>ss;
        return ss[0] == 'y';
    }
    
    int main()
    {
    #ifdef LOCAL
    //    freopen("","r",stdin);
    #endif
        getPrime();
        int t = 0;
        int fk = 0;
        for(int i = 1; i <= 4; i++)
        {
            if(tryf(prime[i])) {
                vis[i] = 1;
                t++;
            }
        }
        if(t > 1)
        {
            printf("composite\n");
            fflush(stdout);
        }
        else if(t == 0){
            printf("prime\n");
            fflush(stdout);
        }
        else {
            for(int j = 1; j <= 4; j++)
            if(vis[j])
            for(int i = 1; i <= 19; i++){
                if(prime[i]*prime[j] >= 100) break;
                if(tryf(prime[i]*prime[j])){
                    printf("composite\n");
                    fflush(stdout);
                    fk = 1;
                    break;
                }
            }
            if(!fk){
                printf("prime\n");
                fflush(stdout);
            }
        }
        return 0;
    }



#### gym 100286B

一个瞎子在迷宫里走，你给出走的方向，系统告诉你是墙还是空白。要求把迷宫的空白全部走一遍，并且迷宫大小n * m(0<n,m<31)这样。

基本上就是dfs，然后每次注意继续走直到访问过所有空白块。注意每次dfs之后要返回原位置为了跑别的方向的dfs。

只要数组稍微开的大一点就行。

    /*
      ID: oodt
      PROG:
      LANG:C++
    */
    #include<iostream>
    #include<algorithm>
    #include<cstdio>
    #include<cmath>
    #include<string>
    #include<cstring>
    #include<map>
    #include<vector>
    #include<queue>
    #include<stack>
    #include<set>
    
    using namespace std;
    
    const int maxx=100;
    int n,m,k;
    int a[maxx];
    int ans = 0,cnt = 0,pos = 0;
    int l = 0,r = 0;
    
    int dx[4] = {0,-1,0,1};
    int dy[4] = {1,0,-1,0};
    string s[4] = {"NORTH","EAST","SOUTH","WEST"};
    int vis[maxx][maxx];
    string ss;
    
    int move(int d)
    {
        cout<<s[d]<<endl;
        fflush(stdout);
        cin>>ss;
        return ss[0] == 'E';
    }
    void dfs(int x,int y)
    {
        vis[x][y] = 1;
        for(int i = 0 ; i < 4; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(!vis[nx][ny] && move(i) ){
                dfs(nx,ny);
                move((i+2)%4);
            }
            else vis[nx][ny] = 1;
        }
    }
    
    
    int main()
    {
    #ifdef LOCAL
    //    freopen("","r",stdin);
    #endif
        int x = 50,y = 50;
        dfs(x,y);
        printf("DONE\n");
        fflush(stdout);
        return 0;
    }

```
#### Gym 101021A

猜1-1000000内的数。其实这个应该做入门题。直接二分，判断就用交互就行了。
```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<set>

using namespace std;

const int maxx=10005;
int n,m,k;
int a[maxx];
int ans = 0,cnt = 0,pos = 0;
int l = 0,r = 0;
char s[maxx];


int ok(int mid)
{
    printf("%d\n",mid);
    fflush(stdout);
    scanf("%s",s);
    return s[0] == '>';
}

void erfen()
{
    int mid;
    while(l<=r)
    {
        mid = (l + r) / 2;
        if(ok(mid))
        {
            l = mid + 1;
        }
        else
        {
            r = mid - 1;
        }
    }
    l--;
}


int main()
{
#ifdef LOCAL
//    freopen("/Users/ecooodt/Desktop/c++ and acm/special--专题/9-strange/interactive/gym101021a.txt","r",stdin);
#endif
    l = 1,r = 1000000;
    erfen();
    printf("! %d\n",l);
    return 0;
}

```

#### cf680c
给你一个2-100的数字,让你查询不超过20次判断是素数还是合数

```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<set>

using namespace std;

const int maxx=10005;
int n,m,k;
int a[maxx];
int ans = 0,cnt = 0,pos = 0;
int l = 0,r = 0;
int vis[105];
string ss;

const int MAXN=10000;
int prime[MAXN+1];
void getPrime()
{
    memset(prime,0,sizeof (prime));
    for(int i=2;i<=MAXN;i++)
    {
        if(!prime[i] )prime[++prime[0]]= i;
        for(int j=1;j<=prime[0]&&prime[j]<=MAXN/i;j++) {
            prime[prime[j]*i]=1;
            if(i%prime[j]==0) break;
        }
    }
}

int tryf(int d)
{
    cout<<d<<endl;
    fflush(stdout);
    cin>>ss;
    return ss[0] == 'y';
}

int main()
{
#ifdef LOCAL
//    freopen("","r",stdin);
#endif
    getPrime();
    int t = 0;
    int fk = 0;
    for(int i = 1; i <= 4; i++)
    {
        if(tryf(prime[i])) {
            vis[i] = 1;
            t++;
        }
    }
    if(t > 1)
    {
        printf("composite\n");
        fflush(stdout);
    }
    else if(t == 0){
        printf("prime\n");
        fflush(stdout);
    }
    else {
        for(int j = 1; j <= 4; j++)
        if(vis[j])
        for(int i = 1; i <= 19; i++){
            if(prime[i]*prime[j] >= 100) break;
            if(tryf(prime[i]*prime[j])){
                printf("composite\n");
                fflush(stdout);
                fk = 1;
                break;
            }
        }
        if(!fk){
            printf("prime\n");
            fflush(stdout);
        }
    }
    return 0;
}
```

---

## 第四次训练。

琦神中途去宣讲（？还是啥，开组会）了，后面我们基本在摸。

这次。数学专场吧。

A题，计算$S_n = \sum^n_{k=1}[\frac{(3k+6)!+1}{3k+7}-[\frac{(3k+6)!}{3k+7}]]$

琦神：观察可得规律，当p为素数时才满足Sn+1。
我后来百度了一下，这叫威尔逊定理。即：当且仅当p为素数的时候，(p-1)! = -1 (mod p)，所以只有3k+7是素数的时候，才有1的结果。
那就直接筛1000000以下素数跑3k+7的sum就行了。

B题，给出一些城市的高度，给出每次海平面上升到的高度，问有多少个连通块还没有被淹没
我看了很久以为tm的有什么数据结构能跑logn的更新和查询。

C题扩欧，非常经典。

D题

E题

F题矩阵

G题水题。但是搞了个后缀非常诱人（通过后缀数组求原串hhh）实际上就是通过原串的顺序看每个位置和他后一个位置的每个后面那个原串中比较，随便乱搞就行。

H题

I题扩欧。
>给出一个树的形状，现在为这棵树标号，保证根节点的标号值比子节点的标号值大，问有多少种标号树。
>解题思路：和排队的思路一致的是uva11174,最后问题只和树德结构有直接关系，f(root)=(s(root)−1)!/(s(1)∗s(2)∗⋯∗s(n))

首先我们来看uva11174。
题意：村里有n个人，给出父亲与儿子的关系，问有多少种方式可以把他们拍成一列，使得没人会排在其父亲的前面。
>换个模型，先将森林变成一棵树，这样就直观多了，对于一个节点，他的子节点排列时没有任何要求，而子排列中会有限制，将这些限制先提取出来，就可以将所有的视为相同的。然后就是有重复元素的全排列问题。
>
>设f(i)是以节点i为根的子树的排法，即节点i有儿子c1,c2,c3...cj共j棵子树。如果分别先给各个子树内部排序，那么毫无疑问共有f(c1) * f(c2) * f(c3) ... * f(cj)种情况。
>
>设s[i]为树根为i的子树包含的节点数。然后把每棵子树的所有节点看成同一元素，根据有重复元素的全排列方式共有s(i-1)!／(s(c1)! * s(c2)! * … * s(ck)!)
>
>

J题kd-tree裸题

---

## 第五次训练。

有点惨，只出了4题。

A题题意很简单，对任意一对查询，在一个图里找到一条最大边最小的路。

琦神开的。首先为了保证取的最大边最小，跑一遍最小生成树。

琦神：「跑出树形之后就很简单了，树一定有根，那么就把两个点都向根部跑，如果相遇了就直接取最大值」大体就是这样了。往最小生成树里加根的代码我还真不怎么会。。学习一波。不过要用prim，用kruskal的话跑出来的pre数组不一定是树上的。

贴下琦神代码吧，这题虽然放在区域赛是水题但我自己的话真不一定能写出来。

```c++
int prim(){
       int mini[MAXN],ret=0;
       int v[MAXN],i,j,k;
       for (i=0;i<n;i++)
              mini[i]=inf,v[i]=0,pre[i]=-1;
       for (mini[j=0]=0;j<n;j++){
              for (k=-1,i=0;i<n;i++)
                    if (!v[i]&&(k==-1||mini[i]<mini[k]))
                            k=i;
              for (v[k]=1,ret+=mini[k],i=0;i<n;i++)
                     if (!v[i]&&mat[k][i]<mini[i])
                            mini[i]=mat[pre[i]=k][i];
       }
       return ret;
}

			query[x]=max(1,query[x]);
            while(pre[x]!=-1)
            {
                query[pre[x]]=max(query[x],mat[x][pre[x]]);
                x=pre[x];
                //printf("%d %d %d\n",x,pre[x],mat[x][pre[x]]);
            }
            if(query[y]!=0)
            {
                printf("%d\n",query[y]);
                continue;
            }
            while(pre[y]!=-1)
            {
                if(query[pre[y]]!=0)
                {
                    printf("%d\n",max(query[pre[y]],max(query[y],mat[y][pre[y]])));
                    break;
                }
                query[pre[y]]=max(query[y],mat[y][pre[y]]);
                y=pre[y];
            }
            if(pre[y]==-1)printf("%d\n",query[y]);
```

B题

C题披着计算几何外衣（给出坐标系）的水题。就给出一些点的坐标(double)，每个点只会向斜上方的方块（0,0就1,1以上这样）连线，问连线的**曼哈顿**长度的平均值。

思路就是出自曼哈顿距离，所以可以把每个方块中的点简缩成一个点，然后直接求x * ty-y * tx，t就是数量因为斜上方所以保证了一定大于，就酱。

因为会爆int，所以wa了一发而不知所措=。=

D题

E题

F题

G题

H题

I题题意是给出多组a0-a9和a10，问是否存在N!=1，使得$（\sum_{i = 0}^{9}a_i） \% N = a_{10}$

扔给lyy大佬做了。具体的话，首先如果s < a10，那么肯定不行。其次如果s == a10那么答案必定大于s。最后s > a10，ans = 所有s - a[i]的gcd（且答案大于a10）。

判断一下情况，有没有前面答案小于或者上面第一种情况。

J题

---

## 第六次训练

么得题解（鸽了）

---

##第七次训练。

琦神又去开组会了，然后我们心不在焉的做了有史以来最惨的两题。当时我们基本上放弃了，lyy拿着电脑去打印模板啥的。。

A题就是水题，给出一堆排序的要求，排个序，加个贡献什么的...



B

C题题意就是要求将游戏机上一串A改变成想要的字母需要操作多少次左右箭头。字母连通，首尾连通。

其实很简单，我一开始没有意识到走法。就是先左后右或者先右后左，正着跑一遍的情况其实已经包含在里面了。

所以其实就几行的代码，我写了很久，改了很久，这次题少很大程度怪我。没有理好公式和方法。

D

E题意思是给出一个之前的排名和所有改变排名的数对，每一个数对(a,b)表示原先b在a前面而现在a在b前面。问最后确定下来的排名。观察可以发现，对于给出的数对，改变的一定只有1的权值。那么就好做很多了，直接按照每个查询+-1就行了。

lyy疯狂wa，应该是存在a > b的情况，并不是impossible。

F

G

H也是水题，就模拟交易，sell按低出，buy按高出，优先队列不断弹就行了。自己写的没什么问题，但是题读的有问题，初始化交易记录的地方写错了。卡了两个小时（后来自己在宿舍写的）

I

J

---

## 第八次训练。

这次的题，意外的非常棘手（扎实）

BH水题不表。才不是我去晚了这两个题听都没听呢。

D题题意：给出一些串，所有串可以当成n * m的表格（由逗号分开），问是否有两行中存在两列相同的。n<10000, m < 10。我当时感觉无论如何都要防止n^2，然后就在想想想=。=然而没想到的是，lyy写完hash(极不信任map)想了想居然跑了个O(n^2 * m)然后过了。

1e9在600ms里过了。无法信任了！

I题题意：给出一张dag图，要求跑完所有边。每次跑不下去的时候可以重新选择起点，问最少选择的次数以及跑的路线。

首先琦神nb！

首先设超级起点和超级汇点，跑一遍上下界最小流。不过好像没有最小流的板子，有个上界下界的板子。我和琦神在lyy不能光看板子啊不能依赖板子啊要自己写啊的疯狂抱怨中研究出了最小流的写法，然后暴力跑一个dfs（这次是n^4！100^4！琦神嫌再写一个邻接表的dfs繁就跑的矩阵的。。）搜出所有路每次在流量上-1就行。



#### C题交互题

直接贴lyy的题解

https://vjudge.net/problem/Gym-101308C

一道很有意思的交互题

题意：

是给你一个1-n的排列，告诉你n(3<=n<=200)，然后你可以进行若干次（不超过2000次）询问，询问的格式是{P1,P2,P3}(三个数两两不相等),  意思是问排列中位置为P1,P2,P3的三个数大小在中间的那个数是多少，系统返回给你中间的那个数的值，最后你要确定最后的答案（答案可能不止一个，你只需找到解系中的任意一个解即可

样例和分析：

4 ： 1 2 3

2 ： 2 3 4

3 ： 1 2 4 

2 ： 1 3 4

3 ： ok 2 1 4 3 

先告诉你排列的长度为4，

你询问a1a2a3 中大小在中间的数是多少，返回结果为2

你询问a2a3a4 中大小在中间的数是多少，返回结果为3

你询问a1a2a4 中大小在中间的数是多少，返回结果为2

你询问中大小在中间的数是多少，返回结果为3

可以确定最终的结果2 1 4 3

分析：

对于n=3这种情况，我们知道不管怎么去询问，都会回答2，所以无法判断，解系是3个数的任意一组排列*

n>=4时，你是无法区分1和2，n和n-1，因为如果你的询问的位置上的数包含1和2，一定会返回2，如果询问位置上的数不包含1或者不包含2，那返回结果一定不是1和2。(n和n-1同理。)对于其它的数一定能判断，所以解系是一组特解然后可以将1和2，n和n-1互换位置。

那么如何确定每个数的位置呢?

我们可以采用生成随机询问的方法，如果询问是{P1,P2,P3}，返回结果是x，那么我们就可以判断x在P1,P2,P3位置中的一个，我们只记录x这个数可能的位置，如果多次返回了x我们就可以通过集合的并集确定x的位置。

**我们生成随机询问，保证P1,P2,P3这三个位置上的数之前都没有确定，我们先进行若干次询问，直到没有被确定的位置小于等于10（在n=200的情况下只需要400-450次询问即可）；然后我们对于剩下10个位置每三个数询问一次，共C_{10}^3= 120 次，这样除了1,2,n-1,n都可以确定了，然后再进行4次询问，确定1,2和n-1,n。**

---

## 第九次训练

大概也鸽了

两道水题。

C - 给出一个洞的上下界，问最多能储多少水（不能碰到上界）

从右到左扫一遍就能得到每一列的最高的水位，再从左到右扫一遍就行了

琦神nb

E - 两两匹配问题，即，

---

## 第十次训练。

4题可怜。

A题三分。三分一般用在有单一极值的地方。
补一下代码（lyy）学习一波。

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int n;
struct point
{
	double x,y;
}p[50005];

double f(double x)
{
	double ans=0;
	for (int i=1;i<=n;i++)
	{
		ans=max(ans,sqrt((p[i].x-x)*(p[i].x-x)+p[i].y*p[i].y));
	}
	//printf("%.1f %.1f\n",x,ans);
	return ans;
}

double find()
{
	double l=-1e9,r=1e9;
	double m1,m2;
	while (r-l>1e-9)
	{
		//cout<<l<<' '<<r<<endl;
		m1=(l*2+r)/3;
		m2=(l+r*2)/3;
		if (f(m1)>f(m2)) l=m1;
		else r=m2;
	}
	return (l+r)/2;
}

int main()
{
	while (~scanf("%d",&n) && n!=0)
	{
		for (int i=1;i<=n;i++)
		{
			scanf("%lf%lf",&p[i].x,&p[i].y);
		}
		double k=find();
		printf("%.8f %.8f\n",k,f(k));
	}
	return 0;
}

```

I题水题

B题阅读题，今天代码有点问题，怎么都在错。

J题就是对后缀数组的应用。琦神和lyy扔了大把时间在里面。

D题dp。
题意：AB玩飞镖。A随意扔，B瞄准扔到相邻3个区域中的一个。现在有n < 501分，问分别先手的获胜概率

> 用$dp[0][n][m]$表示当A剩余n分，B剩余m分时，A先手获胜的概率
> 用$dp[1][n][m]$表示当A剩余n分，A剩余m分时，B先手获胜的概率
>
> 那么当n和m都不小于20时有递推式
>
> $dp[0][n][m] =\sum_{i = 1}^{20}  \frac{1}{20}(1-dp[1][n-d[i]][m])$
> $dp[1][n][m] =max_{1<=i<=20} \frac{1}{20}\sum_{j = -1}^{1} \frac{1}{3}(1-dp[0][n][m-d[i+j]])$
>
> 从下向上递推，在n<d[i]和m<d[i+j]的时候跳过（其实就是空了一个回合）即可。

其实有了递推式就很简单了，问题是递推式是怎么来的。
$dp[0][n][m]$：当A剩余n分，B剩余m分时，A先手获胜的概率为扔到所有点的（1-B获胜概率）之和
$dp[1][n][m]$：当A剩余n分，B剩余m分时，B先手获胜的概率为B锁定所有点里面，对其胜率最大的，这个胜率是三个点的（1-A的胜率）之和。
我觉得这道题非常好，模型很优秀。

补一下代码

```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<set>

using namespace std;

const int maxx=10005;
int n,m,k;
int a[maxx];
int ans = 0,cnt = 0,pos = 0;
int l = 0,r = 0;
int dart[] = {20,1,18,4,13,6,10,15,2,17,3,19,7,16,8,11,14,9,12,5,20,1,18};
double dp[502][502][2];

int main()
{
#ifdef LOCAL
//freopen("","r",stdin);
#endif
    int n = 501;
    for(int i = 1; i <= n; i++)
    {
        dp[i][0][0] = 0;
        dp[0][i][1] = 1;
    }
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= n; j++)
        {
            double x = dp[i][j][0];
            double y = dp[i][j][1];
            //x = p0*y+q0;
            double q0 = 0,p0 = 0;
            for(int k = 0; k < 20; k++)
            {
                if(dart[k] > i) p0 += 1.0/20;
                else q0 += 1.0/20 * dp[i - dart[k]][j][1];
            }
            y = 1;
            dp[i][j][1] = 1;
            for(int k  = 0; k < 20; k++)
            {
                double p1 = 0,q1 = 0;
                for(int r = 0; r < 3; r++)
                {
                    int d = dart[r+k];
                    if(d > j)
                    {
                        p1 += 1.0/3;
                    }
                    else q1 += 1.0/3 * dp[i][j-d][0];
                }
                double tmp = (p1*q0+q1)/(1-p1*p0);
                if(tmp < y) {
                    y = tmp;
                    dp[i][j][1] = tmp;
                    dp[i][j][0] = p0*y + q0;
                }
            }
            //x = p0 * y + q0;
            // y = p1*x + q1 = p1*(p0*y+q0) + q1;
            // (1-p1*p0) y = p1*q0 + q1;
        }
    }
    while(scanf("%d",&n) && n)
    {
        printf("%.9f %.9f",dp[n][n][0],1-dp[n][n][1]);
    }
    return 0;
}

```



G题dp+计算几何

C题dp

F题bellmanford最短路
神tm当时没过。后来仔仔细细做了一遍，发现没过是应该的。
题意：给出一个图，图里有一些虫洞和墙，问起点（左下角）到终点（右上角）的最大值。
可以知道就是带负环回路求最短路，其中有这么几种情况要考虑：
1.要跑虫洞就会经过终点。这时候我们不以终点向外连线即可。
2.虫洞无法抵达。这样的话需要在bellmanford里面加入已经跑过的判断，以及离散化…(?)反正我没写离散化就没过，跑的spfa。
3.跑的时候注意虫洞就只往传送方向连边
别的大概没啥了。点挺多的，框架很快写好，细节检查许久。

---

## 第十一次训练

J 阅读题，and chelf，看到的话秒过。

A 给出一个20 * 1000的矩阵，问哪一列乘积最大。

扔给lyy写大数了。其实可以不用大数，每个数相乘那么每个数取log也是可以的，就是要注意负数的情况。

写的wa炸了。其实就是考虑负数而已。。。心态炸了，直接用别人的

```c++
int bigger(int u,int v){
    if(a[u]>0){
        if(a[v] <=0 )return 1;
        else return num[u] > num[v]+eps;
    }
    if(a[u] == 0){
        if(a[v] < 0)return 1;
        return 0;
    }
    if(a[v] >= 0) return 0;
    return num[u]+eps < num[v];
}
```

H 当一行或列和为偶时可以删掉这一行。那么从第一个位置向右下角递推就行了。一定是可以按次序确定的。写的时候有点僵硬，没有推清奇偶状态和变换关系啊，没有考虑边界啊。

E 水题 琦神切的。

D 给出一些比赛和题目数，给出你会做的题目出现在哪些比赛中，问能填满的最多比赛数。已知比赛数<15而你会做的题目<50

枚举所有比赛的状态，那么剩下的问题就是怎样安排比赛使得比赛既没有冲突且最大。一种显然的思路是二分图，但是发现其实求的好像是多重匹配。

于是跑最大流。但是如果每次都跑会炸。我们就在这里T掉了，然后从sap改成isap，然后改成dinic，都不行。

最后发现只需要更新当前这种比赛安排比ans大的情况，其他情况不用跑网络流，就不会T了。

琦神：这题傻逼。

dinic的板子是网上来的。到最后都不知道这个有没有弧优化，到时候再找一个看起来就比较靠谱的吧，在那之前先用着isap。


```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<cassert>
#include<map>
#include<vector>
#include<queue>
#include<sstream>
#include<stack>
#include<set>

using namespace std;

#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
//#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}

const int maxx=10005;
const int INF = 0x3f3f3f3f;
int n,m,k;
int a[maxx],f[20];
int vis[maxx];
char aa[10005];
vector<int> v[55];
int ans = 0,cnt = 0,pos = 0;
int l = 0,r = 0;
char s[maxx];
map<string,int> pp;
string str;
const int Ni = 80;
const int MAX = 1<<26;
 struct Edge{
     int u,v,c;
     int next;
 }edge[80*Ni];
 int edn;//边数
 int p[Ni];//父亲
 int d[Ni];
 int sp,tp;//原点，汇点

 void addedge(int u,int v,int c)
 {
     edge[edn].u=u; edge[edn].v=v; edge[edn].c=c;
     edge[edn].next=p[u]; p[u]=edn++;

     edge[edn].u=v; edge[edn].v=u; edge[edn].c=0;
     edge[edn].next=p[v]; p[v]=edn++;
 }
 int bfs()
 {
     queue <int> q;
     memset(d,-1,sizeof(d));
     d[sp]=0;
     q.push(sp);
     while(!q.empty())
     {
         int cur=q.front();
         q.pop();
         for(int i=p[cur];i!=-1;i=edge[i].next)
         {
             int u=edge[i].v;
             if(d[u]==-1 && edge[i].c>0)
             {
                 d[u]=d[cur]+1;
                 if(u == tp) return 1;
                 q.push(u);
             }
         }
     }
     return d[tp] != -1;
 }
 int dfs(int a,int b)
 {
     int r=0;
     if(a==tp)return b;
     for(int i=p[a];i!=-1 && r<b;i=edge[i].next)
     {
         int u=edge[i].v;
         if(edge[i].c>0 && d[u]==d[a]+1)
         {
             int x=min(edge[i].c,b-r);
             x=dfs(u,x);
             r+=x;
             edge[i].c-=x;
             edge[i^1].c+=x;
         }
     }
     if(!r)d[a]=-2;
     return r;
 }

 int dinic(int sp,int tp)
 {
     int total=0,t;
     while(bfs())
     {
         while(t=dfs(sp,MAX))
         total+=t;
     }
     return total;
 }

int main()
{
#ifdef LOCAL
//    freopen("","r",stdin);
#endif
    freopen("d.in","r",stdin);
    while(scanf("%d%d",&n,&m) && (n + m))
    {
        pp.clear();
        rep(i,0,m) v[i].clear();
        int d;
        cnt = 0;
        rep(i,0,n){
            scanf("%s%d",s,&d);
            str = string(s);
            pp[str] = cnt;
            f[cnt++] = d;
        }
        getchar();
        for(int i=0; i<m; i++)
        {
            gets(aa);
            int l=strlen(aa);
            str="";
            for(int j=0;j<l;j++)
            {
                if(aa[j]==' ')
                {
                    if(str != "")
                    {
                        v[i].push_back(pp[str]);
                        str="";
                    }
                }
                else str+=aa[j];
            }
            if(str!="")v[i].push_back(pp[str]);
        }
        sp = m,tp = n+m+1;
        int i,j;
        ans=0;
        for(int i = 0; i < (1<<n); i++)
        {
            edn = 0;
            memset(p,-1,sizeof(p));
//            init();
            for(int j=0;j<m;j++)
            {
                addedge(m,j,1);
            }
            for(int j =0;j<m;j++)
            for(int k=0;k<v[j].size();k++)
            {
                addedge(j,v[j][k]+m+1,1);
            }
            j=0;
            int now=i;
            int num=0;
            int t = 0;
            while(now)
            {
                if((now&1)==1)
                {
                    t += f[j];
                    addedge(j+m+1,m+n+1,f[j]);
                    num++;
                }
                now=now>>1;
                j++;
            }
            if(num <= ans) continue;
            int nowflow=dinic(m,n+m+1);
            if(nowflow==t && num>ans)ans=num;
        }
        printf("Case #%d: %d\n",++pos,ans);
    }
    return 0;
}
```



---

## 第十二次训练 (=第七次训练)



B dp

就是从第一个的排序之后在第二个里找一个值最大的。已知第一个只会一个一个往下取，所以就在第二个里面按偶数个能取的个数+1

```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<cassert>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<set>

using namespace std;

#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}

const int maxx=2005;
const int INF = 0x3f3f3f3f;
int n,m,k;
struct pp{
    int x,y;
}a[maxx];
char s[maxx];
int vis[maxx];
int ans = 0,cnt = 0,pos = 0;
int l = 0,r = 0;
struct p{
    int m,tiexin;
}dp[maxx][maxx];
int cmp(pp a,pp b){
    if(a.x != b.x)
    return a.x > b.x;
    else return a.y < b.y;
}

int main()
{
#ifdef LOCAL
    freopen("/Users/ecooodt/Desktop/c++ and acm/_集训2/sp_12/b.txt","r",stdin);
#endif
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        scanf("%s",s);
        ans = 0;
        rep(i,1,n+1){
            int x,y;
            scanf("%d%d",&x,&y);
            a[i].x = x,a[i].y = y;
            ans += a[i].x;
        }
        sort(a+1,a+n+1,cmp);
        //memset()
        int t = 1;
        if(s[0] =='P'){
//            ans1 += a[0].x;
            t = 2;
        }
        memset(dp,0,sizeof(dp));
        rep(i,1,n-t+2){
            rep(j,1,(i+1)/2+1){
                if(dp[i-1][j-1].m + a[i+t-1].y > dp[i-1][j].m)
                {
                    dp[i][j].m = dp[i-1][j-1].m + a[i+t-1].y;
                    dp[i][j].tiexin = dp[i-1][j-1].tiexin + a[i+t-1].x;
                }
                else if(dp[i-1][j-1].m + a[i+t-1].y == dp[i-1][j].m){
                    dp[i][j] = dp[i-1][j];
                    if(dp[i-1][j-1].tiexin+a[i+t-1].x < dp[i-1][j].tiexin){
                        dp[i][j].tiexin = dp[i-1][j-1].tiexin + a[i+t-1].x;
                    }
                }
                else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        printf("%d %d\n",ans-dp[n-t+1][(n-t+2)/2].tiexin,dp[n-t+1][(n-t+2)/2].m);
    }
    return 0;
}
/*
3
4
Petra
100 80
70 80
50 80
30 50
4
Petra
10 1
1 10
6 6
4 4
7
Jan
4 1
3 1
2 1
1 1
1 2
1 3
1 4
 */
```

F 最大流

网上题解写的不错（摸

给n个点的无权无向图（n<=100），每个点有一个非负数ai。若ai==0则此点归敌方所有，若ai>0则此点归你且上面有ai个属于你的士兵。保证至少有一个属于你的点与敌方的点相邻。你可以让你的每个士兵最多移动一次，每次可以待在原地或者去到相邻的属于你的领地，但每个点至少要留1各士兵，使得最薄弱的关口尽量坚固。关口是指与敌方点相邻的点，薄弱与坚固分别指兵少与兵多。

把每个点拆成两个点，一个入度，一个出度，入度向自己的和每个相邻的点的出度连一条边，容量是ai，每个点出度连一条边到汇点，容量为1，那些与敌人相邻的点再多连一条边到汇点，容量是二分的值，我们只需要二分这个值，跑一下网络流，如果满流，表示可以，否则不行。

```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<cassert>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<set>

using namespace std;

#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}

const int maxx=105;
const int INF = 0x3f3f3f3f;
int n,m,k;
int a[maxx];
int vis[maxx];
int ans = 0,cnt = 0,pos = 0;
int l = 0,r = 0;
char s[maxx][maxx];


const int maxn = 305;
int flow[maxn][maxn];
int maz[maxn][maxn];
int gap[maxn],dis[maxn],pre[maxn],cur[maxn];
int sap(int start,int end,int nodenum)
{
    memset(cur,0,sizeof(cur));
    memset(dis,0,sizeof(dis));
    memset(gap,0,sizeof(gap));
    memset(flow,0,sizeof(flow));
    int u = pre[start] = start,maxflow = 0,aug = -1;
    gap[0] = nodenum;
    while(dis[start] < nodenum)
    {
    loop:
        for(int v = cur[u]; v < nodenum; v++)
        {
            if(maz[u][v]-flow[u][v] && dis[u] == dis[v] + 1)
            {
                if(aug == -1 || aug > maz[u][v] - flow[u][v]) aug = maz[u][v] - flow[u][v];
                pre[v] = u;
                u = cur[u] = v;
                if(v == end)
                {
                    maxflow += aug;
                    for(u = pre[u]; v != start; v= u, u = pre[u])
                    {
                        flow[u][v] += aug;
                        flow[v][u] -= aug;
                    }
                    aug = -1;
                }
                goto loop;
            }
        }
        int mindis = nodenum - 1;
        for(int v = 0; v < nodenum; v++)
        {
            if(maz[u][v] - flow[u][v] && mindis > dis[v])
            {
                cur[u] = v;
                mindis = dis[v];
            }
        }
        if((--gap[dis[u]]) == 0) break;
        gap[dis[u] = mindis + 1] ++;
        u = pre[u];
    }
    return maxflow;
}


int ok(int mid)
{
    memset(maz,0,sizeof(maz));
    int t = 0;
    rep(i,1,n+1){
        if(a[i])
        {
            maz[i*2-1][i*2] = a[i];
            maz[0][2*i-1] = a[i];
            int g = 0;
            rep(j,1,n+1)
            {
                if(s[i][j] == 'Y'){
                    if(a[j]) maz[i*2-1][j*2] = a[i];
                    else g = 1;
                }
            }
            if(!g) {
                maz[i*2][n*2+1] = 1;
                t++;
            }
            else{
                maz[i*2][n*2+1] = mid;
                t += mid;
            }
        }
    }
    int nowflow = sap(0,2*n+1,2*n+2);
    printf("%d %d\n",t,nowflow);
    if(nowflow >= t) return 1;
    else return 0;
}

void erfen()
{
    int mid;
    while(l<=r)
    {
        mid = (l + r) / 2;
        if(ok(mid))
        {
            l = mid + 1;
        }
        else
        {
            r = mid - 1;
        }
    }
    l--;
}


int main()
{
#ifdef LOCAL
    freopen("/Users/ecooodt/Desktop/c++ and acm/_集训2/sp_12/f.txt","r",stdin);
#endif
    int T;
    scanf("%d",&T);
    while(T--)
    {
        cnt = 0;
        scanf("%d",&n);
        rep(i,1,n+1){
            scanf("%d",&a[i]);
        }
        rep(i,1,n+1)
        {
            scanf("%s",s[i]+1);
        }
        l = 1,r = 10000;
        erfen();
        printf("%d\n",l);
    }
    return 0;
}
```



---

## 第十三次训练

A 水题

D

在一个三维空间中，给定一些点，这些点的z坐标都是大于0的。要求求出一个圆锥（底面是圆形），使得这个圆锥的底面在z = 0的平面上，它能够包含所有给定的点并且圆锥的体积要求最小。

琦神写了一大片板子就过了

网上的做法是三分，看了看确实不知道比琦神要节省多少时间hhh

转成二维问题，要求要求$y^2x$的值最小。发现对过p(a,b)，y = K * (x - a) + b
x =  - a * k + b
y = -b / k + a
V = pi * x * y^2 = pi * (-a * k + b) * (-b / k + a) ^ 2
求个导，发现影响正负的是 -(aK^2 + 2bK)。得到结论，k = -2b/a时取得最小值。
三分y，x 用z * y / x - (ai^2+bi^2表示就能取到最大)

E

给出n个人，m个地方的一维坐标，每个地方至少一个人，使得所有人走动的距离最少的值。

$dp[i][j] = min(dp[i-1][j],dp[i-1][j-1]) + abs(a[i]-b[j])$

注意输出路径。

F
$$
\frac{p_1!p_2!..p_n!}{q_1!q_2!..q_m!} \\r_1!^{s_1}r_2!^{s_2}...r_k!^{s_k}t
$$
这题想要化简分子和分母都是阶乘之积，即第一幅图，然后形成第二幅图的形式，让r、s尽量大，不管t，并且询问第一个式子是不是整数。
q p < 1e4 nm < 1e3

存每个数的素因子及其个数。然后看分子是否不小于分母。不小于就是整数。

然后二分r就行了。r的上界就是1e4，r比s优先就不用管s



G

交互题，扔给lyy了。

I 

给出边权，问从1-n的「边权字典序」最小的一种。

先用一遍bfs跑出d数组，再用一次bfs每次只更新距离+1的点的最小边权，如果有多种则统统扔进queue里，每次统统弹出来扫一遍。

一开始写的时候是一个一个扔一个一个扫的，这样不能保证字典序最小。

K 

问在节点度数最多为k的情况下对所有节点染不超过k种的染色方案。

用bfs遍历一遍图，先用vis扫一遍所有邻边，染一个周围没染过的颜色，再扫一遍把周围邻边的颜色从vis撤出来，就行了

---

## 第十四次训练

lyy因为要当出题人所以摸了。最后一道题我背了大锅居然忘记了 & 的优先级，结束之后15s过的题

G题水题

D题很有意思。D问的是最多只相隔一个连续区间的最长连续序列有多长。

想到lis的nlogn解法，lis是b里放每个长度LIS的最小末尾，这里我们同样放每个连续递增序列的最后一个元素的最小值。同样二分，同样更新。


```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<cassert>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<set>

using namespace std;

#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}

const int maxx=10005;
const int INF = 0x3f3f3f3f;
int n,m,k;
int vis[maxx];
int l = 0,r = 0;

int len[200005],pos[200005],a[200005],b[200005];
int main()
{
#ifdef LOCAL
    freopen("/Users/ecooodt/Desktop/c++ and acm/_集训2/sp_14/d.txt","r",stdin);
#endif
    int T,i,n;
    scanf("%d",&T);
    while(T--)
    {
        memset(b,0x3f,sizeof(b));
        int ans = 0;
        scanf("%d",&n);
        for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
        len[1]=1;
        pos[1]=1;
        for(i=2;i<=n;i++)
        {
            if(a[i-1]<a[i])
            {
                len[i]=len[i-1]+1;
                pos[i]=pos[i-1]+1;
            }
            else
            {
                len[i]=1;
                pos[i]=1;
            }
        }
        for(i=n-1;i>=1;i--)
        {
            if(a[i]<a[i+1])
            {
                len[i]=len[i+1];
            }
        }
        for(i=1;i<=n;i++)
        {
            //update ans
            int now=lower_bound(b+1,b+1+n,a[i])-b-1;
            if(now+len[i]-pos[i]+1>ans)ans=now+len[i]-pos[i]+1;
            if(a[i]<b[pos[i]])b[pos[i]]=a[i];
        }
        printf("%d\n",ans);
    }
    return 0;
}

```



E题set的应用。

如果一个水塘连续两次下雨就会炸，必须在第二次之前喝掉水塘里的水。这道题问题就在于水塘里没有水的时候没法喝，不能直接模拟。

改为贪心，每次下雨取和上次下雨之间区间的第一个不下雨的日子喝掉。用set维护，并用set二分查找。十分方便。

C题马拉车的应用。

找一个ww^rww^r，即w和w的反 * 2的最长长度。琦神的后缀数组处理不了一些奇怪的height的情况。于是用马拉车，对于每个ww^rww^r，w和w^r必然构成一个回文。但是ww^rww^r可能比ww^r * 2要小（大的情况会缩回来变成小的情况），只要找两个w和ww^r中间那里的最长回文是否大于中间的一半就行了

注意小判断。比如我一直错的地方：只有在字母之间的位置才能进行判断（毕竟%4）

J题构造

A题同上海C，求空间中线段距离的平方，用分数表示。
先判断线段平行或重合，直接计算每个端点过去的最小值，否则异面直线，带入模版。

这里先贴一个csdn的代码

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

long long gcd(long long a, long long b) {
    return b == 0 ? a : gcd(b, a % b);
}
long long lcm(long long a, long long b) {
    return a / gcd(a, b) * b;
}
struct Rat {
    long long a, b;
    Rat(long long a = 0):a(a), b(1) {}
    Rat(long long x, long long y):a(x), b(y) {
        if (b < 0) {
            a = -a;
            b = -b;
        }
        long long temp = gcd(a, b);
        if (temp < 0)
            temp = -temp;
        a /= temp;
        b /= temp;
    }
};
Rat operator + (const Rat& A, const Rat& B) {
    long long temp = lcm(A.b, B.b);
    return Rat(A.a * (temp / A.b) + B.a * (temp / B.b), temp);
}
Rat operator - (const Rat& A, const Rat& B) {
    return A + Rat(-B.a, B.b);
}
Rat operator * (const Rat& A, const Rat& B) {
    return Rat(A.a * B.a, A.b * B.b);
}

void Min(Rat& A, const Rat& B) {
    if (A.a * B.b > B.a * A.b) {
        A.a = B.a;
        A.b = B.b;
    }
}

struct Point3 {
    long long x, y, z;
    Point3(long long x = 0, long long y = 0, long long z = 0):x(x), y(y), z(z) {}
};
typedef Point3 Vector3;

Vector3 operator + (const Vector3& A, const Vector3& B) {
    return Vector3(A.x + B.x, A.y + B.y, A.z + B.z);
}
Vector3 operator - (const Vector3& A, const Vector3& B) {
    return Vector3(A.x - B.x, A.y - B.y, A.z - B.z);
}
Vector3 operator * (const Vector3& A, long long b) {
    return Vector3(A.x * b, A.y * b, A.z * b);
}

bool operator == (const Point3& A, const Point3& B) {
    return A.x == B.x && A.y == B.y && A.z == B.z;
}
long long Dot (const Vector3& A, const Vector3& B) {
    return A.x * B.x + A.y * B.y + A.z * B.z;
}
long long Length(const Vector3& A) {
    return Dot(A, A);
}
Vector3 Cross(const Vector3& A, const Vector3& B) {
    return Vector3(A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x);
}
//点到线段距离
Rat Rat_DistanceToSegment(const Point3& P, const Point3& A, const Point3& B) {
    if (A == B)
        return Rat(Length(P - A));
    Vector3 v1 = B - A, v2 = P - A, v3 = P - B;
    if (Dot(v1, v2) < 0)
        return Rat(Length(v2));
    if (Dot(v1, v3) > 0)
        return Rat(Length(v3));
    return Rat(Length(Cross(v1, v2)), Length(v1));
}
//求p1 + su和p2 + tv两个异面直线的公垂线，如果平行或重合返回false
//两次调用解出t和s两个参数
bool Rat_LineDistance3D(const Point3& p1, const Vector3& u, const Point3& p2, const Vector3& v, Rat& s) {
    long long b = Dot(u, u) * Dot(v, v) - Dot(u, v) * Dot(u, v);
    if (b == 0)
        return false;
    long long a = Dot(u, v) * Dot(v, p1 - p2) - Dot(v, v) * Dot(u, p1 - p2);
    s = Rat(a, b);
    return true;
}
void Rat_GetPointOnLine(const Point3& A, const Point3& B, const Rat& t, Rat& x, Rat& y, Rat& z) {
    x = Rat(A.x) + Rat(B.x - A.x) * t;
    y = Rat(A.y) + Rat(B.y - A.y) * t;
    z = Rat(A.z) + Rat(B.z - A.z) * t;
}

int main() {
    int cas;
    scanf("%d", &cas);
    while (cas--) {
        Point3 L1[2], L2[2];
        scanf("%lld%lld%lld%lld%lld%lld", &L1[0].x, &L1[0].y, &L1[0].z, &L1[1].x, &L1[1].y, &L1[1].z);
        scanf("%lld%lld%lld%lld%lld%lld", &L2[0].x, &L2[0].y, &L2[0].z, &L2[1].x, &L2[1].y, &L2[1].z);
        Rat res = Rat(1e9) s, t;
        int flag = 0;
        if (Rat_LineDistance3D(L1[0], L1[1] - L1[0], L2[0], L2[1] - L2[0], s)) {
            if (s.a > 0 && s.a < s.b && Rat_LineDistance3D(L2[0], L2[1] - L2[0], L1[0], L1[1] - L1[0], t)) {
                if (t.a > 0 && t.a < t.b) { //点要在线段上需要参数保证在0~1之间
                    flag = 1;
                    Rat x1, y1, z1, x2, y2, z2;
                    Rat_GetPointOnLine(L1[0], L1[1], s, x1, y1, z1);
                    Rat_GetPointOnLine(L2[0], L2[1], t, x2, y2, z2);
                    res = Rat((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));
                }
            }
        }
        if (!flag) {
            Min(res, Rat_DistanceToSegment(L1[0], L2[0], L2[1]));
            Min(res, Rat_DistanceToSegment(L1[1], L2[0], L2[1]));
            Min(res, Rat_DistanceToSegment(L2[0], L1[0], L1[1]));
            Min(res, Rat_DistanceToSegment(L2[1], L1[0], L1[1]));
        }
        if (res.a == 0)
            res.b = 1;
        printf("%lld %lld\n", res.a, res.b);
    }
    return 0;
}
```



I题

---

## 第十五次训练。

#### A 水题

#### C 

给出两个1000 * 1000的矩阵A B，问A ^ 2 是否 == B（其实是给出一个图，问第二个图是不是第一个图走长为2的路形成的图）
普通n^3肯定不妥。用 a * (a * c) = b * c 优化矩阵到n^2

#### F题 bfs dp

一只猴子在树上跳来跳去，问你至少要多少次才能保证打死这只猴子，每开一枪猴子都会跳到其他的点上。

我们把有可能有猴子设为1，没有设为0，那么就是由一个初始全1的串到全0的串的路径长，每开一枪就能把这个点设为0，然后下一个状态就是剩下那些1和他们相通的点，bfs即可，注意记录路径。

#### H题 区间dp

---

## 第十六次训练

鸽了

---

## 第十七次训练

第十七次训练

A 求= c(<=1e15)的所有c(n,m)。

枚举n，二分m。写的话有点小麻烦

B zz阅读题

E 不知道

C 每次从栈里取出一个标号扔到顶上，n 1e5 ，询问每次扔之前它上面有多少个东西。询问1e5

想到模拟这个栈，每次取出一个标号就给他另赋一个顶值，就可以用一个树桩数组直接维护每个位置了。

想不到就很麻烦，调了半天树堆，发现312这样的我再取第k大的时候是取不到的。

> 是Splay的不错的替代品，不过至今还是有一些问题不能很好的解决
> 譬如查询某个数在序列中的第几个位置QAQ

D 大概是2sat问题，虽然有人用二分图过了，不过大概是数据太水。

F 最大流经典紫书题。。给出一个n * m的矩阵，里面有#和.，#是草，.是洞，洞和草可以以一定代价互相转化，而最后要在保证最外围一圈都是草的情况下给所有洞和草之间以一定代价围上篱笆，问最小代价。

看到给草和洞之间以代价围篱笆，想到最小割。最小割就是最大流。
首先保证最外围一圈都是草，然后把外围草和原点的限流设为无限大，把内部草和原点连限流为代价的边（就是变成洞的代价），内部洞和汇点连限流为代价的边，然后内部之间连边（洞和草之间围栏的代价）跑最大流就行了

H 大模拟

类似状态压缩dp。。。？

有个东西我非常在意：枚举集合sup的子集：

```c++
for(int i = sup; i; i = (i-1)&sup;)//也可以i != sup
```

这还是骚啊。就能直接跑1011（11）的 10,9,8,3,2,1这些。

另外

```c++
for(int i = 0; i < 13; i++) if(t&(1<<i)) v.pb(i);
```

就能直接取出t里面二进制位是1的位置。

这题就给你13张牌，已知有对子，3，4，3+2，>=5的顺子的出牌方式，问最少多少次能打出所有牌。

先处理出所有的结束状态。枚举(1<<13) 的状态，用上面的东西枚举子集，i是现在的状态，j是子集的状态，如果i-j是一个结束状态，表示从i状态打到j状态只需要一次，则有更新dp[i] = max(dp[i],dp[j] + 1)这样。

输出也有点麻烦，dfs跑一遍。

---

## 第十八次训练

A.水题，扫过不是.之后到下一个不是.的.都算一遍就行了

B.阅读题，模拟（我都能1a）

K.猜测、图论

问你最少连哪些边使得图里没有割边。

按照dfs序上的连i与i+(n+1)/2即可。正确性不明。

E.大模拟，bfs没有跑到所有的点wa了两发

G.分析

在1-n里猜一个数，每次告诉你猜的数和真正的数的gcd

当猜一个数他说gcd不为1时缩小的范围一定比说为1的情况大。所以一定都说1，问题转化为给n以内的素数分组，使得每组之积不大于n，求最小的组数。（就是每次猜一组素数乘积的数字）每次取最大的和小的合并就行了

D

给出n个word，问能组成多少个串，满足要么这个串是word，要么可以被分成两份，前份是某个word的前缀，后份是某个word的后缀。

显然想到字典树。

字典树可以很好的去掉重复组成，但是有另一个种重复，就abc可以分为a|bc，也可以分为ab|c。对于每个前缀，向后添加一个字符时，以这个字符为首的后缀都算重了，就统计以x为儿子的前缀数量，以x为儿子的后缀数量，相乘就是重复数。（换个说法，统计两个树里除了和根相连的字母出现次数）最后加上长度为1的单词

```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<cassert>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<set>

using namespace std;

#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}

const int maxx=40005;
const int INF = 0x3f3f3f3f;
int n,m,k;
int a[maxx];
int vis[maxx];
int ans = 0,cnt = 0,pos = 0;
int l = 0,r = 0;

struct Trie{
    int sz,g[maxx][26];
    int c[26];

    void init(){
        sz = 1;
        memset(g[0],0,sizeof(g[0]));
        memset(c,0,sizeof(c));
    }
    void insert(char *s){
        int u = 0,n = strlen(s);
        for(int i = 0; i < n; i++)
        {
            int v = s[i]-'a';
            if(g[u][v] == 0){
                memset(g[sz],0,sizeof(g[sz]));
                g[u][v] = sz++;
                if(i) c[v]++;
            }
            u = g[u][v];
        }
    }
}pre,suf;

int main()
{
#ifdef LOCAL
//    freopen("","r",stdin);
#endif
    freopen("dictionary.in","r",stdin);
    freopen("dictionary.out","w",stdout);
    scanf("%d",&n);
    char word[45];
    pre.init();
    suf.init();
    for(int i = 0; i < n; i++)
    {
        scanf("%s",word);
        pre.insert(word);
        if(strlen(word) == 1) vis[word[0]-'a'] = 1;
        reverse(word,word+strlen(word));
        suf.insert(word);
    }
    ll ans = 1ll * (pre.sz-1) * (suf.sz-1);
    rep(i,0,26){
        ans -= (ll)pre.c[i] * suf.c[i] - vis[i];
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 第19次训练

#### JD 水题

#### I题 思维 

给出一个区间，查询里面是否有重复的数，如果有，随便输出一个。

处理出每个数和他后面一个数，那么这个d[i] = min(d[i+1],pos)。

#### C题大模拟

#### B题中国剩余定理

#### F题 动态树板题

然而动态树板子不够优秀，不能封装k个lct（其实是不会改…）。
抄了个别的板子，怎么用还是个问题。



#### E题 假题

---

## 第20次训练

orz我做了一堆水题，没什么好说的。

吐个槽，有个题给出网球规则，结果给错了却按照真实的来。。我就不该认真读题。shit

---

## 第21次训练

AH lyy切

#### B 树状数组

题意给出2 * n个竖着的方块，每次相同的碰撞会使得两两抵消，问最少交换多少次相邻的两个方块使得所有的方块都可以被抵消？

emmm，我也是听了隔壁的思路做的。猜测每次都从左向右贪心每个不能抵消的方块最优，而每个不能抵消的方块需要抵消的话就需要找前面的他自己出现的位置，问题转换为查询每个数字前一次出现的位置，这样就是很简单的bit的题了。

```c++
/*
  ID: oodt
  PROG:
  LANG:C++
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<cassert>
#include<map>
#include<vector>
#include<queue>
#include<stack>
#include<set>

using namespace std;

#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}

const int maxx=1000500;
const int INF = 0x3f3f3f3f;
int n,m,k;
int a[maxx];
int vis[maxx];
int c[maxx];
int ans = 0,cnt = 0,pos = 0;
int l = 0,r = 0;

int lowbit(int x)
{
    return x & (-x);
}
void add(int x,int add)//一维
{
    while(x <= n*2)
    {
        c[x]+=add;
        x+=lowbit(x);
    }
}
int sum(int x)
{
    int s=0;
    while(x > 0)
    {
        s += c[x];
        x -= lowbit(x);
    }
    return s;
}

int main()
{
#ifdef LOCAL
//    freopen("","r",stdin);
#endif
    freopen("b.in","r",stdin);
    scanf("%d",&n);
    rep(i,1,2*n+1){
        scanf("%d",&a[i]);
    }
    memset(vis,0,sizeof(vis));
    rep(i,1,2*n+1){
        if(vis[a[i]]){
            int t = sum(i) - sum(vis[a[i]]-1);
            add(vis[a[i]],-1);
            ans += t-1;
        }
        else {
            vis[a[i]] = i;
            add(i,1);
        }
//        printf("%d\n",ans);
    }
    printf("%d\n",ans);
    return 0;
}

```

#### C题水题

这题该lyy切的。。我不适合切什么质数之类的破题

#### E题大模拟

模拟一个折叠翻转的过程。。。调参一个半小时才调出来

#### G题队列模拟

#### I题 树

求树上每个点和他距离最远的点距离。lca做多了直接一发lca贴上去发现不对。

先随便取个根，求出与这个根最远的点，然后求出与这个最远的点最远的点，则答案一定取自这两个点之中一个。正确性。。emmmm，显然！（不显然）

---

## 第22次训练

#### A 最大流

求有向图里不重复走边1-n的两条路的权值和。有向图，拆点。

#### D 模拟

#### E fibonacci

很奇怪，环里取匹配数居然是fibonacci，不过好像有个什么locas定理就是a[n-1]+a[n-2]

#### I 2-sat

裸题。。。

#### J 水题

我就不说我直接贴set忘记重复的事了。。

---

# 秋季训练