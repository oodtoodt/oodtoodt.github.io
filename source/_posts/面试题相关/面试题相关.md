---
title: 面试题相关
date: 2019-09-20 09:46:58
tags: 面试
---

惨，是真的惨。

---
<!--more-->




## 知识

### c++的

#### memmove注意事项？
内存重叠（dst<=src || (char * )dst >= (char * )src + count)
内存对齐(为了提高存取效率和一定的移植性)

##### memcpy
它的功能是从src的开始位置拷贝n个字节的数据到dest。如果dest存在数据，将会被覆盖。memcpy函数的返回值是dest的指针。

#### c++的内存管理
在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。
代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
数据段：存储程序中已初始化的全局变量和静态变量
bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。
堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。
映射区:存储动态链接库以及调用mmap函数进行的文件映射
栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值

##### allocator
大多数情况下，STL默认的allocator就已经足够了。这个allocator是一个由两级分配器构成的内存管理器，当申请的内存大小大于128byte时，就启动第一级分配器通过malloc直接向系统的堆空间分配，如果申请的内存大小小于128byte时，就启动第二级分配器，从一个预先分配好的内存池中取一块内存交付给用户，这个内存池由16个不同大小（8的倍数，8~128byte）的空闲列表组成，allocator会根据申请内存的大小（将这个大小round up成8的倍数）从对应的空闲块列表取表头块给用户。

注意这并不适合一个通用的内存分配。因为它要求在释放一个内存块时，必须提供这个内存块的大小，以便确定回收到哪个free list中

我们知道，引入相对的复杂的空间配置器，主要源自两点：

1. 频繁使用malloc，free开辟释放小块内存带来的性能效率的低下
2. 内存碎片问题，导致不连续内存不可用的浪费

引入两层配置器帮我们解决以上的问题，但是也带来一些问题：

内碎片的问题，自由链表所挂区块都是8的整数倍，因此当我们需要非8倍数的区块，往往会导致浪费，比如我只要1字节的大小，但是自由链表最低分配8块，也就是浪费了7字节，我以为这也就是通常的以空间换时间的做法，这一点在计算机科学中很常见。
我们发现似乎没有释放自由链表所挂区块的函数？确实是的，由于配置器的所有方法，成员都是静态的，那么他们就是存放在静态区。释放时机就是程序结束，这样子会导致自由链表一直占用内存，自己进程可以用，其他进程却用不了。

##### 为什么free不需要知道大小？
有先存一个结构体为它的大小


Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。
当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。
Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。

##### malloc和new的区别？
1. 申请的内存所在位置。malloc是堆，new是从free store
2. 返回类型。malloc返回void * ，new是类型安全的。失败时malloc返回NULL，new失败抛出异常
3. 调用构造/析构函数
4. 指定内存大小
5. 专门提供对数组的处理
6. 可以重载
7. 直观的内存（malloc）

##### placement new

一般来说，使用new申请空间时，是从系统的“堆”（heap）中分配空间。申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这就是所谓的“定位放置new”（placement new）操作。 
定位放置new操作的语法形式不同于普通的new操作。例如，一般都用如下语句A *  p=new A;申请空间，而定位放置new操作则使用如下语句A *  p=new (ptr)A;申请空间，其中ptr就是程序员指定的内存首地址。考察如下程序。 

##### new,delete,malloc,free是否可以混用
当申请的空间是内置类型时，delete和free可以混用
当申请的空间是自定义类型时，
*       1>若没有析构函数，delete和malloc可以混用，有[]和没有[]都相同
*       2>若申请的空间有析构函数时，malloc申请的空间可以用delete和free释放，但是用delete释放时不能加[]
*       3>若申请的空间有析构函数时，new申请的空间不能用free释放，可以用delete释放，但是释放时必须加上[]

##### delete []p 和delete p
delete ptr 代表释放ptr指向内存，并且只能用来释放内存。
delete[] ptr 代表释放ptr指向的内存，并且逐个调用对象的析构函数。

#### 指针和引用
引用即别名，指针是新的变量
级数：从理论上来说，对于指针没有级数限制，但是引用只有一级。
内存分配：程序为指针变量分配区域，而不为引用分配内存区域。因为引用生命时必须初始化，从而指向一个已经存在的对象，引用不能为空值
编译：反正就是指针可以指向别的值，引用不能

#### 定义和声明的区别
声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。

#### 二维字符串的初始化

```c++
char *p[30] =  {"ab","cd","ed"};
```

####  int * ( * ( * fp)(void * ))[10]
```c++
int (*(*fp)(void *))[10]; //这个类型用typedef分解出来

// 第一步：此指针是一个指向函数T1的指针
typedef int (*T1(void *))[10];
T1 *fp;

// 第二步：T1 是一个函数，返回值是T2，参数为(void *)
typedef int (*T2)[10];
typedef T2 T1(void *);
T1 *fp;

// 第三步：T2是个指针，该指针指向T3类型
typedef int T3[10];
typedef T3 *T2;
typedef T2 T1(void *);
T1 *fp;
```
##### 指针函数 函数指针

**指针函数：** 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。
注意到指针函数返回的指针可能指向空值，需用static声明

**函数指针** 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。

```c++
int max(int a, int b)
{
    return a > b ? a : b;
}
int (*p)(int, int); //函数指针的定义
//int (*p)();       //函数指针的另一种定义方式，不过不建议使用
//int (*p)(int a, int b);   //也可以使用这种方式定义函数指针
p = max;    //函数指针初始化
int ret = p(10, 15);    //函数指针的调用
```

##### typedef  void ( * pfun)(void); 

```c++
typedef  unsigned int  UINT32;	// UINT32 类型是unsigned int
UINT32 sum;		// 定义一个变量：int sum;

typedef  int  arr[3];		// arr 类型是 int[3];（存放int型数据的数组）
arr a;		// 定义一个数组：int a[3];

同理：
typedef  void (*pfun)(void);	// pfun 类型是 void(*)(void)
pfun main;      // 定义一个函数：void (*main)(void);
```

其中静态不静态的区别只在类中，静态不需要对象来访问变量（函数）

##### 应用：

举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方

**回调函数**：

回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。
回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。

上面这个简单的demo就是一个比较典型的回调函数的例子。在这个程序中，回调函数`callback`无需关心`func_sum`是怎么实现的，只需要去调用即可。
这样的好处就是，如果以后对求和函数有优化，比如新写了个`func_sum2`函数的实现，我们只需要在调用回调函数的地方将函数指针指向`func_sum2`即可，而无需去修改`callback`函数内部

#### Extern C*

extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
被extern “C”修饰的函数或者变量是按照C语言方式编译和链接的，所以可以用一句话来概括extern “C”的真实目的：实现C++与C的混合编程。


#### struct和class的区别？
c++中：
1.struct可以包括成员函数
2.struct可以实现继承
3.struct可以实现多态

1.默认的继承访问权。class默认的是private,strcut默认的是public。（优先取决于取决于子类而不是基类）

两者最大的区别就在于思想上，c语言编程单位是函数，语句是程序的基本单元。而C++语言的编程单位是类。从c到c++的设计有过程设计为中心向以数据组织为中心转移。

#### 时间复杂度
##### fibonacci
return f(n-1) + f(n-2)
这里的复杂度是O(2^n)！一直误会了这个复杂度。因为每一个都会向下递归，那么直接考虑成一颗二叉树，其实应该是O(2^n/2)的感觉，左边偏满越向右越不满。
优化就是尾递归只一层或者直接循环


#### 虚函数
##### 虚函数定义
虚函数则是加了virtual修饰词的类的成员函数。
虚函数通过继承方式来体现出多态作用，它必须是基类的非静态成员函数，其访问权限可以是protected或public
虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数

##### 虚函数的代价
1）带有虚函数的每个类会产生一个虚函数表，用来存储虚成员函数的指针
2）带有虚函数的每个类都会有一个指向虚函数表的指针
3）不再是内联函数，因为内联函数可以在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到达采用哪种函数，所以虚函数不是内敛函数

##### 虚函数和纯虚函数的区别？
1）纯虚函数只有定义，没有实现，虚函数既有定义，又有实现
2）含有纯虚函数的类不能定义对象，含有虚函数的类可以定义对象

##### 不能虚函数的函数？
常见的不能声明为虚函数的有：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数。
构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数
父类虚析构函数就是为了避免内存泄漏，防止子类内存得不到释放造成内存泄漏

##### 虚表指针存在对象的哪个位置
存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表
一般而言，虚函数表vtable存放在可执行文件的只读数据段
##### 纯虚函数
（1）当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；
（2）这个方法必须在派生类(derived class)中被实现；

##### 含虚函数的sizeof
其实考察的还是虚表指针。
//是虚函数里面的指针个数（其实只有一个指向开头，毕竟指针） * 指针大小
如果是单继承，则派生类只含有一个虚函数表（虚表指针）
如果是多继承，则在派生类中，有每个基类函数的虚表指针
虚继承中，派生类会保存一个指向虚基类的指针，而且如果虚基类包含虚函数，则还会保存虚基类中的虚表指针。（虚继承就是菱形继承）


#### 内存泄漏
内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
内存泄漏的分类：
1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。
  有效解决内存泄漏可以使用智能指针。因为智能指针可以自动删除分配的内存。智能指针和普通指针类似，只是不需要手动释放指针，而是通过智能指针自己管理内存的释放

#### 智能指针
智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。

weak_ptr 用来协助shared_ptr

unique_ptr 唯一的ptr

#### 初始化列表
使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的。
所以一个好的原则是，能使用初始化列表的时候尽量使用初始化列表.

##### 必须使用初始化列表的场合

1.常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
2.引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面

3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化

另外：成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的

#### 使用拷贝构造函数／构造函数／赋值函数
如果临时变量是第一次出现，那么调用的只能是拷贝构造函数，反之如果变量已经存在，那么调用的就是赋值函数。
如果你认真思考一下构造函数的结构，其实也能明白的吧

#### 迭代器
1、迭代器
Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。

由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。

2、迭代器和指针的区别

迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、 * 、++、--等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用 * 取值后的值而不能直接输出其自身。

3、迭代器产生原因

Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

#### 使用this指针的场合
你不怎么会用呢。
C++ 规定，在非静态成员函数内部可以直接使用 this 关键字，this 就代表指向该函数所作用的对象的指针
注意哦，是 指针


#### inline
inline 是一种"用于实现的关键字"，而不是一种"用于声明的关键字"
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 
只有当函数非常短小的时候它才能得到我们想要的效果

#### static
全局静态变量在声明他的文件之外是不可见的
但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。
那么这个函数只可在本cpp内使用
对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。

##### static的赋值问题

首先分开赋值和初始化。

注意带有类内初始值设定项的成员必须为常量
即static静态成员变量的初始化赋值应该在类的外部。
非静态的类数据成员不能在其类的外部定义

绕来绕去，总之就是类外！

该静态数据成员只能被定义一次，而且要被同类的所有对象共享。各个对象都拥有类中每一个普通数据成员的副本，但静态数据成员只有一个实例存在，与定义了多少类对象无关。
静态数据成员的用途之一是统计有多少个对象实际存在。
静态数据成员不能在类中初始化，实际上类定义只是在描述对象的蓝图，在其中指定初值是不允许的。也不能在够造函数中初始化该成员，因为静态数据成员为类的各个对象共享，那么每次创建一个类的对象则静态数据成员都要被重新初始化。

#### const作用
（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；  
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；  
char * const p p不可更改
const char * p 内容不可更改
char const * p 内容不可更改
（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；  
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；  （最后 () const{}这种)
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

#### 模版类编程
template<typename T>与template<class T>一般情况下这两个通用，但有一个特例，就是当 T 是一个类，而这个类又有子类(假设名为 innerClass) 时，应该用 template<typename>:

注意，类中函数可以不怎么在意
但是类外要写就要
```c++
A& operator=(const A& s_point);

A<T>& A<T>::operator=(const A& s_point)

~BS();
BS<T>::~BS()
```
注意到A<T>::其实是一定要插进来的。

#### 编译的过程
预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件


#### 析构函数特点
没有参数
没有重载
权限控制无效
不能手动调用
没有返回类型

#### 内联和宏的区别
内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候内联函数像宏一样展开，所以取消了函数的参数压栈，减少了调用的开销。可以像调用函数一样调用内联函数，而不必担心会产生处理宏的一些问题。

#### explicit
explicit和构造函数一起使用，explicit指明构造函数只能显式使用，目的是为了防止不必要的隐式调用类型转换构造函数。

#### restrict
(1)restrict是用来优化的;
(2)restrict只能修饰指针，restrict修饰的指针是能够访问所指区域的唯一入口，限制多个指针指向同一地址。

#### volatile
volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。

如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

#### c++11特性
auto类型推导
范围for循环
lambda函数
Lambda表达式:简化了匿名委托的使用，让你让代码更加简洁，优雅。

```c++
[] (int x, int y) { return x + y; } // 隐式返回类型
[] (int& x) { ++x;  } // 没有 return 语句 -> Lambda 函数的返回类型是 'void'
[] () { ++global_x;  } // 没有参数，仅访问某个全局变量
[] { ++global_x; } // 与上一个相同，省略了 (操作符重载函数参数)


1.空:Lambda表达式不使用在同一块语句的变量，例如:[]
2.=:在块语句内的局部变量都以值传递的方式传递给Lambda,例如:[=]
3.&:块语句内的局部变量以引用方式传递给Lambda,例如:[&]
4.指定某个变量传递,例如:[a],[&a]

//可以像下面这样显示指定返回类型：
[] (int x, int y) -> int { int z = x + y; return z; }

//Lambda 函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包. 闭包被定义在 Lambda 表达式声明中的方括号 [] 内。这个机制允许这些变量被按值或按引用捕获

auto f_check_map = [&_map, &bMapFlag](){}

sort(intervals.begin(), intervals.end(), [](Interval &a, Interval &b) {return a.start < b.start;});

```





##### override 和 final 关键字

在成员函数声明或定义中，`override` 确保该函数为虚函数并覆盖某个基类中的虚函数。若此非真则程序非良构（生成编译错误）。
当在虚函数声明或定义中使用时，`final`确保函数为虚并指定其不可被派生类覆盖。若这么做则程序非良构（生成编译时错误）。

#### 深浅拷贝
见下吧。

#### 移动语意和移动构造函数说一下

首先说个没关系的，右值引用指向将要被销毁的对象。
可以用move来左值转换成右值，右值也行。注意赋值之后原先的值无法被访问（被销毁）。

再来个没关系的，如果浅拷贝a到b，销毁了a之后b就是野东西了。这是深浅拷贝到问题。

通俗一点的解释就是，拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。
正常的说，移动构造函数完成了内存移动，斩断了原对象和堆存的关系，并确保A-B后不再使用A，即便销毁了也没有问题的状态。

```c++
class A{
public:    
    A(A &&tempa) noexcept :m_pb(tempa.m_pb){
        tempa.m_pb = nullptr;//noexcept通知标准库这个移动构造函数不抛出任何异常
    }
private:
    B *m_pb;
}

```

那么赋值同理

```c++
A &operator=(const A& src){
    if(this == &src) return *this;
    delete m_pb;
    m_pb = new B(*(src.m_pb));
    return *this;
}//拷贝
A &operator=(A&& src){
    if(this == &src) return *this;
    delete m_pb;
    m_pb = src.m_pb;//直接拿过来用
    src.m_pb = nullptr;
    return *this;
}//移动赋值
```

#### 右值引用

右值引用:
C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，右值是由两个概念构成，将亡值和纯右值。纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等，而将亡值通常是指具有转移语义的对象，比如返回右值引用T&&的函数返回值等。
C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：
T && a=ReturnRvale();
假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。
基于右值引用可以实现转移语义和完美转发新特性。

完美转发就是函数参数里有&&，那么会自动分辨出左值右值，尤其可以辨认出常量左值和左值引用。至于右值引用，其实就已经是个左值了...
注意要用模版函数去转发。

#### 四种cast强转
1、const_cast
用于将const变量转为非const
2、static_cast
用于各种隐式转换，比如非const转const，void * 转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
3、dynamic _ cast
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
向上转换：指的是子类向基类的转换
向下转换：指的是基类向子类的转换
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
4、reinterpret_cast
几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；
5、为什么不使用C的强制转换？
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

#### c和c++
设计思想上：
C++是面向对象的语言，而C是面向过程的结构化编程语言
语法上：
C++具有封装、继承和多态三种特性
C++相比C，增加多许多类型安全的功能，比如强制类型转换、
C++支持范式编程，比如模板类、函数模板等


C语言面向过程，重点在于算法和数据结构。。C程序的设计首先考虑的是如 何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控 制）。
C++语言是面向对象语言，首先考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的 问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 它在C的基础上添加了面向对象、模板等现在程序设计语言的特性。拓展了面向对象设计的内容，如类、继承、虚函数、模板和容器类等等，使之更加符合现代程序设计的需要。

解释对编译：Java是一种解释性语言，意味着其在执行时会被“翻译”为二进制形式，也就是java跑得时候必须有人（jvm）去解释它
内存安全：Java是一种内存安全型语言
指针
重载
多继承


#### c++各种特性
1.多态
静态（模版、重载），动态（重写）
2.封装

3.继承
单一、多重、菱形等等

##### 什么是多态
一个接口，多种方法
动态多态：    是指在程序运行时才能确定函数和实现的链接（虚函数）
静态多态：  是在编译期就把函数链接起来，此时即可确定调用哪个函数或模板，静态多态是由模板和重载实现的
overload是重载：允许同名函数的表现，参数列表／类型不同
override是重写：虚函数允许子类重写

##### 什么是封装
封装就是将抽象得到的数据和行为相结合，形成一个有机的整体

##### 什么是继承
继承就是新类从已有类那里得到已有的特性。 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，

子类继承基类后，可以创建子类对象来调用基类函数，变量等

#### 析构函数默认不为虚？
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

#### fork
Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：
```
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```
成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。

最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

#### 树的父节点表示法
树中除了根节点之外，每个节点都有且仅有一个父节点，为了记录树中节点与节点之间的父子关系，可以为每个节点增加一个parent域，用以记录该节点的父节点。

#### I/O复用（的三种方法）（其实是socket的知识）
select、poll、epoll这三组I/O复用系统调用都能同时监听多个文件描述符，他们都通过timeout参数指定要等待的时间。直到事件就绪时返回，返回值就是就绪的文件描述符的数量。
##### select函数
该函数运行进程指示内核等待多个事件中的任何一个发生，并只有一个或多个事件发生或经历一段指定的时间后才唤醒它。
##### poll
poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构。
##### epoll
epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。

1、select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。

2、select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。

### 算法结构的

#### 红黑树和平衡二叉树的区别？
红黑树旋转次数变少，在插入删除多的情况下优于AVL
AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。

#### b树


#### 插入查找都是logn的非树结构？
跳表

#### 排队（消息队列）
就一种思想，生产者消费者+队列

#### 混合的适合插入查询的数据结构
数组+链表

#### 查询效率均等的数据结构
B+Tree 深度一致。

#### 索引是什么作用
加快查找速度，一般用b+树实现
与红黑树相比，有更少的查找次数、更好的磁盘预读性
1.b+tree索引，用于查找、排序、分组
2.哈希索引，无法排序分组，只能精确查找，不能部分、范围。
3.全文索引，倒排索引实现

大大减少了服务器需要扫描的数据行数
帮助服务器避免排序分组、避免创建临时表
随机io变为顺序io

#### 哈希三种检测冲突
1.拉链法：拉链法使用链表来存储 hash 值相同的键，从而解决冲突。查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找。
2.再散列：线性探测（当冲突发生时，向前探测一个空位来存储冲突的键），二次探测、伪随机探测
3.再哈希：就继续hash直到不冲突
4.公共溢出区：建立一个公共溢出区域，把hash冲突的元素都放在该溢出区里。查找时，如果发现hash表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。



#### 树的父节点表示法
树中除了根节点之外，每个节点都有且仅有一个父节点，为了记录树中节点与节点之间的父子关系，可以为每个节点增加一个parent域，用以记录该节点的父节点。


#### 池化思想

### 操作系统的

#### 线程／进程
##### 线程和进程的区别
线程是进程里的一个执行单元
线程调度分配的基本单位／进程是拥有资源的基本单位
不同进程可以并发／同进程的多个线程可以并发
进程拥有资源／线程访问进程的自由
创建撤销进程时，分配回收资源／线程则很少

##### 进程间通信

进程间通信的方式：
进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

1.管道：
管道主要包括无名管道和命名管道:**管道可用于具有亲缘关系的父子进程间的通信**，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信
1.1 普通管道PIPE：
1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端
2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。
1.2 命名管道FIFO：
1)FIFO可以在无关的进程之间交换数据
2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

2. 系统IPC（进程间通信）：
  2.1 消息队列
  消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；
  特点：
  1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
  2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
  3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。
  2.2 信号量semaphore
  信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
  特点：
  1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
  2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
  3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减意正整数。
  4)支持信号量组。
  2.3 信号signal
  信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
  2.4 共享内存（Shared Memory）
  它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等
  特点：
  1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取
  2)因为多个进程可以同时操作，所以需要进行同步
  3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问
3. 套接字SOCKET：
  socket也是一种进程间通信机制，与其他通信机制不同的是，**它可用于不同主机之间的进程通信。**

##### 线程间通信
  线程间通信的方式:（也是线程间同步的方式）
  临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
  互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
  信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作
  事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

需要注意的是，临界区是效率最高的，因为基本不需要其他的开销，二内核对象涉及到用户态和内核态的切换，开销较大，另外，关键段、互斥量具有[线程所有权]的概念，因此只可以用于线程之间互斥，而不能用到同步中。只有互斥量能完美解决进程意外终止所造成的“遗弃问题”。

##### 扯些线程
线程通信主要作用为线程同步
多线程就是一个进程里有多个线程
但是多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。

基于进程的多任务处理是程序的并发执行。
基于线程的多任务处理是同一程序的片段的并发执行。

c++11有线程库

互斥是一种特殊的同步

##### 线／进程的基本概念

进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；

线程，有时称为轻量级进程，是CPU调度和分派的基本单位；它由线程ID、程序计数器、寄存器集合和堆栈组成。它与属于同一进程的其他线程共享其代码段、数据段和其他操作系统资源（如打开文件和信号）。

线程有四种状态：新生状态、可运行状态、被阻塞状态、死亡状态

##### 多线程同步和互斥有几种实现方法，都是什么？

见上通信

##### 多进程同步
信号量
互斥锁
管程

好了这问题就这样吧，乱七八糟的也说不清楚。

##### 互斥和同步

所谓同步，表示有先有后，比较正式的解释是“线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。”所谓互斥，比较正式的说明是“线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。”表示不能同时访问，也是个顺序问题，所以互斥是一种特殊的同步操作。

举个例子，设有一个全局变量global，为了保证线程安全，我们规定只有当主线程修改了global之后下一个子线程才能访问global，这就需要同步主线程与子线程，可用关键段实现。当一个子线程访问global的时候另一个线程不能访问global，那么就需要互斥。

##### 多线程中栈与堆是公有的还是私有的

栈私有, 堆公有

##### 以下多线程对int型变量x的操作，哪几个需要进行同步： 
　　　　A. x=y;      B. x++;    C. ++x;    D. x=1;

答案是ＡＢＣ，显然，y的写入与x读y要同步，x++和++x都要知道x之前的值，所以也要同步。

##### 在Windows编程中互斥量与临界区比较类似，请分析一下二者的主要区别。

　　  1）互斥量是内核对象，所以它比临界区更加耗费资源，但是它可以命名，因此可以被其它进程访问

　　  2）从目的是来说，临界区是通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
	互斥量是为协调共同对一个共享资源的单独访问而设计的。 

##### 线程不安全
当多个线程并发访问同一个资源对象时，可能会出现线程不安全的问题，比如现有100个高铁座位,现在有请三个窗口(A,B,C)同时售票.，此时使用多线程技术来实现这个案例.
。。。
为什么编号为84的座位号被3个窗口售出了？
当A窗口打印84座位号，还没打印完的时候，其他两个线程就也进入到了84号座位票的分配操作中，所以导致线程安全问题。
要解决上述多线程并发访问多一个资源的安全性问题，就必须得保证打印座位号和座位号总数减1操作,必须同步完成.即是说，A线程进入操作的时候,B和C线程只能在外等着,A操作结束,A和B和C才有机会进入代码去执行.

解决多线程并发访问资源的安全问题，有三种方式：
方式1:同步代码块
方式2:同步方法
方式3:锁机制(Lock)

#####  协程的作用
>没有啥复杂的东西，考虑清楚需求，就可以很自然的衍生出这些解决方案。
>一开始大家想要同一时间执行那么三五个程序，大家能一块跑一跑。特别是UI什么的，别一上计算量比较大的玩意就跟死机一样。于是就有了并发，从程序员的角度可以看成是多个独立的逻辑流。内部可以是多cpu并行，也可以是单cpu时间分片，能快速的切换逻辑流，看起来像是大家一块跑的就行。
>但是一块跑就有问题了。我计算到一半，刚把多次方程解到最后一步，你突然插进来，我的中间状态咋办，我用来储存的内存被你覆盖了咋办？所以跑在一个cpu里面的并发都需要处理上下文切换的问题。进程就是这样抽象出来个一个概念，搭配虚拟内存、进程表之类的东西，用来管理独立的程序运行、切换。
>后来一电脑上有了好几个cpu，好咧，大家都别闲着，一人跑一进程。就是所谓的并行。
>因为程序的使用涉及大量的计算机资源配置，把这活随意的交给用户程序，非常容易让整个系统分分钟被搞跪，资源分配也很难做到相对的公平。所以核心的操作需要陷入内核(kernel)，切换到操作系统，让老大帮你来做。
>有的时候碰着I/O访问，阻塞了后面所有的计算。空着也是空着，老大就直接把CPU切换到其他进程，让人家先用着。当然除了I\O阻塞，还有时钟阻塞等等。一开始大家都这样弄，后来发现不成，太慢了。为啥呀，一切换进程得反复进入内核，置换掉一大堆状态。进程数一高，大部分系统资源就被进程切换给吃掉了。后来搞出线程的概念，大致意思就是，这个地方阻塞了，但我还有其他地方的逻辑流可以计算，这些逻辑流是共享一个地址空间的，不用特别麻烦的切换页表、刷新TLB，只要把寄存器刷新一遍就行，能比切换进程开销少点。
>如果连时钟阻塞、 线程切换这些功能我们都不需要了，自己在进程里面写一个逻辑流调度的东西。那么我们即可以利用到并发优势，又可以避免反复系统调用，还有进程切换造成的开销，分分钟给你上几千个逻辑流不费力。这就是用户态线程。
>从上面可以看到，实现一个用户态线程有两个必须要处理的问题：一是碰着阻塞式I\O会导致整个进程被挂起；二是由于缺乏时钟阻塞，进程需要自己拥有调度线程的能力。如果一种实现使得每个线程需要自己通过调用某个方法，主动交出控制权。那么我们就称这种用户态线程是协作式的，即是协程。
>本质上协程就是用户空间下的线程。

#### cpu调度进程方式
即按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程，如果没有就绪进程，系统会安排一个系统空闲进程或idle进程。

FCFS
最短作业优先SJF
最短剩余时间优先SRTN
最高响应比优先算法HRRN
时间片轮转调度算法（Round Robin——RR）
优先级调度算法
多级反馈

##### 时间片轮转原理
将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程

#####  线程切换时发生了什么

发生了一次上下文切换——保存上个任务状态，切换到下个任务。（信息会存在结构体里扔进等待队列）

#### 死锁及避免
互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
占有和等待：已经得到了某个资源的进程可以再请求新的资源。
不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

避免：银行家算法

解除：破坏条件。
利用抢占恢复
利用回滚恢复
通过杀死进程恢复

#### 内存相关
##### 页面置换算法
1. 最佳OPT
2. 最近最久未使用LRU
3. 最近未使用NRU
4. 先进先出FIFO
5. 第二次机会算法
6. 时钟

##### LRU原理
为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。代码见手撕

##### 缺页中断
缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

##### 页面抖动和驻留集
在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。
工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。

##### 驻留集大小
对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页。也就是说，给特定的进程分配多大的主存空间，这需要考虑以下几点：
分配给一个进程的存储量越小，在任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率。
如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高。
如桌页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。

基于这些因素，现代操作系统通常采用三种策略：
固定分配局部置换。它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。
可变分配全局置换。这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。
可变分配局部置换。它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度； 反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

##### 局部性原理
操作系统的虚拟地址空间的技术，进程调度，以及缓存磁盘文件系统中最近被使用的磁盘块等都用到了局部性原理
具体的来说就是我一块缓存，每次读一个数据很亏，既然转到了那我不如每次读连续的一段数据，用不用得到另说，但是符合局部性的就会很快。

##### 虚拟地址空间技术
为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 **事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。**还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。


请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。


#### 操作系统对内存如何管理
段页式
那么，引入分段存储管理方式的目的，则主要是为了满足用户（程序员）在编程和使用上多方面的要求
页提高内存利用率
内存中连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的大块空间，但须为之付出很大开销。
如果允许将一个进程直接分散地装入到许多不相邻的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式。

##### 分页与分段的区别
段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。
段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定
段向用户提供二维地址空间；页向用户提供的是一维地址空间
段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

#### 阻塞与非阻塞的区别／同步与异步
比如我在线程A中调用了fun()函数。
同步/异步：针对的被调用者的状态。也就是fun函数。（也就是上面的烧水壶）
同步是指fun如果没有结果就不会返回，除非有结果了。
异步是指fun在被调用之后就立即返回了。返回结果之后再通知调用者（可以用信号、回调之类的实现）。

阻塞/非阻塞：主要是针对调用者的，是指程序在等待结果时的状态。（也就是上面的老张在等水开时的状态）
阻塞是指调用线程会被挂起，不做什么别的事情。在得到结果之后才会返回。
非阻塞是指不能立即得到结果，当前线程不会被挂起，还可以做别的事情。

老张把水壶放到火上，立等水开。（同步阻塞）
老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）
老张把响水壶放到火上，立等水开。（异步阻塞）
老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）


#### lib和dll区别
（1）lib是编译时用到的，dll是运行时用到的。如果要完成源代码的编译，只需要lib；如果要使动态链接的程序运行起来，只需要dll。
（2）如果有dll文件，那么lib一般是一些索引信息，记录了dll中函数的入口和位置，dll中是函数的具体内容；如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。使用静态编译的lib文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行。
（3）动态链接的情况下，有两个文件：一个是LIB文件，一个是DLL文件。LIB包含被DLL导出的函数名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到DLL文件。

##### 动态静态链接库的优缺点
1 静态链接库的优点 
 (1) 代码装载速度快，执行速度略比动态链接库快； 
 (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 

2 动态链接库的优点 
 (1) 更加节省内存并减少页面交换；
 (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；
 (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；
 (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

3 不足之处
 (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；
 (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。


### 计算机网络的

#### 各层作用（协助理解）
数据链路层
是负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。 传输有地址的帧以及错误检测功能 。
一、流量控制
二、错误检测和纠正
在这一层，数据的单位称为 帧 （frame）

网络层
负责相邻计算机之间的通信。
一、处理来自传输层的分组发送请求
二、处理输入数据报
三、处理路径、流控、拥塞等问题
网络层包括：
IP是网络层的核心，通过路由选择将下一跳IP封装后交给接口层。IP数据报是无连接服务。 　　
ICMP是网络层的补充，可以回送报文。用来检测网络是否通畅。 
ARP是正向地址解析协议，通过已知的IP，寻找对应主机的MAC地址。
RARP是反向地址解析协议，通过MAC地址确定IP地址。比如无盘工作站和DHCP服务。
在这一层，数据的单位 称 数据包 （packet）

传输层
网络层负责点到点（point-to-point）的传输（这里的"点"指主机或路由器）,而传输层负责端到端（end-to-end）的传输（这里的"端"指源主机和目的主机）
提供应用程序间的通信。其功能包括：
一、格式化信息流；
二、提供可靠传输。

四、应用层
向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。

#### 以太网帧结构
以太网特点：传输速率高;结构简单;工作可靠
以太网上使用两种标准帧格式。
当Type字段值小于等于1500（或者十六进制的0x05DC）时，帧使用的是IEEE 802.3格式。
当Type字段值大于等于1536 （或者十六进制的0x0600）时，帧使用的是Ethernet II格式。
以太网中大多数的数据帧使用的是Ethernet II格式。

Ethernet II：
DMAC（Destination MAC）是目的MAC地址。DMAC字段长度为6个字节，标识帧的接收者。
SMAC（Source MAC）是源MAC地址。SMAC字段长度为6个字节，标识帧的发送者。
类型字段（Type）用于标识数据字段中包含的高层协议，该字段长度为2个字节。类型字段取值为0x0800的帧代表IP协议帧；类型字段取值为0806的帧代表ARP协议帧。
数据字段(Data)是网络层数据，最小长度必须为46字节以保证帧长至少为64字节，数据字段的最大长度为1500字节。
循环冗余校验字段（FCS）提供了一种错误检测机制。该字段长度为4个字节。

IEEE802.3
DMAC
SMAC
Length字段定义了Data字段包含的字节数。
逻辑链路控制LLC由目的服务访问点DSAP、源服务访问点SSAP和Control字段组成。
子网访问控制SNAP由机构代码和类型（Type）字段组成。
Data
FCS

数据链路层基于MAC地址进行帧的传输

#### 集线器、交换机、路由器的作用
1.集线器：相当于一个中继器，它可以放大传输的信号，数据传输的方式是共享的，比如一个集线器连接了8个主机，当1号想向8号发送信息时，数据会在这条线路中进行广播。另外，集线器不能分割冲突域也不能分割广播域。

2.交换机：交换机相当于一个智能的多端口集线器，其运行在OSI模型的第二层即数据链路层，所以交换机通过MAC地址寻找主机，它是独享网络。数据进行端到端的传输。它可以分割冲突域但是不能分割广播域。

3.网桥：网桥是一个网络硬件协议翻译器。它能让两种不同数据链路层协议的网段进行信息的交流。它是一个聪明的中继器，在数据链路层中实现局域网的互联，运行在数据链路层上。它通过接受，存储，地址过滤和转发的方式实现互联网络之间的通信，它的缺点是没有流量监控，当数据流量太大是，就会帧丢失，另外，网桥在转发是要先进行帧缓存，因此会比中继器延迟。最后，它可以分割冲突域但是不能广播域。

4，路由器：路由器又称为网关设备（Gateway），主要作用是为数据进行分组转发，流量监控，并且为分组提供一个最优的网络传输路径，它跟交换机的区别在于路由器运行在网络层上，而交换机运行在数据链路层，所以路由器利用IP地址来寻址。另外，路由器可以分割冲突域也能分割广播域。

村里打帝国时代的联机。

#### ARP 协议的作用，以及维护 ARP 缓存的过程
每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

#### tcp和udp的区别
tcp 传输控制协议
udp 用户数据报协议 包头只有端口号和长度校验和
udp 需要资源少（简单）、需要处理快（无拥塞控制可以丢包）、不需要一对一（不面向连接，一对多）
tcp包头：
端口号 序号（有序了） 确认序号（解决丢包） 状态位（维护状态） 窗口大小 
三次握手建立连接
四次握手断开连接
可靠传输：
确认应答（发ack回来）、超时重传（重传去重）、滑动窗口（快重传）
拥塞控制：
慢启动-拥塞窗口、延迟应答

区别：
TCP 是面向连接的，UDP 是面向无连接的
UDP程序结构较简单
TCP 是面向字节流的，UDP 是基于数据报的
TCP 保证数据正确性，UDP 可能丢包
TCP 保证数据顺序，UDP 不保证

什么是面向连接：
在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会

##### TCP可靠连接：
通过 TCP 连接传输的数据无差错。
TCP 报文头里面的序号能使 TCP 的数据按序到达
报文头里面的确认序号能保证不丢包，累计确认及超时重传机制
注意ack回复是有延迟的，ack丢了无妨，后面补上可知信息。包丢了就会重复回复ack，然后快重传。
其中，超时重传如下：如果没收到我发出的包的ack，在一定时间后会重传。配合窗口效率最大化。TCP为了保证任何环境下都能保持较高性能的通信, 因此会动态计算这个最大超时时间，累计过一定次数就关闭连接，如果收到重复就靠靠序列号去重。
TCP 拥有流量控制及拥塞控制的机制

##### 三次握手，四次握手
为什么连接的时候是三次握手，关闭的时候却是四次握手？
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

##### TIME_WAIT
为什么要有Time_wait
1、确保有足够的时间让对方收到ACK包；（一来一去刚好是2MSL）
2、避免新旧连接混淆
为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

##### 拥塞控制的方式
慢启动：
从小到大逐渐增大发送端的拥塞控制窗口数值

拥塞避免算法如下：
（1）TCP连接初始化，将拥塞窗口设置为1
（2）执行慢开始算法，cwnd按指数规律增长，知道cwind=ssthress时，开始执行拥塞避免算法，cwnd按线性规律增长
（3）当网络发送拥塞，把ssthresh值更新为拥塞前ssthresh的一半，cwnd重新设置为1，然后再执行

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）
而不要等到自己发送数据时捎带确认。快重传算法规定发送方只要已收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待

##### kcp
KCP是一个可靠的传输协议，UDP本身是不可靠的，所以需要额外信息来保证传输数据的可靠性。因此，我们需要在传输的数据上增加一个包头。用于确保数据的可靠、有序。

conv:连接号。UDP是无连接的，conv用于表示来自于哪个客户端。对连接的一种替代
cmd:命令字。如，IKCP_CMD_ACK确认命令，IKCP_CMD_WASK接收窗口大小询问命令，IKCP_CMD_WINS接收窗口大小告知命令，
frg:分片，用户数据可能会被分成多个KCP包，发送出去
wnd:接收窗口大小，发送方的发送窗口不能超过接收方给出的数值
ts:时间序列
sn:序列号
una:下一个可接收的序列号。其实就是确认号，收到sn=10的包，una为11
len：数据长度
data:用户数据

快速重传机制—无延迟ACK回复模式
>假如开启KCP的快速重传机制，并且设置了当重复的ACK个数大于resend时候，直接进行重传。 当发送端发送了1,2,3,4,5五个包，然后收到远端的ACK：1,3,4,5。当收到ACK3时，KCP知道2被跳过1次，当收到ACK4的时候，KCP知道2被跳过2次，当次数大于等于设置的resend的值的时候，不用等到超时，可直接重传2号包。这就是KCP的快速重传机制。

KCP是选择性重传，只重传真正丢失的数据包。
超时重传1.5倍增长
流量控制同tcp
KCP的ACK是否延迟发送可以调节。
拥塞控制可以关闭

本质而言，kcp就是一arq协议。只是tcp是为流量设计的，kcp是为流速设计的。

##### 粘包
站在传输层的角度, TCP是一个一个报文传过来的. 按照序号排好序放在缓冲区中.
站在应用层的角度, 看到的只是一串连续的字节数据.

那么如何避免粘包问题呢?
归根结底就是一句话, 明确两个包之间的「边界」

#### udp是如何进行一对多传输的
广播：一对所有，只能在子网中传播（在同一个路由器中传播），子网上的所有节点都能收到信息
组播：一对多，一个发送者对多个接收者
多播，也称为“组播”，将网络中同一业务类型主机进行了逻辑上的分组，进行数据收发的时候其数据仅仅在同一分组中进行，其他的主机没有加入此分组不能收发对应的数据。

##### 广播时socket是什么样子的
![网图](https://img-blog.csdnimg.cn/2018103110011619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjc1MDYyMw==,size_5,color_FFFFFF,t_70)


#### socket

##### Socket是什么呢？
>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

>Socket 的中文翻译过来就是“套接字”。套接字是什么，我们先来看看它的英文含义：插座。
Socket 就像一个电话插座，负责连通两端的电话，进行点对点通信，让电话可以进行通信，端口就像插座上的孔，端口不能同时被其他进程占用。而我们建立连接就像把插头插在这个插座上，创建一个 Socket 实例开始监听后，这个电话插座就时刻监听着消息的传入，谁拨通我这个“IP 地址和端口”，我就接通谁。
实际上，Socket 是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作抽象为几个简单的接口，供应用层调用实现进程在网络中的通信。Socket 起源于 UNIX，在 UNIX 一切皆文件的思想下，进程间通信就被冠名为文件描述符（file descriptor），Socket 是一种“打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个“文件”，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。

![img](https://image-static.segmentfault.com/424/131/4241315319-5818ad16c6539_articlex)

1）基于TCP的socket：
1、服务器端程序：
1创建一个socket，用函数socket()
2绑定IP地址、端口等信息到socket上，用函数bind()
3设置允许的最大连接数，用函数listen()
4接收客户端上来的连接，用函数accept()
5收发数据，用函数send()和recv()，或者read()和write()
6关闭网络连接

2、客户端程序：
1创建一个socket，用函数socket()
2设置要连接的对方的IP地址和端口等属性
3连接服务器，用函数connect()
4收发数据，用函数send()和recv()，或read()和write()
5关闭网络连接


2）基于UDP的socket：
1、服务器端流程
1-建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。
2-设置服务器地址和侦听端口，初始化要绑定的网络地址结构。
3-绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。
4-接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。
5-向客户端发送数据，使用sendto()函数向服务器主机发送数据。
6-关闭套接字，使用close()函数释放资源。UDP协议的客户端流程

2、客户端流程
1-建立套接字文件描述符，socket()。
2-设置服务器地址和端口，struct sockaddr。
3-向服务器发送数据，sendto()。
4-接收服务器的数据，recvfrom()。
5-关闭套接字，close()。

#### ip报文头

IP协议是网络层的主要协议，为上层传输层提供无连接、无状态、不可靠的服务。优点是简单高效。无状态是指各个IP报文是独立传送的，不同步传输状态的信息，所以容易发生重复和乱序的情况。不可靠是指IP协议不能保证数据报一定能被送达，可靠性主要是通过传输层的TCP协议来保证的。

4位版本，4位首部长度，8位服务类型，16位总长度
16位标识（每个数据报计数器+1，同计数分片拼装），3位标志（后面还有没，可否分片），13位片位移（较长的分组在分片后，某片在原分组中的相对位置）
8位生存时间TTL（指明数据报在网络中至多可经过多少个路由器），8位协议，16位首部校验和
32位源ip
32位目的ip

##### ICMP协议
通常被认为是IP层的组成部分，一般被IP层或更高层（TCP、UDP）使用。
ICMP报文是在IP数据报内部被传输的，即ip数据报如下
ip首部-icmp报文
报文的前4个字节都一样： 8bit类型，8bit代码，16bit检验和。

##### ping
ping程序是由Mike Muuss编写，目的是为了测试一个主机是否能到达。
该程序的原理就是向目的主机发送一个请求回显类型（ICMP众多类型的一个，类型是8，代码是0）的ICMP报文，并等待返回ICMP回显应答（ICMP众多类型的一个，类型是0，代码是0）。
##### traceroute
traceroute程序--可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由情况。

ping程序中也提供了查看IP记录路由选项，为啥还要再搞一个traceroute咧？主要原因还是因为IP首部选项能存储的ip数量太少了，最多9个。如果只考虑去和回的一个方向，那么最多只能存储4-5个路由，这在现在的互联网规模来看显然是不太满足的。
traceroute几个核心知识：利用TTL通过路由减1，直到变为1或者0时（路由不会传送TTL为0的包），路由就会发送超时类型的ICMP报文通知源端主机。利用UDP发送一般不常见的端口号给目的主机，当真正到达目的主机时，目的主机会发送一个端口不可达错误的ICMP报文（在未到达时，是路由返回的超时类型的ICMP报文，需要辨识开）。源端主机根据这个确认是否到达。TTL开始是1，逐渐递增。
整个就一骗子程序，疯狂骗路由ip

#### 什么是端口?
> 我们之前在初识进程中知道，单个计算机进程是用进程标示符（PID）标志的。但是在互联网的大环境下，操作系统很多，不同的操作系统有不同的进程标识符，所以仅仅用进程标示符是不足够的。
> 因此，为了让不同操作系统的计算机应用程序能够互相通信，就必须用统一的方法对进程进行标志
> 但就算使用统一的标示符进行标识，也存在问题

> 1.进程的创建和撤销是动态的，通信的一方几乎无法识别对方的进程
> 2.我们需要主机提供的功能来识别通信的重点，但是我们无法识别具体的进程是哪个
> 所以：运输层使用“”协议端口号“来解决这个问题，就是端口号。
> 端口号解决了传输层的分用问题

常见端口：1.HTTP协议代理服务器常用端口号：80/8080/3128/8081/9098

2.SOCKS代理协议服务器常用端口号：1080

3.FTP（文件传输）协议代理服务器常用端口号：21

4.Telnet（远程登录）协议代理服务器常用端口号：23

5.DNS端口为53 UDP,是用来做DNS解析的

HTTP服务器，默认端口号为80/tcp（木马Executor开放此端口）

HTTPS（securely transferring web pages）服务器，默认端口号为443/tcp 443/udp

SSH（安全登录）、SCP（文件传输）、端口号重定向，默认的端口号为22/tcp


#### DNS全过程
1.检查浏览器缓存中是否缓存过该域名对应的IP地址
2.如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP
3.向本地域名解析服务系统发起域名解析的请求
4.向根域名解析服务器发起域名解析请求
5.根域名服务器返回gTLD（通用顶级域）域名解析服务器地址
6.向gTLD服务器发起解析请求
7.接受请求并返回Name Server服务器
8.返回IP地址给本地服务器
9.本地域名服务器缓存解析结果
10.返回给用户

多使用UDP

负载均衡
将流量均摊到多个服务器上

一个域名访问多个IP地址。当客户端请求解析域名时，DNS服务器查询文件中的记录按顺序返回不同的解析结果，从而将客户访问引导到不同的服务器上去，从而实现负载均衡。

#### http协议
>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。
通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。
HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。
HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。
浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。

##### http和https的区别
HTTPS和HTTP的区别主要如下：
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

#### 帧同步，状态同步的实现原理
同步问题的本质是一致性的问题，在同一局多人游戏的过程中，玩家A看到玩家B的状态，应该跟玩家B自身看到自己的状态相一致。延迟是造成不一致的本质原因，假设理想情况下双方的网络时延都为0，那两者应该是同步的，但是在现实情况中，往往是不可能的，本文讨论的同步机制，就是为了解决一致性问题而产生的，对于不同的游戏类型，不同的团队技术积累，可以根据自身情况采取不同的同步机制技术方案。
##### 状态同步
状态同步主要是指客户端发送游戏动作到服务器，服务器收到后对游戏行为结果进行计算，
然后通过广播下发游戏各种状态到客户端，客户端受到状态信息后进行UI层展示或处理。
这种方式类似于核心逻辑计算都在服务器端进行，客户端主要负责上传操作动作等请求数据，
一般回合制游戏主要采用这种方式
##### 帧同步
客户端发送游戏动作到服务器，服务器广播转发所有客户端的动作（或者客户端直接通过P2P技术发送），客户端根据收到的所有游戏动作来做游戏运算和显示。这种做法等于客户端之间互相远程控制其他客户端上的游戏软件。早期的IPX网络游戏，如红色警戒、帝国时代、星际争霸，甚至大量的支持网络连线双打的游戏机模拟器，都是这种方式

### 设计原则
S.O.L.I.D
简写	全拼	中文翻译
SRP	The Single Responsibility Principle	单一责任原则
OCP	The Open Closed Principle	开放封闭原则
LSP	The Liskov Substitution Principle	里氏替换原则
ISP	The Interface Segregation Principle	接口分离原则
DIP	The Dependency Inversion Principle	依赖倒置原则
1. 单一责任原则
修改一个类的原因应该只有一个。

换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

2. 开放封闭原则
类应该对扩展开放，对修改关闭。

扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。

3. 里氏替换原则
子类对象必须能够替换掉所有父类对象。

继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。

如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

4. 接口分离原则
不应该强迫客户依赖于它们不用的方法。

因此使用多个专门的接口比使用单一的总接口要好。

5. 依赖倒置原则
高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

任何变量都不应该持有一个指向具体类的指针或者引用；
任何类都不应该从具体类派生；
任何方法都不应该覆写它的任何基类中的已经实现的方法。