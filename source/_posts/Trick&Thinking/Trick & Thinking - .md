---
title: Trick & Thinking - 1
date: 2020-01-16 16:57:58
tags:
- c++
- trick

categories:
- trick

---

在学习的过程中接触到了一些...稀奇古怪的玩意，大概都是一些指导思想或者是小Trick，这里一并记录一下。
<!--more-->

---

# 前言
因为这些东西牵涉甚广，所以不要想着一下子就理解或者搞懂，这篇坑我会慢慢补，先盖个大概出来。
因为其实很多本质上是很高层的东西，所以可能也许以后会当作读物放松的时候看一下，但不是现在。

## DDD

## Bean
### JavaBean
JavaBean是公共Java类，但是为了编辑工具识别，需要满足至少4个条件：
1、所有属性为private
2、提供默认构造方法
3、提供getter和setter
4、实现serializable接口
在java1996年发布,当年12月即发布了java bean1.00-A,有什么用呢?通过统一的规范可以设置对象的值(get,set方法),这是最初的java bean;在实际企业开发中,需要实现事务,安全,分布式,javabean就不好用了.sun公司就开始往上面堆功能,这里java bean就复杂为EJB;EJB功能强大,但是太重了.此时出现DI(依赖注入),AOP(面向切面)技术,通过简单的java bean也能完成EJB的事情,这里的java bean简化为POJO;Spring诞生了.
#### PO
#### VO
#### DTO
### Spring bean
Spring bean是Spring框架在运行时管理的对象。Spring bean是任何Spring应用程序的基本构建块。你编写的大多数应用程序逻辑代码都将放在Spring bean中。

## Convention Over Configuration
惯例优先原则；约定优先配置

## AOP

## IOC
    Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。
是一个解耦合的过程，通过从其他地方定义对象（对象的具体注入），来保证开关原则（主业务对修改关闭，对扩展开放）核心机制建立在Java的反射上。
谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）
为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。

>IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。

>IoC很好的体现了面向对象设计法则之一 —— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。

### DI
    DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。

+ 谁依赖于谁：当然是应用程序依赖于IoC容器；

+ 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；

+ 谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；

+ 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。

IoC和DI由什么关系呢？其实它们是**同一个概念的不同角度描述**，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。

### 最后
>作者：Robert Zee
>链接：https://www.zhihu.com/question/318377502/answer/641205726
>来源：知乎
>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

>现在大多数网上的教程都是你抄我，我抄你，来源都是Spring Boot的官网。这些教程只是手把手教你怎么搭建一个基于Spring Boot的网站，但基本没有告诉你设计思路。想要了解Spring Boot的好处，以及为什么把它设计成这个样子，就需要了解它的本体Spring Framework。要了解Spring Framework，以及它产生和变化的原因，就需要有一些它的前辈EJB背景知识。现在所有的资料都告诉你关于Spring内容就是Dependency Injection (IoC) 和 AOP，让人往往摸不着头脑为什么Spring要如此依赖于IoC和AOP，原因是什么、好处是什么。事实上，IoC和AOP远远早于Spring的诞生，在EJB和传统面向过程的语言中已经广泛应用了。Spring最重要的是采用了 更好  的IoC和AOP的方式，它是演变自EJB，取长补短。所有的框架并非一蹴而就，都是经过很长时间的演变。所以我非常推荐去看看《Expert One-on-One J2EE Development without EJB》，作者是Spring Framework的Rod Johnson。前六章讲了架构设计的概念以及吐槽EJB的复杂。后面章节讲的是Spring的设计思路，这本书能够解释你在学习过程中碰到的问题。书虽然老了一些，但是架构问题千古不变，以不变应万变。

## CPS

## closures

## AST

## exception safe


## Interface As Contract
read《From Apprentice To Artisan》
https://stackoverflow.com/questions/219425/interface-contract-class-object


## SFINAE

## ADT


## 语法的一致性问题
源自轮子哥http://www.cppblog.com/vczh/archive/2013/04/27/199765.html
关于C语言的“定义和使用相一致”还有最后一个例子，这个例子也是很美妙的:
```c
int a;
typedef int a;

int (*f)(int a, int b);
typedef int (*f)(int a, int b);
```
typedef是这样的一个关键字：他把一个符号从变量给修改成了类型。所以每当你需要给一个类型名一个名字的时候，就先想一想，怎么定义一个这个类型的变量，写出来之后往前面加个typedef，事情就完成了。

不过说实话，就一致性来讲，C语言也就到此为止了。至于说为什么，因为上面这几条看起来很美好的“定义和使用相一致”的规则是不能组合的，譬如说看下面这一行代码：
```c
typedef int(__stdcall*f[10])(int(*a)(int, int));
```
这究竟是个什么东西呢，谁看得清楚呀！而且这也没办法用上面的方法来解释了。究其原因，就是C语言采用的这种“定义和使用相一致”的手法刚好是一种解方程的手法。譬如说`int *b`;定义了“`*b是int`”，那b是什么呢，我们看到了之后，都得想一想。人类的直觉是有话直说开门见山，所以如果我们知道`int*`是int的指针，那么`int* b`也就很清楚了——“b是int的指针”。 

因为C语言的这种做法违反了人类的直觉，所以这条本来很好的原则，采用了错误的方法来实现，结果就导致了“坑”的出现。因为大家都习惯“`int* a;`”，然后C语言告诉大家其实正确的做法是“`int *a;`”，那么当你接连的出现两三个变量的时候，问题就来了，你就掉坑里去了。
这个时候我们再回头看一看上面那一段长长的函数指针数组变量的声明，会发现其实在这种时候，C语言还是希望你把它看成“`int* b;`”的这种形式的：f是一个数组，数组返回了一个函数指针，函数返回int，函数的参数是`int(*a)(int, int)`所以他还是一个函数指针。

我们为什么会觉得C语言在这一个知识点上特别的难学，就是因为他同时混用了两种原则来设计语法。那你说好的设计是什么呢？让我们来看看一些其它的语言的作法：
```c++
C++:
function<int __stdcall(function<int(int, int)>)> f[10];

C#:
Func<Func<int, int, int>, int>[] f;

Haskell:
f :: [(int->int->int)->int]

Pascal:
var f : array[0..9] of function(a : function(x : integer; y : integer):integer):integer;
```