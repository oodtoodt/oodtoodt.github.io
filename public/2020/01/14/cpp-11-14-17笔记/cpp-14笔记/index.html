<!doctype html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="c++,company,c++14," />





  <link rel="alternate" href="/atom.xml" title="oodt's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon(1).ico?v=5.1.1" />






<meta name="description" content="先打预防针：14的内容不多。">
<meta name="keywords" content="c++,company,c++14">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp-14笔记">
<meta property="og:url" content="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17笔记/cpp-14笔记/index.html">
<meta property="og:site_name" content="oodt&#39;s blog">
<meta property="og:description" content="先打预防针：14的内容不多。">
<meta property="og:updated_time" content="2020-01-14T09:27:00.166Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cpp-14笔记">
<meta name="twitter:description" content="先打预防针：14的内容不多。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17笔记/cpp-14笔记/"/>





  <title>cpp-14笔记 | oodt's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">oodt's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">自杀之路</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17笔记/cpp-14笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="eco_oodt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/prpr.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="oodt's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">cpp-14笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-14T16:05:58+08:00">
                2020-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/14/cpp-11-14-17笔记/cpp-14笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/01/14/cpp-11-14-17笔记/cpp-14笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2020/01/14/cpp-11-14-17笔记/cpp-14笔记/" class="leancloud_visitors" data-flag-title="cpp-14笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>先打预防针：14的内容不多。<br><a id="more"></a></p>
<hr>
<h1 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h1><p>应该说核心内容不多，如果你想去读官方1000页文档然后说不多那我无话可说。<br>这里就只捡取最流行的一份中文文档来说了<br>如果你打开cppreference，查看c++语言核心特性，会发现c++14只有一个变量模板</p>
<p>另外贴一个知乎大大的总结：</p>
<blockquote>
<p>最后总结一下就是，C++14可以称为更加完美的C++11，这是我的观点。我觉得这些提案本就应该在C++11出现，但是却由于各种因素才拖到C++14中了。 C++的确变得更加复杂了，但是对于今天学习C++的人来说是更幸福的，少了很多奇淫技巧，多了更多照顾开发者的东西。<br>——蓝色</p>
</blockquote>
<h2 id="一篇流传很广的文档：语言特性"><a href="#一篇流传很广的文档：语言特性" class="headerlink" title="一篇流传很广的文档：语言特性"></a>一篇流传很广的文档：语言特性</h2><h3 id="泛型lambda，可以在形参中使用auto"><a href="#泛型lambda，可以在形参中使用auto" class="headerlink" title="泛型lambda，可以在形参中使用auto"></a>泛型lambda，可以在形参中使用auto</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> adder = [](<span class="keyword">auto</span> op1,<span class="keyword">auto</span> op2) &#123;<span class="keyword">return</span> op1 + op2;&#125;;</div></pre></td></tr></table></figure>
<h3 id="lambda捕捉初始化"><a href="#lambda捕捉初始化" class="headerlink" title="lambda捕捉初始化"></a>lambda捕捉初始化</h3><p>c++14允许被捕捉的成员用任意的表达式初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</div><div class="line"><span class="keyword">auto</span> lambda = [&amp;ptr]&#123;<span class="keyword">return</span> *ptr&#125;;</div><div class="line"><span class="comment">//也是可以的了 auto lambda = [ptr = std::move(ptr)]&#123;return *ptr;&#125;;</span></div></pre></td></tr></table></figure></p>
<h3 id="auto推导"><a href="#auto推导" class="headerlink" title="auto推导"></a>auto推导</h3><p>c++14的auto可以推导没有返回类型的函数了（之前必须显式声明，不过注意现在我们禁止带有歧义性的返回类型auto）<br>当decltype(auto)被用于声明变量时，该变量必须立即初始化。假设该变量的初始化表达式为e，那么该变量的类型将被推导为decltype(e)。也就是说在推导变量类型时，先用初始化表达式替换decltype(auto)当中的auto，然后再根据decltype的语法规则来确定变量的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) g1() &#123;<span class="keyword">return</span> s.a;&#125;</div><div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) i1 = a;</div><div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) i2 = <span class="built_in">std</span>::move(a);</div></pre></td></tr></table></figure></p>
<h3 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h3><p>使得没有return expression的函数也可以使用返回类型推导<br>如果你对之前的某篇文章很有印象的话，会记得有<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">auto f(int a, int b) -&gt; decltype( a + b )</div><div class="line">&#123;</div><div class="line">   int i = a + b;</div><div class="line">   return i;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; f(1,2) &lt;&lt; std::endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对，返回类型后置，当然不是用在这里的，这里举个例子。<br>c++14之后，你就可以直接<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> i = a + b;</div><div class="line">   <span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，因为不允许歧义了，所以<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (i == <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> i;          <span class="comment">// return type deduced to int</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> sum(i<span class="number">-1</span>)+i + <span class="number">0.0</span>; <span class="comment">// 这样怎么办呢？</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是不允许的</p>
<h3 id="放松了constepr"><a href="#放松了constepr" class="headerlink" title="放松了constepr"></a>放松了constepr</h3><p>放松了constexpr的概念，c++11中，constexpr函数只含有一个将返回的表达式（和包含static_assert声明在内的几个语句），c++14中则放松了这些限制<br>constexpr的函数将可以包含：</p>
<ul>
<li>任何声明，除了static和thread_local变量、没有初始化的变量声明。</li>
<li>放松了constexpr的概念，c++11中，constexpr函数只含有一个将返回的表达式（和包含static_assert声明在内的几个语句），c++14中则放松了这些限制<br>constexpr的函数将可以包含：</li>
<li>任何声明，除了static和thread_local变量、没有初始化的变量声明。</li>
<li>条件分支if和switch，goto不行</li>
<li>所有的循环</li>
<li>表达式可以改变对象值，只需该对象生命期在常量表达式函数内开始<br>调用非constexpr函数仍然是受限的，所以如果使用基于范围的for，begin和end的重载必须自身被声明为constexpr，顺便一提，std::initializer_list在本地和全局都有这东西</li>
</ul>
<p>所有被声明为constexpr的非静态成员函数也隐含声明为const（即函数不能修改*this的值）这一在c++11中定义的点在c++14中已经被删除。</p>
<p>多说几句，这个特性…</p>
<blockquote>
<p>这篇提案可谓是深得标准委员会人员的心，不可否认，这篇提案对于普通开发人员无疑是福音，因为可以再次提高性能。但是对于编译器开发人员简直是噩梦的一篇提案。说实话，在C++11的所有特性中，constexpr绝对是一个很难实现的特性，我不能透露ibm编译器如何实现的，感兴趣的可以去参看GCC或者Clang的实现。直到现在，Visual C++的实现constexpr都是Partial的状态。众所周至，constexpr有一些限定，比如只能返回一条语句等，即使这样，编译器做起来都是很头痛的一件事情。这篇提案简直逆天了，要去掉这些条件，还可以加入if，for什么的了，，具体的可以参看提案内容。我只能说简直丧心病狂，完全不管编译器开发者的死活。当时我们激烈讨论了到底怎么实现的，但是也没有讨论出来什么。但就是这篇提案，标准委员会举双手双脚赞成，而且还说有实现的先例：D语言。我也不知道该说什么了。<br>作者：蓝色<br>链接：<a href="https://www.zhihu.com/question/22765983/answer/22591090" target="_blank" rel="external">https://www.zhihu.com/question/22765983/answer/22591090</a></p>
</blockquote>
<h3 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h3><p>c++11引入了类型别名模板，c++14现在也可以创建变量模板<br>指using解决typedef在模板参数的问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">constexpr</span> T pi = T(<span class="number">3.1415926535897932385</span>);  <span class="comment">// 变量模板</span></div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function">T <span class="title">circular_area</span><span class="params">(T r)</span> <span class="comment">// 函数模板</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> pi&lt;T&gt; * r * r; <span class="comment">// pi&lt;T&gt; 是变量模板实例化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在类作用域中使用时，变量模板声明一个静态数据成员模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals;</div><div class="line"><span class="keyword">struct</span> matrix_constants</div><div class="line">&#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">    <span class="keyword">using</span> pauli = hermitian_matrix&lt;T, <span class="number">2</span>&gt;; <span class="comment">// 别名模版</span></div><div class="line"> </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="comment">// 静态数据成员模板</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> pauli&lt;T&gt; sigmaX = &#123; &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125; &#125;; </div><div class="line"> </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> pauli&lt;T&gt; sigmaY = &#123; &#123; <span class="number">0</span>, <span class="number">-1</span>i &#125;, &#123; <span class="number">1</span>i, <span class="number">0</span> &#125; &#125;;</div><div class="line"> </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> pauli&lt;T&gt; sigmaZ = &#123; &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125; &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>除非变量模板被显式特化或显式实例化，否则它在特化时隐式实例化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> limits &#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> T min; <span class="comment">// 静态数据成员模板的声明</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">const</span> T limits::min = &#123; &#125;; <span class="comment">// 静态数据成员模板的定义</span></div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">   <span class="keyword">static</span> T s; <span class="comment">// 类模板的非模板静态数据成员的声明</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">T X&lt;T&gt;::s = <span class="number">0</span>; <span class="comment">// 类模板的非模板静态数据成员的定义</span></div></pre></td></tr></table></figure></p>
<p>模板元编程离我们还有点距离，我们可以先放一放。</p>
<hr>
<h3 id="聚合体成员初始化。"><a href="#聚合体成员初始化。" class="headerlink" title="聚合体成员初始化。"></a>聚合体成员初始化。</h3><p>c++11新增member initializer(即成员初始化列表)，之前不允许聚合体初始化，现在c++14可以了<br>聚合体：<br>aggregate:详见pod那个章节，这里我们稍微提一下。数组类型、结构体、联合体、类中，没有私有、保护的非静态数据成员、无用户提供的构造函数、无基类无虚函数的都是。<br>如果聚合体中间有嵌套，可以不用花括号分割。（int arr[3],j;={1,2,3,4}，j会分配4）</p>
<h3 id="二进制字面值与数字分位符号"><a href="#二进制字面值与数字分位符号" class="headerlink" title="二进制字面值与数字分位符号"></a>二进制字面值与数字分位符号</h3><p>使用前缀0b或0B，引入’作为数字分位符号，使其具有更好的可读性。</p>
<h3 id="属性：deprecated"><a href="#属性：deprecated" class="headerlink" title="属性：deprecated"></a>属性：deprecated</h3><p>指示声明有此属性的名字或实体被弃用，即允许但因故不鼓励使用。<br>语法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[deprecated]]	(<span class="number">1</span>)	</div><div class="line">[[deprecated( 字符字面量 )]]	(<span class="number">2</span>)</div></pre></td></tr></table></figure></p>
<p>字符字面量    -    能用于解释弃用的理由并/或提议代替用实体的文本</p>
<h2 id="——————————————"><a href="#——————————————" class="headerlink" title="——————————————"></a>——————————————</h2><h2 id="新标准库的特性"><a href="#新标准库的特性" class="headerlink" title="==新标准库的特性=="></a>==新标准库的特性==</h2><h2 id="———–"><a href="#———–" class="headerlink" title="———–"></a>———–</h2><h3 id="增加了共享的互斥体和锁"><a href="#增加了共享的互斥体和锁" class="headerlink" title="增加了共享的互斥体和锁"></a>增加了共享的互斥体和锁</h3><p>std::shared_timed_mutex</p>
<h3 id="元函数别名"><a href="#元函数别名" class="headerlink" title="元函数别名"></a>元函数别名</h3><p>c++11定义了一组元函数用于查询类型是否具有某种特征，或者转换给定类型的某种特征<br>指的就是type_traits里的各种东西，以及别名模板。<br>我们先来一点前置知识学习</p>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>首先是c++11中的volatile<br>volatile:在柯林斯高级学习词典中这样解释：<br>A situation that is volatile is likely to change suddenly and unexpectedly.<br>注意，likely，suddenly，unexpectedly<br>总结来说，被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。<br>我们讨论c/c++的执行顺序时会提到——序列点。执行表达式有两种类型的动作：(1)计算某个值(2)副作用(例如访问volatile对象、原子同步、修改文件等)因此，如果两个表达式e1和e2中间有一个序列点，或者在c++中e1于序列中在e2之前，则e1的求值动作和副作用都会在e2的求值和副作用之前。<br>因此在c/c++中，对volatile对象的访问，有编译器优化上的副作用：</p>
<ul>
<li>不允许优化消失</li>
<li>于序列上在另一个对volatile对象访问之前<br>（这里其实很像原子操作的某些规则，但是volatile访问的序列性是在单线程执行的前提）<h5 id="常见的错解"><a href="#常见的错解" class="headerlink" title="常见的错解"></a>常见的错解</h5>错解：用volatile修饰while的退出flag。应该用atomic<br>volatile 本质是让编译器在每次遇到被它修饰的变量时，不能根据代码上下文假设它的状态。注意是「让『编译器』」。所以编译器不会对它做某些类型的优化，也不会交换两个 volatile 访问的顺序。但是这不保证 CPU 执行时不会交换顺序。<br>但是还是要结合一下cpu的情况，根据具体环境给一个可用不可用的范围约束。</li>
</ul>
<p>好，现在我们学会了volatile，于是我们来看remove_cv</p>
<h5 id="remove-cv"><a href="#remove-cv" class="headerlink" title="remove_cv"></a>remove_cv</h5><p>很简单！去掉const和volatile前缀，其实就是remove_const和remove_volatile的结合<br>然后呢，我们看到了type_traits头文件！<br>想到什么了吗！<br>之前没讲的，类型萃取！它leile！</p>
<h4 id="类型萃取"><a href="#类型萃取" class="headerlink" title="类型萃取"></a>类型萃取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::decay对类型进行退化处理，退化掉引用和cv符。</div><div class="line">如果is_array&lt;U&gt;::value为真，则修改类型为remove_reference&lt;U&gt;::type*</div><div class="line">否则，如果is_function &lt; U &gt; ::value为真，修改类型为add_pointer&lt; U &gt;::type</div><div class="line">否则，修改类型为remove_cv&lt; U &gt;::type</div><div class="line">可以方便的获得函数指针</div><div class="line"><span class="built_in">std</span>::result_of元函数可以获取调用对象的返回类型</div><div class="line">enable_if是利用SFINAE根据条件重载函数</div></pre></td></tr></table></figure>
<h4 id="…这和c-14有什么关系呢"><a href="#…这和c-14有什么关系呢" class="headerlink" title="…这和c++14有什么关系呢"></a>…这和c++14有什么关系呢</h4><p>但是在c++11中，它们用在模板中时，必须用typename关键字<br>c++14中提供了更便捷的写法————利用类型别名模板。规则：如果标准库的某个类模板只含有有唯一的成员，即成员类型type，那么提供std::some_class_t<t>作为typename std::some_class::type的别名<br>稍微罗列几个就懂了：</t></p>
<blockquote>
<p>remove_const,remove_volatile,remove_cv,add_const,add_reference,add_lvalue_reference(r),make_signed,make_unsigned,remove_extent,remove_all_extents,remove_pointer,aligned_storage,decay,enable_if,conditional,common_type,underlying_type,result_of,tuple_element<br>对不起发现了几个很有趣的类型就都写上了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">type_object&lt;<span class="built_in">std</span>::<span class="keyword">remove_cv_t</span>&lt;<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&gt;&gt;get_type_object(T&amp;);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>唔，似乎没说明到底是啥ww，具体就是给一个预定义的using来用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> remove_reference;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">using</span> <span class="keyword">remove_reference_t</span> = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="关联容器的异构查找"><a href="#关联容器的异构查找" class="headerlink" title="关联容器的异构查找"></a>关联容器的异构查找</h3><p>即定义了operator&lt;的都可以作为set等查找类型<br>strict weak orderings，就<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( x &lt; y ) &#123; <span class="keyword">return</span> <span class="literal">true</span>;&#125; <span class="keyword">if</span> ( y &lt; x ) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>具体请查标准库文档<br>比如const char* 与string<br>标准库的泛型比较器都支持这一点<br>如果不知道你根本不会相信以前是不支持这个东西的（指复杂度会远超logn</p>
<h3 id="新增自定义字面量特性（标准库）"><a href="#新增自定义字面量特性（标准库）" class="headerlink" title="新增自定义字面量特性（标准库）"></a>新增自定义字面量特性（标准库）</h3><p>“s”，用于创建各种std::basic_string类型<br>“h”,”min”,”s”,”ms”,”us”,”ns”用于创建相应的std::chrono::duration时间间隔</p>
<h3 id="通过类型寻址多元组"><a href="#通过类型寻址多元组" class="headerlink" title="通过类型寻址多元组"></a>通过类型寻址多元组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="built_in">string</span>,<span class="built_in">string</span>,<span class="keyword">int</span>&gt;t(<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">int</span> i = get&lt;<span class="keyword">int</span>&gt;(t);<span class="comment">//i == 7</span></div><div class="line"><span class="keyword">int</span> j = get&lt;<span class="number">2</span>&gt;(t)<span class="comment">//same as before j == 7;</span></div><div class="line"><span class="built_in">string</span> s = get&lt;<span class="built_in">string</span>&gt;(t);<span class="comment">//ce due to ambiguity</span></div></pre></td></tr></table></figure>
<h3 id="较小的标准库特性"><a href="#较小的标准库特性" class="headerlink" title="较小的标准库特性"></a>较小的标准库特性</h3><p>std::make_unique可以像std::make_shared一样使用产生std::unique_ptr对象（？为什么不在c++11里加这个）<br>std::is_final，用于识别一个class类型是否禁止被继承<br>std::integral_constant增加了一个返回常量值的operator()<br>全局std::begin/std::end函数之外，增加了std::cbegin/std::cend函数，它们总是返回常量迭代器</p>
<h3 id="c-14移除或抛弃的特性"><a href="#c-14移除或抛弃的特性" class="headerlink" title="c++14移除或抛弃的特性"></a>c++14移除或抛弃的特性</h3><p>被c++14移除的标准特性（这里指一些可能本来会在c++14出现的东西</p>
<ul>
<li>关于数组的扩展<br>在c++11和之前的标准中，在堆栈上分配的数组被限制为拥有一个固定的、编译器确定的长度。这一扩展允许堆栈上分配的一个数组最后一维拥有运行期确定的长度。<br>添加了std::dynarray类型，它拥有与std::vector和std::array类似的接口，代表一个固定长度的数组。被明显地设计为当它被放置在栈上时，可以使用栈内存而不是堆内存<br>在斟酌之后，它被从c++14中移除了。</li>
<li>optional值<br>类似于c#的可空类型，也没采用</li>
<li>concepts lite<br>回炉重造了</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>c++14结束啦。<br>补这篇文档的时候找到了不少有趣的资料，感觉很不错。<br>下篇就是c++17了，17的资料真的不多，争取明天弄完吧——</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/c/" rel="tag"># c++</a>
          
            <a href="/tags/company/" rel="tag"># company</a>
          
            <a href="/tags/c-14/" rel="tag"># c++14</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/14/cpp-11-14-17笔记/cpp-11笔记-3/" rel="next" title="cpp-11笔记_3">
                <i class="fa fa-chevron-left"></i> cpp-11笔记_3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2020/01/14/cpp-11-14-17笔记/cpp-14笔记/"
           data-title="cpp-14笔记" data-url="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17笔记/cpp-14笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/prpr.jpg"
               alt="eco_oodt" />
          <p class="site-author-name" itemprop="name">eco_oodt</p>
           
              <p class="site-description motion-element" itemprop="description">---自虐一点 开心一点</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-14"><span class="nav-number">1.</span> <span class="nav-text">C++14</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一篇流传很广的文档：语言特性"><span class="nav-number">1.1.</span> <span class="nav-text">一篇流传很广的文档：语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型lambda，可以在形参中使用auto"><span class="nav-number">1.1.1.</span> <span class="nav-text">泛型lambda，可以在形参中使用auto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda捕捉初始化"><span class="nav-number">1.1.2.</span> <span class="nav-text">lambda捕捉初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto推导"><span class="nav-number">1.1.3.</span> <span class="nav-text">auto推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数返回类型"><span class="nav-number">1.1.4.</span> <span class="nav-text">函数返回类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#放松了constepr"><span class="nav-number">1.1.5.</span> <span class="nav-text">放松了constepr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量模板"><span class="nav-number">1.1.6.</span> <span class="nav-text">变量模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚合体成员初始化。"><span class="nav-number">1.1.7.</span> <span class="nav-text">聚合体成员初始化。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制字面值与数字分位符号"><span class="nav-number">1.1.8.</span> <span class="nav-text">二进制字面值与数字分位符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性：deprecated"><span class="nav-number">1.1.9.</span> <span class="nav-text">属性：deprecated</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#——————————————"><span class="nav-number">1.2.</span> <span class="nav-text">——————————————</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新标准库的特性"><span class="nav-number">1.3.</span> <span class="nav-text">==新标准库的特性==</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#———–"><span class="nav-number">1.4.</span> <span class="nav-text">———–</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#增加了共享的互斥体和锁"><span class="nav-number">1.4.1.</span> <span class="nav-text">增加了共享的互斥体和锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元函数别名"><span class="nav-number">1.4.2.</span> <span class="nav-text">元函数别名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#volatile"><span class="nav-number">1.4.2.0.1.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#常见的错解"><span class="nav-number">1.4.2.0.2.</span> <span class="nav-text">常见的错解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remove-cv"><span class="nav-number">1.4.2.0.3.</span> <span class="nav-text">remove_cv</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型萃取"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">类型萃取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#…这和c-14有什么关系呢"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">…这和c++14有什么关系呢</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联容器的异构查找"><span class="nav-number">1.4.3.</span> <span class="nav-text">关联容器的异构查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新增自定义字面量特性（标准库）"><span class="nav-number">1.4.4.</span> <span class="nav-text">新增自定义字面量特性（标准库）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过类型寻址多元组"><span class="nav-number">1.4.5.</span> <span class="nav-text">通过类型寻址多元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#较小的标准库特性"><span class="nav-number">1.4.6.</span> <span class="nav-text">较小的标准库特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-14移除或抛弃的特性"><span class="nav-number">1.4.7.</span> <span class="nav-text">c++14移除或抛弃的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结语"><span class="nav-number">1.4.8.</span> <span class="nav-text">结语</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eco_oodt</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"oodtoodtgithub"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  














  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("9nyYGut00EwMsBkAM79MHdVT-gzGzoHsz", "S2d0pfqMODa7ipkySemFGTdl");AV.useAVCloudUS();</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
