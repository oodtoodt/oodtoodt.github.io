<!doctype html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="c++,company,c++17," />





  <link rel="alternate" href="/atom.xml" title="oodt's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon(1).ico?v=5.1.1" />






<meta name="description" content="c++17原定是一个超大的版本（不亚于c++11那种），但是最后令人兴奋的特性都没落实下来，留到c++20了，尽管如此，细节上面还是有很多可以说的。">
<meta name="keywords" content="c++,company,c++17">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp-17笔记_1">
<meta property="og:url" content="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17笔记/cpp-17笔记-1/index.html">
<meta property="og:site_name" content="oodt&#39;s blog">
<meta property="og:description" content="c++17原定是一个超大的版本（不亚于c++11那种），但是最后令人兴奋的特性都没落实下来，留到c++20了，尽管如此，细节上面还是有很多可以说的。">
<meta property="og:updated_time" content="2020-01-15T06:43:43.449Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cpp-17笔记_1">
<meta name="twitter:description" content="c++17原定是一个超大的版本（不亚于c++11那种），但是最后令人兴奋的特性都没落实下来，留到c++20了，尽管如此，细节上面还是有很多可以说的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17笔记/cpp-17笔记-1/"/>





  <title>cpp-17笔记_1 | oodt's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">oodt's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">自杀之路</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17笔记/cpp-17笔记-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="eco_oodt">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/prpr.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="oodt's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">cpp-17笔记_1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-14T18:49:18+08:00">
                2020-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/14/cpp-11-14-17笔记/cpp-17笔记-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/01/14/cpp-11-14-17笔记/cpp-17笔记-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2020/01/14/cpp-11-14-17笔记/cpp-17笔记-1/" class="leancloud_visitors" data-flag-title="cpp-17笔记_1">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>c++17原定是一个超大的版本（不亚于c++11那种），但是最后令人兴奋的特性都没落实下来，留到c++20了，尽管如此，细节上面还是有很多可以说的。<br><a id="more"></a></p>
<hr>
<h1 id="c-17"><a href="#c-17" class="headerlink" title="c++17"></a>c++17</h1><p>c++开始变得越来越先进，语法上很多地方有python、lua的味道了。<br>但是一旦模板加入了整个行列，那么事情就变得复杂了起来。<br>不管怎么说，c++17还是很好的</p>
<h2 id="删除-废弃的特性"><a href="#删除-废弃的特性" class="headerlink" title="删除/废弃的特性"></a>删除/废弃的特性</h2><h4 id="删除trigraph"><a href="#删除trigraph" class="headerlink" title="删除trigraph"></a>删除trigraph</h4><p>??!不再能表示|<br>wtf…？这什么东西<br>我相信很多人甚至都不知道C++还有这个东西，所以即使被禁止掉对大多数人都没有任何的感觉。<br>让我先列举一下这是什么：<br>??= #<br>??( [<br>??) ]<br>??&lt; {<br>??&gt; }<br>??/ \<br>??’ ^<br>??! |<br>??- ~</p>
<p>也就是说当你打 ??/ 的时候会被转为 \ ，而转为这个 \ 以后会发生什么事情呢？那就是转义了，而更为恐怖的是你即使是在字符串里面写 “?? / “也会被解析为 “\”。比如一些被Bug蹂躏到崩溃的程序员会不断的使用printf大法打问号的方式来发泄自己找bug的不满，然后一激动就把shift松了，直接把问号打成了/<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"what the f**k is it???????/"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后这一转义，事情就有趣了，编译器就直接绕过去了，<br>假装这里有图.jpg（其实就是大括号直接匹配不到了<br>Clang比较好，还有Warning，但是一些编译器就直接只有这样的错误，程序员会更加崩溃，不知道发生什么事情了。现在你在C++17就不用管这件事情了，默认禁止了。</p>
<blockquote>
<p>而这个提案一出来的时候，IBM首先站出来反对：<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4210.pdf" target="_blank" rel="external">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4210.pdf</a> ，因为IBM大型机使用的编码是EBCDIC，不是ANSIC。在EBCDIC的世界中，? = 都是相同的code point，但是 # 并不是所有的EBCDIC都是相同的code point，所以 ? = 更安全。当然 IBM 还列举了一个理由，就是有一些国际键盘没有 # 等特殊按键，不过Reddit有个人的评论说那就让他们把键盘扔了，买个有这些符号的键盘，我看了以后竟无言以对。无论如何，这个提案还是进入了C++17，至于IBM大型机会怎么做呢？比如 ??! -&gt; | ，我猜测可能会使用C++的 bitor 来换吧，Aha…交给他们大型机的开发者自己弄吧。</p>
</blockquote>
<h4 id="删除register"><a href="#删除register" class="headerlink" title="删除register"></a>删除register</h4><p>保留关键字，无意义。<br>c++11里提过一嘴这东西</p>
<h4 id="删除bool类型的-运算"><a href="#删除bool类型的-运算" class="headerlink" title="删除bool类型的++运算"></a>删除bool类型的++运算</h4><h4 id="删除throw-A-B-C-的动态异常规范"><a href="#删除throw-A-B-C-的动态异常规范" class="headerlink" title="删除throw(A,B,C)的动态异常规范"></a>删除throw(A,B,C)的动态异常规范</h4><p>throw()保留，为noexcept(true)的同义词<br>…我记得c++11删过了…</p>
<h4 id="弃用constexpr成员的重复声明"><a href="#弃用constexpr成员的重复声明" class="headerlink" title="弃用constexpr成员的重复声明"></a>弃用constexpr成员的重复声明</h4><p>对于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> X&#123;<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> n = <span class="number">10</span>;&#125;;</div><div class="line"><span class="keyword">int</span> X::n;<span class="comment">//不再是定义</span></div></pre></td></tr></table></figure></p>
<p>而是多余的重复声明被弃用，X::n是隐含的inline变量</p>
<h4 id="删除auto-ptr-random-shuffle-iostream中过时的部分"><a href="#删除auto-ptr-random-shuffle-iostream中过时的部分" class="headerlink" title="删除auto_ptr,random_shuffle,\,iostream中过时的部分"></a>删除auto_ptr,random_shuffle,\<functional\>,iostream中过时的部分</functional\></h4><p>c++11被弃用并被取代的功能将不再包含于c++17中，他们的名字保留</p>
<h4 id="删除std-function的内存分配器-allocator-支持"><a href="#删除std-function的内存分配器-allocator-支持" class="headerlink" title="删除std::function的内存分配器(allocator)支持"></a>删除std::function的内存分配器(allocator)支持</h4><p>多态函数包装器function不再具有接受内存分配器的构造函数。内存分配器支持对具有类型擦除(type-erase)功能的可复制类型来说很困难，可能无法有效实现。</p>
<h4 id="弃用一些C-library头文件"><a href="#弃用一些C-library头文件" class="headerlink" title="弃用一些C library头文件"></a>弃用一些C library头文件</h4><p>c library指的是c++标准库的一部分<br><code>&lt;ccomplex&gt;&lt;cstdalign&gt;&lt;cstdbool&gt;&lt;ctgmath&gt;</code><br>注意<code>&lt;ciso646&gt;</code>头文件没有被弃用。</p>
<h4 id="弃用标准库中陈旧的"><a href="#弃用标准库中陈旧的" class="headerlink" title="弃用标准库中陈旧的"></a>弃用标准库中陈旧的</h4><p>如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">allocator&lt;<span class="keyword">void</span>&gt;,raw_storage_iterator,get_temporary_buffer,is_literal_type,<span class="built_in">std</span>::raw_storage_iterator</div></pre></td></tr></table></figure></p>
<h4 id="弃用"><a href="#弃用" class="headerlink" title="弃用"></a>弃用<codecvt></codecvt></h4><p>wstring_convert和wbuffer_convert也被弃用。这些功能难以正确使用，甚至有怀疑它们的规范是否正确。用户应该使用专用的文本处理库。</p>
<h4 id="暂时弃用memory-order-consume"><a href="#暂时弃用memory-order-consume" class="headerlink" title="暂时弃用memory_order_consume"></a>暂时弃用memory_order_consume</h4><p>当前的“consume”内存序的语义被发现是不够的，需要重新定义。这项工作希望能在C++的下一版中完成。在进行这项工作的时间里，建议用户不要使用“consume”内存序，而是使用“acquire”内存序，以免将来遇到问题。</p>
<h4 id="弃用了shared-ptr-unique"><a href="#弃用了shared-ptr-unique" class="headerlink" title="弃用了shared_ptr::unique"></a>弃用了shared_ptr::unique</h4><p>该成员函数暗示了没有实际提供的行为。<br>？</p>
<h4 id="弃用了result-of"><a href="#弃用了result-of" class="headerlink" title="弃用了result_of"></a>弃用了result_of</h4><p>改用新的trait:invoke_result</p>
<h2 id="全局影响核心语言特性"><a href="#全局影响核心语言特性" class="headerlink" title="全局影响核心语言特性"></a>全局影响核心语言特性</h2><p>//弃用删除环节结束，来到全局影响核心语言特性</p>
<h3 id="不经意就会遇到的特性"><a href="#不经意就会遇到的特性" class="headerlink" title="不经意就会遇到的特性"></a>不经意就会遇到的特性</h3><h4 id="异常规范作为类型系统的一部分"><a href="#异常规范作为类型系统的一部分" class="headerlink" title="异常规范作为类型系统的一部分"></a>异常规范作为类型系统的一部分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>是具有不同类型的函数，函数指针可以按符合常理的方式转换，但是这两个函数不能构成重载<br>这个变化加强了类型系统，例如，api可以通过类型系统要求回调函数不抛出异常</p>
<h4 id="保证的复制消除"><a href="#保证的复制消除" class="headerlink" title="保证的复制消除"></a>保证的复制消除</h4><p>prvalue和glvalue的含义已被修改，prvalue不再代表对象，而仅仅代表”初始化”(“initialization”)。返回prvalue的函数不再会复制对象(强制复制消除(省略)”mandatory copy elision”),并且有了新的从prvalue到glvalue，叫temporary materialization conversion。这个变化意味着复制消除是保证了的，甚至可以用于不可移动或复制的类型<br>我尝试着去找这方面的资料…得到了却是不知道我的时间都跑到哪里看些乱七八糟的东西…英文懒得看了（还是得看），这就跟您讲一下大体上发生了什么（通过唯一的一篇中文说明）(复制粘贴,捏妈的这东西真是没例子看不懂)</p>
<p>我们在c++17中引入了一个规则，要求在满足一定的条件下避免对象的复制。至少</p>
<ol>
<li><p>返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用端转移至调用端的手段来避免拷贝操作。返回值优化包括具名返回值优化（NRVO）与无名返回值优化（URVO），两者的区别在于返回值是具名的局部变量还是无名的临时对象。</p>
</li>
<li><p>右值拷贝优化，当某一个类类型的临时对象被拷贝赋予同一类型的另一个对象时，通过直接利用该临时对象的方法来避免拷贝操作。<br> 临时对象指的是没有名字的对象。<br> 对于这样的对象不论是传递参数，还是已返回值返回时，都不会调用拷贝构造。</p>
</li>
</ol>
<p>c++17之前如果像这样将拷贝构造函数和移动构造函数都注释的话，是会出现编译错误的，但是c++17不会</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">class</span> MyClass</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	MyClass()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"MyClass constructor."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	MyClass(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</div><div class="line">	MyClass(MyClass&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function">MyClass <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> MyClass&#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	MyClass obj = foo();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>必须进行临时变量拷贝省略的好处：<br>对于一些没有拷贝构造的函数，如unique_ptr,atomic等，我们可以定义一个工厂函数，即使没有复制或者移动构造函数都可以返回一个对象。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function">T <span class="title">create</span><span class="params">(Args&amp;&amp; ... args)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> T&#123; <span class="built_in">std</span>::forward&lt;Args&gt;(args)... &#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i = create&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</div><div class="line">	<span class="keyword">auto</span> up = create&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="keyword">new</span> <span class="keyword">int</span>&#123; <span class="number">42</span> &#125;);</div><div class="line">	<span class="keyword">auto</span> ai = create&lt;<span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">42</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该特性一个好处是：对于临时对象(prvalue)，不论是通过值传递参数，还是通过值返回时，都不会调用拷贝构造函数，当复制对象的代价很高时，可以保证更好的性能。可以通过下面的代码来看：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">class</span> CopyOnly</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	CopyOnly()</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CopyOnly Constructor."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	CopyOnly(<span class="keyword">int</span> value)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CopyOnly Constructor(int). value = "</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	CopyOnly(<span class="keyword">const</span> CopyOnly&amp;) = <span class="keyword">delete</span>;</div><div class="line">	CopyOnly(CopyOnly&amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">// explicitly deleted</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function">CopyOnly <span class="title">return_by_value_fun</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> CopyOnly&#123;&#125;; <span class="comment">// OK since C++17</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_value_fun</span><span class="params">(CopyOnly co)</span></span></div><div class="line">&#123;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/* //具名临时变量的返回在C++17中也不支持Mandatory Copy Elision</span></div><div class="line">auto nrvo_return_fun()</div><div class="line">&#123;</div><div class="line">    CopyOnly co&#123;&#125;;  //NRVO具名传回值优化(Named Return Value Optimization) from co to the result object (not guaranteed, even in C++17)</div><div class="line">                    //if optimization is disabled, the move constructor is called if move constructor can used</div><div class="line">    return co;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    CopyOnly x = <span class="number">42</span>;<span class="comment">// OK since C++17</span></div><div class="line"> </div><div class="line">    <span class="keyword">auto</span> y = return_by_value_fun();</div><div class="line"> </div><div class="line">    pass_by_value_fun(CopyOnly(<span class="number">2</span>));</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果如下：(14就不能通过编译了)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CopyOnly Constructor(int). value = 42</div><div class="line">CopyOnly Constructor.</div><div class="line">CopyOnly Constructor(int). value = 2</div></pre></td></tr></table></figure></p>
<p>注意代码中的注释片段<br>在C++17之前，对变量x的初始化是非法的，因为首先数值42和变量x的类型不一致，所以出现一次user-defined的implicit conversion。x从类型int通过构造函数CopyOnly(int)得到了类型CopyOnly的一个prvalue(纯右值)。然后才是从一个prvalue构造一个类型CopyOnly的对象。</p>
<p>   我们知道大部分编译器通过复制省略技术把第二个过程会优化掉的，一般的编译器都会优化成原地构造的。但是C++17之前的标准在这个时候要求，即使这部分的内容会优化，但是依旧要进行编译时的检查，检查 copy/move 构造函数是否可用，如果不可用，那这个代码依旧是 ill-formed。</p>
<pre><code>到了C++17中就成了一个很大的改变，在一个变量是 临时变量(prvalue) 的时候，这里会用 direct-initalize，而不是尝试使用 copy/move initialize。也就是说，上面例子的代码在 C++17 起就可以通过编译的。这里就跟一开始那里一样了。
</code></pre><p>但是这里要注意，适用的规则是一个 prvalue 的对象，xrvalue 是不可以的。也就是说，下面这样的代码依旧是不能通过编译的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Foo</div><div class="line">&#123;</div><div class="line">	Foo(<span class="keyword">int</span> = <span class="number">10</span>) &#123;&#125;</div><div class="line"> </div><div class="line">	Foo(Foo&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">	Foo(<span class="keyword">const</span> Foo&amp;) = <span class="keyword">delete</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> Bar</div><div class="line">&#123;</div><div class="line">	<span class="keyword">operator</span> Foo &amp;&amp;()</div><div class="line">	&#123;</div><div class="line">	  <span class="keyword">return</span> <span class="built_in">std</span>::move(a);</div><div class="line">	&#125;</div><div class="line"> </div><div class="line">	Foo a;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	Bar b;</div><div class="line">	Foo a = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里虽然做了一次隐式类型转换（从 Bar 到 Foo），但是得到的类型是一个 xrvalue，而 xrvalue 是不适合上面的拷贝消除规则的，所以还会尝试使用 copy/move 构造，得到 ill-formed 的结果。</p>
<p>根据cppreference中文的说法，value ategory如下：<br>泛左值 (glvalue)（“泛化 (generalized)”的左值）是其求值确定一个对象、位域或函数的个体的表达式；<br>纯右值 (prvalue)（“纯 (pure)”的右值）是求值符合下列之一的表达式：<br>计算某个运算符的操作数的值（这种纯右值没有结果对象），或者<br>初始化某个对象或位域（称这种纯右值有一个结果对象）。所有类和数组的纯右值都有结果对象，即使它被舍弃也是如此。在某些语境中，将发生临时量实质化，以创建作为其结果对象的临时量；<br>亡值 (xvalue)（“将亡 (expiring)”的值）是代表其资源能够被重新使用的对象或位域的泛左值；<br>左值 (lvalue)（如此称呼的历史原因是，左值可以出现于赋值表达式的左边）是非亡值的泛左值；<br>右值 (rvalue)（如此称呼的历史原因是，右值可以出现于赋值表达式的右边）是纯右值或者亡值。、</p>
<p>但是如果你参照c++17的官网文档（<a href="http://www.cplusplus2017.info/c17-guaranted-copy-elision/)它是这样定义的：" target="_blank" rel="external">http://www.cplusplus2017.info/c17-guaranted-copy-elision/)它是这样定义的：</a><br>lvalue:一个函数或者是对象<br>xvalue:指一个对象，通常是接近生命周期结束的那种（即将被收回资源）。一个xvalue是涉及右值引用某些表达式的结果。<br>glvalue:lvalue or xvalue<br>rvalue:一个xvalue,一个临时对象或者其子对象，或者是与对象无关的值<br>prvalue:一个不是xvalue的rvalue。例如，调用一个返回类型不是引用的函数的结果就是prvalue。字面量也都是prvalue</p>
<p>C++17 中，某些场合强制要求进行复制消除（省略），而这要求将纯右值表达式从被它们所初始化的临时对象中分离出来，这就是我们现有的系统。要注意，与 C++11 的方案相比，纯右值已不再是可被移动。<br>我还tm看到这样一句话：obj(…..)是一个prvalue，prvalue不再是一个对象。</p>
<p>prvalue在必要的时候，可以生成一个临时对象，叫做materialize。</p>
<p>用prvalue初始化同类型的对象的时候，不会发生copy/move，而是直接构造目标对象。<br>所以，在C++17里（可以用-std=c++17启用），即使加上-fno-elide-constructors也不会调用copy/moveconstructor，因为这已经不是一个编译器优化，而是语言本身在这里不需要copy/move。同时，即使将所有copy/moveconstructor全变成private，这个程序也可以正确通过编译，因为这里不需要它们。<br>注：C++17中同样存在copyelision，但是已经不再包含上述情形。</p>
<hr>
<h4 id="过度对齐类型的动态内存分配"><a href="#过度对齐类型的动态内存分配" class="headerlink" title="过度对齐类型的动态内存分配"></a>过度对齐类型的动态内存分配</h4><p>over-aligned types—–即alignment超过std::max_align_t的类型的动态内存分配(operator new)现在可以支持了，这个运算符的一个新重载接受对齐要求参数，仍然是由实现决定支持哪些对齐<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="built_in">std</span>::<span class="keyword">align_val_t</span> alignment)</span></span>;</div><div class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="built_in">std</span>::<span class="keyword">align_val_t</span> alignment);</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="built_in">std</span>::<span class="keyword">align_val_t</span> alignment)</span></span>;</div><div class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="built_in">std</span>::<span class="keyword">align_val_t</span> alignment);</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<p>size —— 分配的字节数。必须为alignment的整数倍。</p>
<p>alignment —— 指定的对齐内存值。必须是实现支持的合法对齐。</p>
<p>new的返回值：</p>
<p>成功，返回指向新分配内存起始地址的指针。</p>
<p>用法例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include&lt;new&gt;</div><div class="line"> </div><div class="line">struct alignas(8) A &#123;&#125;;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    A *a = static_cast&lt;A *&gt;(::operator new(sizeof(A), static_cast&lt;std::align_val_t&gt;(alignof (A))));</div><div class="line">    ::operator delete(a, sizeof(A), static_cast&lt;std::align_val_t&gt;(alignof (A)));</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="更严格的表达式求值顺序"><a href="#更严格的表达式求值顺序" class="headerlink" title="更严格的表达式求值顺序"></a>更严格的表达式求值顺序</h4><p>对某些表达式的求值顺序规定更多了。一个重要方面是函数的各个实参现在以不确定(indeterminate)的顺序求值(也就是说没有交错interleaving)，而以前只是未指定的(unspecified)。注意重载运算符的求值顺序和调用方式有关：如果按照运算符的形式调用，就和内置运算符顺序相同，如果按函数的形式调用，就和一般的函数调用相同(即indeterminate)<br>C++17之定义表达式求值顺序</p>
<h5 id="大量例子预警！"><a href="#大量例子预警！" class="headerlink" title="大量例子预警！"></a>大量例子预警！</h5><p>如以下争议代码段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="comment">//对于std::map的[]运算符重载函数，在使用[]新增key时，std::map就已经插入了一个新的键值对</span></div><div class="line">    tmp[<span class="number">0</span>] = tmp.size();<span class="comment">//此处不知道插入的是&#123;0, 0&#125;还是&#123;0, 1&#125;</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了解决该情况，新计算顺序规则为：</p>
<ol>
<li><p>后缀表达式从左到右求值。这包括函数调用和成员选择表达式。</p>
</li>
<li><p>赋值表达式从右向左求值。这包括复合赋值。</p>
</li>
<li><p>从左到右计算移位操作符的操作数。</p>
</li>
</ol>
<p>在之前，许多代码库和c++书籍包含的代码直观的看起来貌似是有效的，但是严格地说，它们具有未定义的行为。一个例子是在一个字符串中查找和替换多个子字符串：</p>
<p>例1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"I heard it even works if you don't believe"</span>;</div><div class="line">	s.replace(<span class="number">0</span>, <span class="number">8</span>, <span class="string">""</span>).replace(s.find(<span class="string">"even"</span>), <span class="number">4</span>, <span class="string">"sometimes"</span>)</div><div class="line">		.replace(s.find(<span class="string">"you don't"</span>), <span class="number">9</span>, <span class="string">"I"</span>);</div><div class="line"> </div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通常的假设是，这段代码是有效的，用“”替换前8个字符，“sometimes”替换“even”，“I”替换“you don’t”,因此我们认为得到的结果是：</p>
<p>it sometimes works if I believe</p>
<p>然而，在C++17之前，这个输出结果是不保证的，因为find()调用返回从何处开始替换，可以在处理整个语句时的任何时候执行，并且在需要它们的结果之前完成执行。事实上，所有find()调用(计算替换的起始索引)都可能在任何替换发生之前进行处理，因此，最终字符串的结果可能有很多可能：</p>
<pre><code>在`https://ideone.com/`上运行结果为：it sometimes works if I believe
在win7 X64,visual studio 2019(c++14)上运行结果为：it even worsometimesf youIlieve
在ubuntu18.04 X64上运行结果为：it sometimes works if I believe
在`https://www.onlinegdb.com上运行结果为：it even worsometimesf youIlieve
在`https://wandbox.org上运行结果为：it sometimes works if I believe
</code></pre><p>另一个例子是，考虑使用output运算符打印由相互依赖的表达式计算的值:</p>
<p>例2：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">111</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">222</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">333</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; g() &lt;&lt; h();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通常的假设是f()在g()之前被调用，两者都在h()之前被调用。然而，这种假设是错误的。f()、g()和h()可以以任何顺序调用，当这些调用相互依赖时，可能会产生令人不解的结果。</p>
<pre><code>在https://ideone.com/上运行结果为：222111333
在win7 X64,visual studio 2019(c++14)上运行结果为：222111333
在ubuntu18.04 X64上运行结果为：222111333
在https://www.onlinegdb.com上运行结果为：222111333
在https://wandbox.org上运行结果为：222111333
</code></pre><p>唔，作为一个例子居然没问题真是抱歉了<br>换一个：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line">main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> str[<span class="number">80</span>]=<span class="string">"Abc+mNp-xyZ"</span>;</div><div class="line">    <span class="keyword">while</span>(str[n]!=<span class="string">'\0'</span>)</div><div class="line">        str[n++] = str[n]&gt;=<span class="string">'a'</span>&amp;&amp; str[n]&lt;=<span class="string">'z'</span>? str[n]-<span class="string">'a'</span>+<span class="string">'A'</span> : str[n];</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</div><div class="line">    <span class="comment">//大写字母65-90, 小写字母97-122</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//答案输出是BC+MNP-XYZ</span></div></pre></td></tr></table></figure></p>
<p><code>str[n++]</code>与 <code>str[n]&lt;=&#39;z&#39;? str[n]-&#39;a&#39;+&#39;A&#39;:str[n]</code>的求值顺序是不确定的，其中包含的对 n 的求值（取 n 的值）与副作用（写 n 的值）的顺序是不确定的，于是这是一个未定义行为。</p>
<hr>
<p>作为一个具体的例子，直到c++ 17以下代码都有未定义的行为:</p>
<p>例3：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++i &lt;&lt; <span class="string">' '</span> &lt;&lt; --i &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"> </div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>c++17之前测试结果如下：</p>
<p>在win7 X64,visual studio 2019(c++14)上运行结果为：0 0</p>
<p>在ubuntu18.04 X64上运行结果为：1 0</p>
<p>为了解决所有这些意想不到的行为，对一些操作符来说进行了改进，现在它们指定了一个有保证的结果顺序:</p>
<p>对于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">       e1 [ e2 ]</div><div class="line">       e1 . e2</div><div class="line">       e1 .* e2</div><div class="line">       e1 -&gt;* e2</div><div class="line">       e1 &lt;&lt; e2</div><div class="line">       e1 &gt;&gt; e2</div></pre></td></tr></table></figure></p>
<p>e1保证在e2之前被求值，所以求值顺序是从左到右。</p>
<p>但是，请注意，相同函数调用的不同参数的计算顺序仍然是未定义的。也就是说，对于如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1.f(a1,a2,a3)</div></pre></td></tr></table></figure></p>
<p>e1肯定会在a1 a2 a3之前求值。然而，a1、a2、a3的求值顺序仍未确定。</p>
<p>在所有赋值运算符中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     e2 = e1</div><div class="line">     e2 += e1</div><div class="line">     e2 *= e1</div></pre></td></tr></table></figure></p>
<p>右边e1保证在左边e2之前求值。</p>
<p>例如，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="comment">//对于std::map的[]运算符重载函数，在使用[]新增key时，std::map就已经插入了一个新的键值对</span></div><div class="line">    tmp[<span class="number">0</span>] = tmp.size();<span class="comment">//C++17保证此处插入的是&#123;0, 0&#125;</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，在new表达中，比如<br><code>new Type(e)</code><br>现在保证内存分配是在计算e之前执行，并且保证新值的初始化是在使用分配的内存和使用初始化的值之前进行，也就是说保证在使用分配的内存之前用新值的已经初始化了。</p>
<p>因此，从c++ 17起<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"I heard it even works if you don't believe"</span>;</div><div class="line">s.replace(<span class="number">0</span>,<span class="number">8</span>,<span class="string">""</span>).replace(s.find(<span class="string">"even"</span>),<span class="number">4</span>,<span class="string">"always"</span>)</div><div class="line">.replace(s.find(<span class="string">"don't believe"</span>),<span class="number">13</span>,<span class="string">"use C++17"</span>);</div></pre></td></tr></table></figure></p>
<p>对你没看错，就是这样的<br>保证将s的值更改为:</p>
<p>it always works if you use C++17</p>
<p>因此，在计算find（）表达式之前，find（）表达式前面的每个替换都已经完成。<br>另一个结果是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">0</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++i &lt;&lt; <span class="string">' '</span> &lt;&lt; --i &lt;&lt; <span class="string">'\n'</span>;</div></pre></td></tr></table></figure></p>
<p>对于支持这些操作数的任何类型的i，现在保证输出为1 0。</p>
<p>然而，大多数其他操作符的未定义顺序仍然存在。例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = i++ + i; // still undefined behavior</div></pre></td></tr></table></figure></p>
<p>在这里，右边的i可能是i在增加之前或之后的值。</p>
<p>新表达式求值顺序的另一个应用是在传递参数之前插入空格的函数[后续在处理空参数包的时候会用到]。</p>
<h5 id="补充：关于c-11里出现的sequenced-before"><a href="#补充：关于c-11里出现的sequenced-before" class="headerlink" title="补充：关于c++11里出现的sequenced-before"></a>补充：关于c++11里出现的sequenced-before</h5><p>C++ 是一个注重效率的语言，标准不指定一些表达式的求值顺序就是为了让编译器能做尽可能多的优化，即便要牺牲掉例如 i=i++ 这样表达式的正确性。</p>
<p>在 C++98/03 的标准中定义了 sequence point 来描述求值顺序，到了 C++11 中，用了更加清晰的 sequenced-before 来描述它。下面要说的是 C++11 中的 sequenced-before。</p>
<p>sequenced-before规则是一种“整理”序列点优先级的规则，它用一致的方式定义了与其它内存模型的关系，比如happens-before和synchronizes-with，所以它可以精确的指定哪些操作和更改的结果是可以确定的。<br><strong>这种修改是为了保证多线程优化的正确性而来的。</strong><br>让我们从例子开始：</p>
<ul>
<li><p><code>i=++i;</code><br>如果i是一个内置的类型，那么一切用的都是内置运算符的操作（也就是没有运算符重载）。那么会有四件事发生：<br>（A）++i进行求值，也就是i+1的值会被计算出来<br>（B）++i side-effect的产生，也就是存储i+1的值到i<br>（C）赋值的值的计算，就算等号右边，也就是返回++i求出来的值<br>（D）赋值的side-effect产生，也就是把新值存到i里<br>以上就是对基于sequenced-before的编译器处理过程的充分表达。<br>因为++i对于i（等号左边）来说等于i+=1，存储值的side-effect产生先序于(sequenced-before) ++i的求值，所以（B）先序于（A）。<br>赋值操作的两个操作数的求值先序于赋值本身，它又先序于存储值side-effect的产生。因此，A先序于C，C先序于D。<br>所以我们就有B-&gt;A-&gt;C-&gt;D，这个在新标准中是可以的，但是在C++98中不行。<br>如果i是一个类，那么表达式将会i.operator=(i.operator++()), 或者 i.operator=(operator++(i)), 所有因operator++调用产生的作用会先序于调用operator=</p>
</li>
<li><p><code>a[++i] = i</code>;<br>如果a是一个数组类型，i是一个int，那么这个表达式分为几部分：<br>（A）i的求值<br>（B）++i的求值<br>（C）++i side-effect的产生，也就是存储i+1的值到i<br>（D）<code>a[++i]</code>的求值，它返回a数组中下标为++i的元素的左值<br>（E）被赋值数的计算，在这种情况下是i的值<br>（F）存储新的值到数组元素<code>a[++i]</code><br>同样的，所有这些都是sequenced-before的充分表达（即它们都是有分号的完整的语句）<br>同样的，由于++i等于i+=1，存储值的side-effect产生先序于++i的求值，所以（C）先序于（B）。<br>数组下标++i的求值先序于element selection的求值，所以B先序于D。<br>赋值操作的两个操作数的求值先序于赋值本身，它又先序于存储值side-effect的产生。因此A和D先序于E，E先序于F<br>所以我们可以得出两个序列(a) -&gt; (d) -&gt; (e) -&gt; (f)和(c) -&gt; (b) -&gt; (d) -&gt; (e) -&gt; (f)。<br>不幸的是，（A）和（C）之前是没有排序的。因此，i的side-effect产生（把值存储到i）和i的求值是未测序的，所以这段代码具有未定义行为。这是由C++11标准文档中1.9的15页给定。<br>如上所述，如果i是类，那么一切都是还正确，因为操作符成为函数调用，这强加了排序。</p>
</li>
</ul>
<p>下面总结一下规则：</p>
<ol>
<li>和一个完整的表达式（full-expression）相关的 side-effect 以及求值都先于和下一个完整表达式相关的 side-effect 以及求值被求值（当一个表达式不是另一个表达式的子表达式，称这个表达式为完整的表达式）。</li>
<li>除了下面提到的以外，对一个运算符的运算数的求值、对一个表达式的子表达式的求值都是 unsequenced。</li>
<li>一个运算符的运算数的求值先序于这个运算符结果的求值。</li>
<li>如果一个标量对象（比如 int 这样类型的对象）的 side-effect 和另一个作用于相同对象的 side-effect 或者求值是 unsequenced，那么这个行为是 undefined。</li>
<li>当调用一个函数的时候，不管函数是不是 inline ，也不管是否使用的是显式语法调用（比如说 i + j 和 i.operator + (j)，这里 i 和 j 是某个重载了 operator + 的类型），这个函数的任一参数的表达式的 side-effect 和 求值，以及指定被调用函数的那个表达式（比如 (<em>func_ptr)() 中，</em>func_ptr 就是这个表达式）都先序于被调用函数体的所有表达式以及语句。但是不同参数的表达式的求值和 side-effect 都不存在序上的关系。</li>
<li>后自增运算符以及后自减运算符的求值先序于它们的 side-effect。</li>
<li>前自增运算符以及前自减运算符的 side-effect 先序于它们的求值。这条和上一条规则就说明了为什么++i是先求值再返回而i++是先返回再求值。</li>
<li>内建（built-in）逻辑与运算符&amp;&amp;以及内建（built-in）逻辑或运算符||的第一个运算数（左边的那个）的求值以及 side-effect 先序于它们的第二个运算数（右边的那个）的 求值以及 side-effect 。</li>
<li>条件运算符?:第一个表达式的 求值以及 side-effect 先序于它第二或第三个表达式的 求值以及 side-effect。</li>
<li>内建赋值运算符=以及所有内建复合赋值运算符的运算数（左右两个）的 求值（但不是 side-effect）先序于它的 side-effect（即对左边运算数的修改），并且这个 side-effect 先序于整个赋值表达式的 求值（也就是说返回之前对象就修改完成了）。</li>
<li>内建逗号运算符,左边运算数的求值以及 side-effect 都先序于它右边那个运算数的 求值以及 side-effect。</li>
<li>初始化列表的每一个元素的求值以及 side-effect 都先序于由逗号分隔、跟在它后面的元素的  求值以及 side-effect。</li>
</ol>
<h3 id="局部影响的核心语言特性"><a href="#局部影响的核心语言特性" class="headerlink" title="局部影响的核心语言特性"></a>局部影响的核心语言特性</h3><p>知道了才能用到的特性</p>
<h4 id="u8字符字面量"><a href="#u8字符字面量" class="headerlink" title="u8字符字面量"></a>u8字符字面量</h4><p>具有u8前缀的字符字面量产生一个在UTF-8中占有一个编码单元（code unit）的合法Unicode代码点（code point）对应的字符，换句话说，就是产生一个ASCII值。例如：u8’x’</p>
<h4 id="16进制浮点数字面量"><a href="#16进制浮点数字面量" class="headerlink" title="16进制浮点数字面量"></a>16进制浮点数字面量</h4><p>具有十六进制底数和十进制指数的浮点数字面量：0xC.68p+2、0x1.P-126。C语言自从C99开始就支持这种语法， printf的%a可以输出这种形式的浮点数。<br>就是以0x开头的十六进制+以f后缀的单精度浮点数，合并。<br>float value = 0x1111f;<br>更复杂的例子：<br>0x1.P-126,0xC.68p+2<br>p是2幂数，lua起手想一下(。</p>
<h4 id="fold表达式"><a href="#fold表达式" class="headerlink" title="fold表达式"></a>fold表达式</h4><p>用于迭代地将二元运算符应用于参数包(parameter pack)的元素的便利语法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(Args ...args)</span></span>&#123;<span class="keyword">return</span> (<span class="number">0</span> + ... + args);&#125;</div></pre></td></tr></table></figure></p>
<p>用于变长参数模板的解包，只支持各种运算符（和操作符），分左、右折叠<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">一元右折叠(unary right fold)</div><div class="line">( pack op ... )</div><div class="line">一元右折叠(E op ...)展开之后变为 E1 op (... op (EN-1 op EN))</div><div class="line"></div><div class="line">一元左折叠(unary left fold)</div><div class="line">( ... op pack )</div><div class="line">一元左折叠(... op E)展开之后变为 ((E1 op E2) op ...) op EN</div><div class="line"></div><div class="line">二元右折叠(binary right fold)</div><div class="line">( pack op ... op init )</div><div class="line">二元右折叠(E op ... op I)展开之后变为 E1 op (... op (EN−1 op (EN op I)))</div><div class="line"></div><div class="line">二元左折叠(binary left fold)</div><div class="line">( init op ... op pack )</div><div class="line">二元左折叠(I op ... op E)展开之后变为 (((I op E1) op E2) op ...) op EN</div></pre></td></tr></table></figure></p>
<p>语法形式中的op代表运算符，pack代表参数包，init代表初始值。<br>初始值在右边的为右折叠，展开之后从右边开始折叠。而初始值在左边的为左折叠，展开之后从左边开始折叠。<br>不指定初始值的为一元折叠表达式，而指定初始值的为二元折叠表达式。<br>当一元折叠表达式中的参数包为空时，只有三个运算符（&amp;&amp; || 以及逗号）有缺省值，其中&amp;&amp;的缺省值为true,||的缺省值为false，逗号的缺省值为void()。</p>
<h5 id="大量例子预警！-1"><a href="#大量例子预警！-1" class="headerlink" title="大量例子预警！"></a>大量例子预警！</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... arg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (arg + ...);<span class="comment">//右折叠</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum_strong</span><span class="params">(T ... arg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (arg + ... + <span class="number">0</span>);<span class="comment">//右折叠</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">sub1</span><span class="params">(T ... arg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (arg - ...);<span class="comment">//右折叠</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">sub2</span><span class="params">(T ... arg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (... - arg);<span class="comment">//左折叠</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> s1 = sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//解包：((((1+)2+)3+)4+)5 = 15</span></div><div class="line">    <span class="keyword">double</span> s2 = sum(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>);</div><div class="line">    <span class="keyword">double</span> s3 = sum(<span class="number">1</span>, <span class="number">2.2</span>, <span class="number">3</span>, <span class="number">4.4</span>, <span class="number">5</span>);</div><div class="line"> </div><div class="line">    <span class="keyword">double</span> s4 = sub1(<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//解包：((((5-)2-)1-)1) = 1</span></div><div class="line">    <span class="keyword">double</span> s5 = sub2(<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//解包：(5-(2-(1-(1)))) = 3</span></div><div class="line"> </div><div class="line">    <span class="keyword">double</span> s6 = sum_strong();<span class="comment">//s6 = 0</span></div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="string">"he"</span>)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="string">"ll"</span>)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="string">"o "</span>)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="string">"world"</span>)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str5 = sum(str1, str2, str3, str4);<span class="comment">//str5 = "hello world"</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>求和<br>假设我们想写一个能接受一个及以上参数的求和函数，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First&gt;  </div><div class="line"><span class="function">First <span class="title">sum1</span><span class="params">(First&amp;&amp; value)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">return</span> value;  </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span> Second, <span class="keyword">typename</span>... Rest&gt;  </div><div class="line"><span class="function">First <span class="title">sum1</span><span class="params">(First&amp;&amp; first, Second&amp;&amp; second, Rest&amp;&amp;... rest)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">return</span> sum(first + second, forward&lt;Rest&gt;(rest)...);  </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</div><div class="line"><span class="function">First <span class="title">sum2</span><span class="params">(First&amp;&amp; first, Rest&amp;&amp;... rest)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (first + ... + rest);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; sum1(<span class="number">1</span>) &lt;&lt; sum1(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; sum1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 136</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; sum2(<span class="number">1</span>) &lt;&lt; sum2(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; sum2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 136</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在C++17之前，求和函数sum1的实现必须分成两个部分。<br>其中4到8行的sum1函数用于处理一个参数的情况。而10到14行的sum1函数用于处理两个及以上参数的情况。<br>当参数个数大于一个时，10到14行的sum1函数将前两个参数相加，然后递归调用自身。<br>当参数个数只有一个时，4到8行的sum1函数将此参数返回，完成求和。<br><code>sum1(1, 2, 3) = sum1(1+2, 3) = sum1(3, 3) = sum1(3+3) = sum1(6) = 6</code><br>而在C++17之后，由于有了折叠表达式这个新特性，求和函数sum2不再需要处理特殊情况，实现大为简化。<br><code>sum2(1, 2, 3) = (1 + ... + pack(2, 3)) = (1+2) + 3 = 6</code><br>这里sum2的实现所采用的是二元左折叠。<br>“与”和“或”<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all</span><span class="params">(Args... args)</span> </span>&#123;<span class="keyword">return</span> (... &amp;&amp; args);&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">any</span><span class="params">(Args... args)</span> </span>&#123;<span class="keyword">return</span> (... || args);&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; all(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// false</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; any(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// true</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; all() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// true</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; any() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里all和any函数分别实现了不特定多数布尔值的与和或的运算。这两个函数的实现均采用了一元左折叠。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">all(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) = (... &amp;&amp; pack(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)) = (<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>) &amp;&amp; <span class="literal">true</span> = <span class="literal">false</span></div><div class="line">any(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) = (... || pack(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)) = (<span class="literal">true</span> || <span class="literal">false</span>) || <span class="literal">true</span> = <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>当一元折叠表达式中的参数包为空时，&amp;&amp;的缺省值为true，而||的缺省值为false。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">all() = (... &amp;&amp; pack()) = <span class="literal">true</span></div><div class="line">any() = (... || pack()) = <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>“打印”和“调用”<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAll</span><span class="params">(Ts&amp;&amp;... mXs)</span></span></div><div class="line">&#123;</div><div class="line">    (<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; mXs) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TF, <span class="keyword">typename</span>... Ts&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">forArgs</span><span class="params">(TF&amp;&amp; mFn, Ts&amp;&amp;... mXs)</span></span></div><div class="line">&#123;</div><div class="line">    (mFn(mXs), ...);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    printAll(<span class="number">3</span>, <span class="number">4.0</span>, <span class="string">"5"</span>); <span class="comment">// 345</span></div><div class="line">    printAll(); <span class="comment">// 空行</span></div><div class="line">    forArgs([](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; a;&#125;, <span class="number">3</span>, <span class="number">4.0</span>, <span class="string">"5"</span>); <span class="comment">// 345</span></div><div class="line">    forArgs([](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; a;&#125;); <span class="comment">// 空操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>printAll函数实现了对不特定多数值的打印输出。该函数的实现采用了二元左折叠。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">printAll(<span class="number">3</span>, <span class="number">4.0</span>, <span class="string">"5"</span>)</div><div class="line">= (<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; pack(<span class="number">3</span>, <span class="number">4.0</span>, <span class="string">"5"</span>)) &lt;&lt; <span class="built_in">endl</span></div><div class="line">= ((<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span>) &lt;&lt; <span class="number">4.0</span>) &lt;&lt; <span class="string">"5"</span> &lt;&lt; <span class="built_in">endl</span></div><div class="line">= 打印<span class="number">345</span>并换行</div></pre></td></tr></table></figure></p>
<p>当二元折叠表达式的参数包为空时，其计算结果为该二元折叠表达式中所预设的初始值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">printAll()</div><div class="line">= (<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; pack()) &lt;&lt; <span class="built_in">endl</span></div><div class="line">= <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span></div><div class="line">= 空行</div></pre></td></tr></table></figure></p>
<p>forArgs函数实现了依次使用多个参数调用某个单参数函数的功能。该函数的实现采用了一元右折叠。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">forArgs([](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; a;&#125;, <span class="number">3</span>, <span class="number">4.0</span>, <span class="string">"5"</span>)</div><div class="line">= ([](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; a;&#125;(pack(<span class="number">3</span>, <span class="number">4.0</span>, <span class="string">"5"</span>)), ...)</div><div class="line">= [](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; a;&#125;(<span class="number">3</span>), ([](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; a;&#125;(<span class="number">4.0</span>), ([](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; a;&#125;(<span class="string">"5"</span>)))</div><div class="line">= 打印<span class="number">345</span></div></pre></td></tr></table></figure></p>
<p>当使用逗号的一元折叠表达式中的参数包为空时，其计算结果为标准规定的缺省值void()。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">forArgs([](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; a;&#125;)</div><div class="line">= ([](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; a;&#125;(pack()), ...)</div><div class="line">= <span class="keyword">void</span>()</div></pre></td></tr></table></figure></p>
<h4 id="template"><a href="#template" class="headerlink" title="template"></a>template<auto></auto></h4><p>非类型形参可以用auto声明<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> X&gt;</div><div class="line"><span class="keyword">struct</span> constant&#123;<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = X;&#125;;</div><div class="line">Delegate&lt;&amp;MyClass::some_function&gt;</div></pre></td></tr></table></figure></p>
<p>然而并不能统一类型/非类型参数</p>
<h4 id="类模板参数推导"><a href="#类模板参数推导" class="headerlink" title="类模板参数推导"></a>类模板参数推导</h4><p>类模板的模板参数可以从构造函数推导<br>在C++17之前，类模板构造器的模板参数是不能像函数模板的模板参数那样被自动推导的，比如我们无法写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::pair a&#123;<span class="number">1</span>, <span class="string">"a"</span>s&#125;; <span class="comment">// C++17</span></div></pre></td></tr></table></figure></p>
<p>而只能写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; a&#123;<span class="number">1</span>, <span class="string">"a"</span>s&#125;; <span class="comment">// C++14</span></div></pre></td></tr></table></figure></p>
<p>为了弥补这一缺陷，标准库为我们提供了 std::make_pair 函数，通过函数模板的模板参数自动推导的功能，<br>免去我们在构造 pair 时写模板参数的麻烦。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> a = <span class="built_in">std</span>::make_pair(<span class="number">1</span>, <span class="string">"a"</span>s); <span class="comment">// C++14</span></div><div class="line"><span class="comment">// 相当于</span></div><div class="line"><span class="comment">// std::pair&lt;int, string&gt; a = std::make_pair&lt;int, string&gt;(1, string("a"));</span></div><div class="line"><span class="comment">// 这里编译器根据 std::make_pair 所带参数的类型，自动推导出了函数模板的参数。</span></div></pre></td></tr></table></figure></p>
<p>这个解决方案其实并不太理想，这是因为：<br>我们需要记住 make_pair, make_tuple 这类用于构造模板类的惯用法。<br>有些 make_XXX 函数在功能上并不等价于类模板的构造器，比如 make_shared 等等。<br>在C++17中，这个问题得到了解决，类模板构造器的模板参数同样能够被自动推导<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::pair a&#123;<span class="number">1</span>, <span class="string">"a"</span>s&#125;; <span class="comment">// C++17</span></div><div class="line"><span class="comment">// 相当于</span></div><div class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; a&#123;<span class="number">1</span>, <span class="string">"a"</span>s&#125;;</div><div class="line"><span class="comment">// 和函数模板一样，这里编译器根据 std::pair 构造器所带参数类型，自动推导出了构造器模板的参数。</span></div></pre></td></tr></table></figure></p>
<p>由此我们不再需要 std::make_pair 之类的辅助函数了。</p>
<h4 id="constexpr-if"><a href="#constexpr-if" class="headerlink" title="constexpr if"></a>constexpr if</h4><p>新的 if constexpr(condition)语句根据常量表达式的值选择执行哪个分支<br>普通的 if-else 是在执行期进行条件判断与选择, 这意味着在泛型编程中无法使用if-else 语句进行条件判断. 比如例 1 会引起编译错误</p>
<p>例 1: 将多个数累加并返回累加结果<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Ns&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>...(Ns) == <span class="number">0</span>) <span class="comment">// 若参数包为空, 直接返回 N</span></div><div class="line">        <span class="keyword">return</span> N;</div><div class="line">    <span class="keyword">else</span>                    <span class="comment">// 否则进行递归调用</span></div><div class="line">        <span class="keyword">return</span> N + sum&lt;Ns...&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">sum&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;();</div></pre></td></tr></table></figure></p>
<p>编译不能通过</p>
<p>C++17之前，将多个数累加并返回累加结果<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只有一个模板参数时调用此模板</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> N;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 模板参数 &gt; 2 个时调用此模板</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> N2, <span class="keyword">int</span>... Ns&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> N + sum&lt;N2, Ns...&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">sum&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;(); <span class="comment">// returns 6</span></div></pre></td></tr></table></figure></p>
<p> C++17, 将多个数累加并返回累加结果<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">template &lt;int N, int... Ns&gt;</div><div class="line">auto sum()</div><div class="line">&#123;</div><div class="line">    if constexpr (0 == sizeof...(Ns))</div><div class="line">        return N;</div><div class="line">    else</div><div class="line">        return N + sum&lt;Ns...&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用</div><div class="line">sum&lt;1, 2, 3&gt;(); // returns 6</div></pre></td></tr></table></figure></p>
<p>更简单的是利用 C++17 提供的新功能 “折叠表达式”, 如例 3.</p>
<p>例 3: 利用折叠表达式实现多个数累加并返回累加结果<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ns&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ns... ns)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (ns + ...);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// returns 6</span></div></pre></td></tr></table></figure></p>
<p>constexpr if 可以应用更多的场合, 比如要将数值转化为字符串. 在 C++17之前, 需要使用 std::enable_if 来判断参数类型, 如例 4.<br>例 4<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数值转换</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_integral&lt;T&gt;::value, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;</div><div class="line">to_string(T t)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::to_string(t);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;!<span class="built_in">std</span>::is_integral&lt;T&gt;::value, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;</div><div class="line">to_string(T t)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>而在 C++17 中可以利用 constexpr if 完成相同功能, 且摒弃了冗长的std::enable_if 语句, 不仅代码可读性好, 而且书写也更方便, 如例 5.<br>例 5<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">auto to_string(T t)</div><div class="line">&#123;</div><div class="line">    if constexpr(std::is_integral&lt;T&gt;::value)</div><div class="line">        return std::to_string(t);</div><div class="line">    else</div><div class="line">        return t;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>便是要注意在 constexpr if 中的 return 语句, 下面的写法是不对的,应当在条件语句的分支中 return,<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">auto to_string(T t)</div><div class="line">&#123;</div><div class="line">    if constexpr(std::is_integral&lt;T&gt;::value)</div><div class="line">        return std::to_string(t);</div><div class="line">    // 此处需要 else</div><div class="line">    return t;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如许多 C++ 著作中提到的, 如果一个函数中使用了大量的 if-else 语句,那么需要重构, 将多个条件语句转化成函数重载会更加清晰. 同理,如果泛型函数中使用大量的 constexpr if 语句, 也许也需要考虑代码重构.</p>
<p>constexpr if的主要功能是简化模板代码（这也意味着除非你是库作者或者模板狂魔，很少会用到）。很多需要绕弯借助SFINAE或者类型tag来实现，需要拆成N个函数的功能，可以借助constexpr if写到一个函数里。</p>
<h2 id="本期结语"><a href="#本期结语" class="headerlink" title="本期结语"></a>本期结语</h2><p>因为例子实在很多（也很好），所以想了想还是分期了。<br>也许扩充的多了能到三期的样子。<br>因为又在补完的过程里找到了许多非常有趣的资料。<br>比如令人发指的trigraph (。<br>下期继续，这期</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>本期多数来自于网上资料blog与知乎大大资料<br><a href="https://blog.csdn.net/zwvista/category_641225.html" target="_blank" rel="external">https://blog.csdn.net/zwvista/category_641225.html</a><br><a href="https://blog.csdn.net/qq811299838/article/details/90371604" target="_blank" rel="external">https://blog.csdn.net/qq811299838/article/details/90371604</a><br><a href="https://blog.csdn.net/janeqi1987/category_9294691.html" target="_blank" rel="external">https://blog.csdn.net/janeqi1987/category_9294691.html</a><br><a href="https://zhuanlan.zhihu.com/p/27551890" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/27551890</a><br><a href="https://www.zhihu.com/people/lan-se-52-30/posts" target="_blank" rel="external">https://www.zhihu.com/people/lan-se-52-30/posts</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/c/" rel="tag"># c++</a>
          
            <a href="/tags/company/" rel="tag"># company</a>
          
            <a href="/tags/c-17/" rel="tag"># c++17</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/14/cpp-11-14-17笔记/cpp-14笔记/" rel="next" title="cpp-14笔记">
                <i class="fa fa-chevron-left"></i> cpp-14笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/15/cpp-11-14-17笔记/cpp-17笔记-2/" rel="prev" title="cpp-17笔记-2">
                cpp-17笔记-2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2020/01/14/cpp-11-14-17笔记/cpp-17笔记-1/"
           data-title="cpp-17笔记_1" data-url="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17笔记/cpp-17笔记-1/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/prpr.jpg"
               alt="eco_oodt" />
          <p class="site-author-name" itemprop="name">eco_oodt</p>
           
              <p class="site-description motion-element" itemprop="description">---自虐一点 开心一点</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">49</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c-17"><span class="nav-number">1.</span> <span class="nav-text">c++17</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#删除-废弃的特性"><span class="nav-number">1.1.</span> <span class="nav-text">删除/废弃的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#删除trigraph"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">删除trigraph</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除register"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">删除register</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除bool类型的-运算"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">删除bool类型的++运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除throw-A-B-C-的动态异常规范"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">删除throw(A,B,C)的动态异常规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弃用constexpr成员的重复声明"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">弃用constexpr成员的重复声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除auto-ptr-random-shuffle-iostream中过时的部分"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">删除auto_ptr,random_shuffle,\,iostream中过时的部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除std-function的内存分配器-allocator-支持"><span class="nav-number">1.1.0.7.</span> <span class="nav-text">删除std::function的内存分配器(allocator)支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弃用一些C-library头文件"><span class="nav-number">1.1.0.8.</span> <span class="nav-text">弃用一些C library头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弃用标准库中陈旧的"><span class="nav-number">1.1.0.9.</span> <span class="nav-text">弃用标准库中陈旧的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弃用"><span class="nav-number">1.1.0.10.</span> <span class="nav-text">弃用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#暂时弃用memory-order-consume"><span class="nav-number">1.1.0.11.</span> <span class="nav-text">暂时弃用memory_order_consume</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弃用了shared-ptr-unique"><span class="nav-number">1.1.0.12.</span> <span class="nav-text">弃用了shared_ptr::unique</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弃用了result-of"><span class="nav-number">1.1.0.13.</span> <span class="nav-text">弃用了result_of</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局影响核心语言特性"><span class="nav-number">1.2.</span> <span class="nav-text">全局影响核心语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不经意就会遇到的特性"><span class="nav-number">1.2.1.</span> <span class="nav-text">不经意就会遇到的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异常规范作为类型系统的一部分"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">异常规范作为类型系统的一部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#保证的复制消除"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">保证的复制消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过度对齐类型的动态内存分配"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">过度对齐类型的动态内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更严格的表达式求值顺序"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">更严格的表达式求值顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#大量例子预警！"><span class="nav-number">1.2.1.4.1.</span> <span class="nav-text">大量例子预警！</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#补充：关于c-11里出现的sequenced-before"><span class="nav-number">1.2.1.4.2.</span> <span class="nav-text">补充：关于c++11里出现的sequenced-before</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部影响的核心语言特性"><span class="nav-number">1.2.2.</span> <span class="nav-text">局部影响的核心语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#u8字符字面量"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">u8字符字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16进制浮点数字面量"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">16进制浮点数字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fold表达式"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">fold表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#大量例子预警！-1"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">大量例子预警！</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#template"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">template</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类模板参数推导"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">类模板参数推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr-if"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">constexpr if</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本期结语"><span class="nav-number">1.3.</span> <span class="nav-text">本期结语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">1.3.1.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eco_oodt</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"oodtoodtgithub"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  














  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("9nyYGut00EwMsBkAM79MHdVT-gzGzoHsz", "S2d0pfqMODa7ipkySemFGTdl");AV.useAVCloudUS();</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
