<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oodt&#39;s blog</title>
  
  <subtitle>自杀之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://oodtoodt.github.io/"/>
  <updated>2020-01-14T09:27:00.166Z</updated>
  <id>http://oodtoodt.github.io/</id>
  
  <author>
    <name>eco_oodt</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cpp-14笔记</title>
    <link href="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17%E7%AC%94%E8%AE%B0/cpp-14%E7%AC%94%E8%AE%B0/"/>
    <id>http://oodtoodt.github.io/2020/01/14/cpp-11-14-17%E7%AC%94%E8%AE%B0/cpp-14%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-14T08:05:58.000Z</published>
    <updated>2020-01-14T09:27:00.166Z</updated>
    
    <content type="html"><![CDATA[<p>先打预防针：14的内容不多。<br><a id="more"></a></p><hr><h1 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h1><p>应该说核心内容不多，如果你想去读官方1000页文档然后说不多那我无话可说。<br>这里就只捡取最流行的一份中文文档来说了<br>如果你打开cppreference，查看c++语言核心特性，会发现c++14只有一个变量模板</p><p>另外贴一个知乎大大的总结：</p><blockquote><p>最后总结一下就是，C++14可以称为更加完美的C++11，这是我的观点。我觉得这些提案本就应该在C++11出现，但是却由于各种因素才拖到C++14中了。 C++的确变得更加复杂了，但是对于今天学习C++的人来说是更幸福的，少了很多奇淫技巧，多了更多照顾开发者的东西。<br>——蓝色</p></blockquote><h2 id="一篇流传很广的文档：语言特性"><a href="#一篇流传很广的文档：语言特性" class="headerlink" title="一篇流传很广的文档：语言特性"></a>一篇流传很广的文档：语言特性</h2><h3 id="泛型lambda，可以在形参中使用auto"><a href="#泛型lambda，可以在形参中使用auto" class="headerlink" title="泛型lambda，可以在形参中使用auto"></a>泛型lambda，可以在形参中使用auto</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> adder = [](<span class="keyword">auto</span> op1,<span class="keyword">auto</span> op2) &#123;<span class="keyword">return</span> op1 + op2;&#125;;</div></pre></td></tr></table></figure><h3 id="lambda捕捉初始化"><a href="#lambda捕捉初始化" class="headerlink" title="lambda捕捉初始化"></a>lambda捕捉初始化</h3><p>c++14允许被捕捉的成员用任意的表达式初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</div><div class="line"><span class="keyword">auto</span> lambda = [&amp;ptr]&#123;<span class="keyword">return</span> *ptr&#125;;</div><div class="line"><span class="comment">//也是可以的了 auto lambda = [ptr = std::move(ptr)]&#123;return *ptr;&#125;;</span></div></pre></td></tr></table></figure></p><h3 id="auto推导"><a href="#auto推导" class="headerlink" title="auto推导"></a>auto推导</h3><p>c++14的auto可以推导没有返回类型的函数了（之前必须显式声明，不过注意现在我们禁止带有歧义性的返回类型auto）<br>当decltype(auto)被用于声明变量时，该变量必须立即初始化。假设该变量的初始化表达式为e，那么该变量的类型将被推导为decltype(e)。也就是说在推导变量类型时，先用初始化表达式替换decltype(auto)当中的auto，然后再根据decltype的语法规则来确定变量的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) g1() &#123;<span class="keyword">return</span> s.a;&#125;</div><div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) i1 = a;</div><div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) i2 = <span class="built_in">std</span>::move(a);</div></pre></td></tr></table></figure></p><h3 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h3><p>使得没有return expression的函数也可以使用返回类型推导<br>如果你对之前的某篇文章很有印象的话，会记得有<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">auto f(int a, int b) -&gt; decltype( a + b )</div><div class="line">&#123;</div><div class="line">   int i = a + b;</div><div class="line">   return i;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; f(1,2) &lt;&lt; std::endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对，返回类型后置，当然不是用在这里的，这里举个例子。<br>c++14之后，你就可以直接<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> i = a + b;</div><div class="line">   <span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意，因为不允许歧义了，所以<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (i == <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> i;          <span class="comment">// return type deduced to int</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> sum(i<span class="number">-1</span>)+i + <span class="number">0.0</span>; <span class="comment">// 这样怎么办呢？</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>是不允许的</p><h3 id="放松了constepr"><a href="#放松了constepr" class="headerlink" title="放松了constepr"></a>放松了constepr</h3><p>放松了constexpr的概念，c++11中，constexpr函数只含有一个将返回的表达式（和包含static_assert声明在内的几个语句），c++14中则放松了这些限制<br>constexpr的函数将可以包含：</p><ul><li>任何声明，除了static和thread_local变量、没有初始化的变量声明。</li><li>放松了constexpr的概念，c++11中，constexpr函数只含有一个将返回的表达式（和包含static_assert声明在内的几个语句），c++14中则放松了这些限制<br>constexpr的函数将可以包含：</li><li>任何声明，除了static和thread_local变量、没有初始化的变量声明。</li><li>条件分支if和switch，goto不行</li><li>所有的循环</li><li>表达式可以改变对象值，只需该对象生命期在常量表达式函数内开始<br>调用非constexpr函数仍然是受限的，所以如果使用基于范围的for，begin和end的重载必须自身被声明为constexpr，顺便一提，std::initializer_list在本地和全局都有这东西</li></ul><p>所有被声明为constexpr的非静态成员函数也隐含声明为const（即函数不能修改*this的值）这一在c++11中定义的点在c++14中已经被删除。</p><p>多说几句，这个特性…</p><blockquote><p>这篇提案可谓是深得标准委员会人员的心，不可否认，这篇提案对于普通开发人员无疑是福音，因为可以再次提高性能。但是对于编译器开发人员简直是噩梦的一篇提案。说实话，在C++11的所有特性中，constexpr绝对是一个很难实现的特性，我不能透露ibm编译器如何实现的，感兴趣的可以去参看GCC或者Clang的实现。直到现在，Visual C++的实现constexpr都是Partial的状态。众所周至，constexpr有一些限定，比如只能返回一条语句等，即使这样，编译器做起来都是很头痛的一件事情。这篇提案简直逆天了，要去掉这些条件，还可以加入if，for什么的了，，具体的可以参看提案内容。我只能说简直丧心病狂，完全不管编译器开发者的死活。当时我们激烈讨论了到底怎么实现的，但是也没有讨论出来什么。但就是这篇提案，标准委员会举双手双脚赞成，而且还说有实现的先例：D语言。我也不知道该说什么了。<br>作者：蓝色<br>链接：<a href="https://www.zhihu.com/question/22765983/answer/22591090" target="_blank" rel="external">https://www.zhihu.com/question/22765983/answer/22591090</a></p></blockquote><h3 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h3><p>c++11引入了类型别名模板，c++14现在也可以创建变量模板<br>指using解决typedef在模板参数的问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">constexpr</span> T pi = T(<span class="number">3.1415926535897932385</span>);  <span class="comment">// 变量模板</span></div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function">T <span class="title">circular_area</span><span class="params">(T r)</span> <span class="comment">// 函数模板</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> pi&lt;T&gt; * r * r; <span class="comment">// pi&lt;T&gt; 是变量模板实例化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在类作用域中使用时，变量模板声明一个静态数据成员模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals;</div><div class="line"><span class="keyword">struct</span> matrix_constants</div><div class="line">&#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">    <span class="keyword">using</span> pauli = hermitian_matrix&lt;T, <span class="number">2</span>&gt;; <span class="comment">// 别名模版</span></div><div class="line"> </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="comment">// 静态数据成员模板</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> pauli&lt;T&gt; sigmaX = &#123; &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125; &#125;; </div><div class="line"> </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> pauli&lt;T&gt; sigmaY = &#123; &#123; <span class="number">0</span>, <span class="number">-1</span>i &#125;, &#123; <span class="number">1</span>i, <span class="number">0</span> &#125; &#125;;</div><div class="line"> </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> pauli&lt;T&gt; sigmaZ = &#123; &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125; &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>除非变量模板被显式特化或显式实例化，否则它在特化时隐式实例化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> limits &#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> T min; <span class="comment">// 静态数据成员模板的声明</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">const</span> T limits::min = &#123; &#125;; <span class="comment">// 静态数据成员模板的定义</span></div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">   <span class="keyword">static</span> T s; <span class="comment">// 类模板的非模板静态数据成员的声明</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">T X&lt;T&gt;::s = <span class="number">0</span>; <span class="comment">// 类模板的非模板静态数据成员的定义</span></div></pre></td></tr></table></figure></p><p>模板元编程离我们还有点距离，我们可以先放一放。</p><hr><h3 id="聚合体成员初始化。"><a href="#聚合体成员初始化。" class="headerlink" title="聚合体成员初始化。"></a>聚合体成员初始化。</h3><p>c++11新增member initializer(即成员初始化列表)，之前不允许聚合体初始化，现在c++14可以了<br>聚合体：<br>aggregate:详见pod那个章节，这里我们稍微提一下。数组类型、结构体、联合体、类中，没有私有、保护的非静态数据成员、无用户提供的构造函数、无基类无虚函数的都是。<br>如果聚合体中间有嵌套，可以不用花括号分割。（int arr[3],j;={1,2,3,4}，j会分配4）</p><h3 id="二进制字面值与数字分位符号"><a href="#二进制字面值与数字分位符号" class="headerlink" title="二进制字面值与数字分位符号"></a>二进制字面值与数字分位符号</h3><p>使用前缀0b或0B，引入’作为数字分位符号，使其具有更好的可读性。</p><h3 id="属性：deprecated"><a href="#属性：deprecated" class="headerlink" title="属性：deprecated"></a>属性：deprecated</h3><p>指示声明有此属性的名字或实体被弃用，即允许但因故不鼓励使用。<br>语法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[deprecated]](<span class="number">1</span>)</div><div class="line">[[deprecated( 字符字面量 )]](<span class="number">2</span>)</div></pre></td></tr></table></figure></p><p>字符字面量    -    能用于解释弃用的理由并/或提议代替用实体的文本</p><h2 id="——————————————"><a href="#——————————————" class="headerlink" title="——————————————"></a>——————————————</h2><h2 id="新标准库的特性"><a href="#新标准库的特性" class="headerlink" title="==新标准库的特性=="></a>==新标准库的特性==</h2><h2 id="———–"><a href="#———–" class="headerlink" title="———–"></a>———–</h2><h3 id="增加了共享的互斥体和锁"><a href="#增加了共享的互斥体和锁" class="headerlink" title="增加了共享的互斥体和锁"></a>增加了共享的互斥体和锁</h3><p>std::shared_timed_mutex</p><h3 id="元函数别名"><a href="#元函数别名" class="headerlink" title="元函数别名"></a>元函数别名</h3><p>c++11定义了一组元函数用于查询类型是否具有某种特征，或者转换给定类型的某种特征<br>指的就是type_traits里的各种东西，以及别名模板。<br>我们先来一点前置知识学习</p><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>首先是c++11中的volatile<br>volatile:在柯林斯高级学习词典中这样解释：<br>A situation that is volatile is likely to change suddenly and unexpectedly.<br>注意，likely，suddenly，unexpectedly<br>总结来说，被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。<br>我们讨论c/c++的执行顺序时会提到——序列点。执行表达式有两种类型的动作：(1)计算某个值(2)副作用(例如访问volatile对象、原子同步、修改文件等)因此，如果两个表达式e1和e2中间有一个序列点，或者在c++中e1于序列中在e2之前，则e1的求值动作和副作用都会在e2的求值和副作用之前。<br>因此在c/c++中，对volatile对象的访问，有编译器优化上的副作用：</p><ul><li>不允许优化消失</li><li>于序列上在另一个对volatile对象访问之前<br>（这里其实很像原子操作的某些规则，但是volatile访问的序列性是在单线程执行的前提）<h5 id="常见的错解"><a href="#常见的错解" class="headerlink" title="常见的错解"></a>常见的错解</h5>错解：用volatile修饰while的退出flag。应该用atomic<br>volatile 本质是让编译器在每次遇到被它修饰的变量时，不能根据代码上下文假设它的状态。注意是「让『编译器』」。所以编译器不会对它做某些类型的优化，也不会交换两个 volatile 访问的顺序。但是这不保证 CPU 执行时不会交换顺序。<br>但是还是要结合一下cpu的情况，根据具体环境给一个可用不可用的范围约束。</li></ul><p>好，现在我们学会了volatile，于是我们来看remove_cv</p><h5 id="remove-cv"><a href="#remove-cv" class="headerlink" title="remove_cv"></a>remove_cv</h5><p>很简单！去掉const和volatile前缀，其实就是remove_const和remove_volatile的结合<br>然后呢，我们看到了type_traits头文件！<br>想到什么了吗！<br>之前没讲的，类型萃取！它leile！</p><h4 id="类型萃取"><a href="#类型萃取" class="headerlink" title="类型萃取"></a>类型萃取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::decay对类型进行退化处理，退化掉引用和cv符。</div><div class="line">如果is_array&lt;U&gt;::value为真，则修改类型为remove_reference&lt;U&gt;::type*</div><div class="line">否则，如果is_function &lt; U &gt; ::value为真，修改类型为add_pointer&lt; U &gt;::type</div><div class="line">否则，修改类型为remove_cv&lt; U &gt;::type</div><div class="line">可以方便的获得函数指针</div><div class="line"><span class="built_in">std</span>::result_of元函数可以获取调用对象的返回类型</div><div class="line">enable_if是利用SFINAE根据条件重载函数</div></pre></td></tr></table></figure><h4 id="…这和c-14有什么关系呢"><a href="#…这和c-14有什么关系呢" class="headerlink" title="…这和c++14有什么关系呢"></a>…这和c++14有什么关系呢</h4><p>但是在c++11中，它们用在模板中时，必须用typename关键字<br>c++14中提供了更便捷的写法————利用类型别名模板。规则：如果标准库的某个类模板只含有有唯一的成员，即成员类型type，那么提供std::some_class_t<t>作为typename std::some_class::type的别名<br>稍微罗列几个就懂了：</t></p><blockquote><p>remove_const,remove_volatile,remove_cv,add_const,add_reference,add_lvalue_reference(r),make_signed,make_unsigned,remove_extent,remove_all_extents,remove_pointer,aligned_storage,decay,enable_if,conditional,common_type,underlying_type,result_of,tuple_element<br>对不起发现了几个很有趣的类型就都写上了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">type_object&lt;<span class="built_in">std</span>::<span class="keyword">remove_cv_t</span>&lt;<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&gt;&gt;get_type_object(T&amp;);</div></pre></td></tr></table></figure></p></blockquote><p>唔，似乎没说明到底是啥ww，具体就是给一个预定义的using来用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> remove_reference;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">using</span> <span class="keyword">remove_reference_t</span> = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type;</div></pre></td></tr></table></figure></p><hr><h3 id="关联容器的异构查找"><a href="#关联容器的异构查找" class="headerlink" title="关联容器的异构查找"></a>关联容器的异构查找</h3><p>即定义了operator&lt;的都可以作为set等查找类型<br>strict weak orderings，就<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( x &lt; y ) &#123; <span class="keyword">return</span> <span class="literal">true</span>;&#125; <span class="keyword">if</span> ( y &lt; x ) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</div></pre></td></tr></table></figure></p><p>具体请查标准库文档<br>比如const char* 与string<br>标准库的泛型比较器都支持这一点<br>如果不知道你根本不会相信以前是不支持这个东西的（指复杂度会远超logn</p><h3 id="新增自定义字面量特性（标准库）"><a href="#新增自定义字面量特性（标准库）" class="headerlink" title="新增自定义字面量特性（标准库）"></a>新增自定义字面量特性（标准库）</h3><p>“s”，用于创建各种std::basic_string类型<br>“h”,”min”,”s”,”ms”,”us”,”ns”用于创建相应的std::chrono::duration时间间隔</p><h3 id="通过类型寻址多元组"><a href="#通过类型寻址多元组" class="headerlink" title="通过类型寻址多元组"></a>通过类型寻址多元组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="built_in">string</span>,<span class="built_in">string</span>,<span class="keyword">int</span>&gt;t(<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">int</span> i = get&lt;<span class="keyword">int</span>&gt;(t);<span class="comment">//i == 7</span></div><div class="line"><span class="keyword">int</span> j = get&lt;<span class="number">2</span>&gt;(t)<span class="comment">//same as before j == 7;</span></div><div class="line"><span class="built_in">string</span> s = get&lt;<span class="built_in">string</span>&gt;(t);<span class="comment">//ce due to ambiguity</span></div></pre></td></tr></table></figure><h3 id="较小的标准库特性"><a href="#较小的标准库特性" class="headerlink" title="较小的标准库特性"></a>较小的标准库特性</h3><p>std::make_unique可以像std::make_shared一样使用产生std::unique_ptr对象（？为什么不在c++11里加这个）<br>std::is_final，用于识别一个class类型是否禁止被继承<br>std::integral_constant增加了一个返回常量值的operator()<br>全局std::begin/std::end函数之外，增加了std::cbegin/std::cend函数，它们总是返回常量迭代器</p><h3 id="c-14移除或抛弃的特性"><a href="#c-14移除或抛弃的特性" class="headerlink" title="c++14移除或抛弃的特性"></a>c++14移除或抛弃的特性</h3><p>被c++14移除的标准特性（这里指一些可能本来会在c++14出现的东西</p><ul><li>关于数组的扩展<br>在c++11和之前的标准中，在堆栈上分配的数组被限制为拥有一个固定的、编译器确定的长度。这一扩展允许堆栈上分配的一个数组最后一维拥有运行期确定的长度。<br>添加了std::dynarray类型，它拥有与std::vector和std::array类似的接口，代表一个固定长度的数组。被明显地设计为当它被放置在栈上时，可以使用栈内存而不是堆内存<br>在斟酌之后，它被从c++14中移除了。</li><li>optional值<br>类似于c#的可空类型，也没采用</li><li>concepts lite<br>回炉重造了</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>c++14结束啦。<br>补这篇文档的时候找到了不少有趣的资料，感觉很不错。<br>下篇就是c++17了，17的资料真的不多，争取明天弄完吧——</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先打预防针：14的内容不多。&lt;br&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://oodtoodt.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="http://oodtoodt.github.io/tags/c/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="c++14" scheme="http://oodtoodt.github.io/tags/c-14/"/>
    
  </entry>
  
  <entry>
    <title>cpp-11笔记_3</title>
    <link href="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17%E7%AC%94%E8%AE%B0/cpp-11%E7%AC%94%E8%AE%B0-3/"/>
    <id>http://oodtoodt.github.io/2020/01/14/cpp-11-14-17%E7%AC%94%E8%AE%B0/cpp-11%E7%AC%94%E8%AE%B0-3/</id>
    <published>2020-01-14T07:36:11.000Z</published>
    <updated>2020-01-14T09:16:46.991Z</updated>
    
    <content type="html"><![CDATA[<p>《深入了解c++11》阅读笔记<br><a id="more"></a></p><hr><h2 id="《深入了解c-11》"><a href="#《深入了解c-11》" class="headerlink" title="《深入了解c++11》"></a>《深入了解c++11》</h2><h3 id="几个细节"><a href="#几个细节" class="headerlink" title="几个细节"></a>几个细节</h3><ul><li>noexcept是会在抛出异常的时候直接终止的。不愧是阻止异常传播。</li><li>c++11中，允许使用等号或花括号进行就地的非静态成员变量初始化，初始化列表效果后作用于非静态成员</li><li>通用的sizeof（非静态成员变量）</li><li><p>模板中使用友元进行对private等东西的测试。注意可以用using</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> DefenderT &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">friend</span> T;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Defence</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tackle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> pos_x = <span class="number">15</span>;</div><div class="line">    <span class="keyword">int</span> pos_y = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> speed = <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> stamina = <span class="number">120</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> AttackerT &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">friend</span> T;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SpeedUp</span><span class="params">(<span class="keyword">float</span> ratio)</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> pos_x = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> pos_y = <span class="number">-30</span>;</div><div class="line">    <span class="keyword">int</span> speed = <span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> stamina = <span class="number">100</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Defender = DefenderT&lt;<span class="keyword">int</span>&gt;;    <span class="comment">// 普通的类定义，使用int做参数</span></div><div class="line"><span class="keyword">using</span> Attacker = AttackerT&lt;<span class="keyword">int</span>&gt;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNIT_TEST</span></div><div class="line"><span class="keyword">class</span> Validator &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Validate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, DefenderTest &amp; d)</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Validate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, AttackerTest &amp; a)</span></span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> DefenderTest = DefenderT&lt;Validator&gt;;  <span class="comment">// 测试专用的定义，Validator类成为友元</span></div><div class="line"><span class="keyword">using</span> AttackerTest = AttackerT&lt;Validator&gt;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    DefenderTest d;</div><div class="line">    AttackerTest a;</div><div class="line">    a.Move(<span class="number">15</span>, <span class="number">30</span>);</div><div class="line">    d.Defence(<span class="number">15</span>, <span class="number">30</span>);</div><div class="line">    a.SpeedUp(<span class="number">1.5f</span>);</div><div class="line">    d.Defence(<span class="number">15</span>, <span class="number">30</span>);</div><div class="line">    Validator v;</div><div class="line">    v.Validate(<span class="number">7</span>, <span class="number">0</span>, d);</div><div class="line">    v.Validate(<span class="number">1</span>, <span class="number">-10</span>, a);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></li><li><p>可以使用模板函数来构造模板，有默认参数。如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">TempFun</span><span class="params">(T a)</span></span>&#123;&#125;</div><div class="line"><span class="comment">//....</span></div><div class="line">TempFun(<span class="number">1</span>);<span class="comment">//1,实例化为TempFun&lt;const int&gt;(1))</span></div></pre></td></tr></table></figure></li><li><p>外部模板，注意复习</p></li><li><p>局部和匿名类型作为模板实参</p></li><li><p>注意基类构造函数被声明为私有成员函数，或者是派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。一旦使用继承构造函数，那么就无默认构造函数了。原来那边也有，注意复习（比如我就忘了然后又写了一遍）</p></li></ul><h3 id="委派构造函数"><a href="#委派构造函数" class="headerlink" title="委派构造函数"></a>委派构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Info &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Info() : Info(<span class="number">1</span>, <span class="string">'a'</span>) &#123; &#125;</div><div class="line">    Info(<span class="keyword">int</span> i) : Info(i, <span class="string">'a'</span>) &#123; &#125;</div><div class="line">    Info(<span class="keyword">char</span> e): Info(<span class="number">1</span>, e) &#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Info(<span class="keyword">int</span> i, <span class="keyword">char</span> e): type(i), name(e) &#123; <span class="comment">/* 其它初始化 */</span> &#125;</div><div class="line">    <span class="keyword">int</span>  type;</div><div class="line">    <span class="keyword">char</span> name;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>构造函数不能同时“委派”和使用初始化列表，所以注意上例中的写法<br>同时注意目标构造函数优先于委派构造函数执行，避免初始化同样的成员。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Info &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Info() : Info(<span class="number">1</span>) &#123; &#125;    <span class="comment">// 委托构造函数</span></div><div class="line">    Info(<span class="keyword">int</span> i) : Info(i, <span class="string">'a'</span>) &#123; &#125; <span class="comment">// 既是目标构造函数，也是委托构造函数</span></div><div class="line">    Info(<span class="keyword">char</span> e): Info(<span class="number">1</span>, e) &#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Info(<span class="keyword">int</span> i, <span class="keyword">char</span> e): type(i), name(e) &#123; <span class="comment">/* 其它初始化 */</span> &#125; <span class="comment">// 目标构造函数</span></div><div class="line">    <span class="keyword">int</span>  type;</div><div class="line">    <span class="keyword">char</span> name;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>同样注意不要成环。</p><p>一个很实际的应用是使用构造模板函数产生目标构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> TDConstructed &#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; TDConstructed(T first, T last) : </div><div class="line">        l(first, last) &#123;&#125;</div><div class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    TDConstructed(<span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; &amp; v): </div><div class="line">        TDConstructed(v.begin(), v.end()) &#123;&#125;</div><div class="line">    TDConstructed(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp; d): </div><div class="line">        TDConstructed(d.begin(), d.end()) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>可以在委派构造函数中捕捉到目标构造函数的异常。</p><h3 id="右值引用。"><a href="#右值引用。" class="headerlink" title="右值引用。"></a>右值引用。</h3><p>移动构造一定会改变临时变量的值，所以注意排除不必要的const<br>移动构造函数的异常抛出非常危险，可以使用std::move_if_noexcept的模板函数代替std::move，在有noexcept时返回右值引用从而使用移动语义，没有时返回左值引用从而使用拷贝语义（牺牲性能保证安全）</p><p>完美转发的一个作用就是包装函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t, U&amp; Func)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">"\tforwarded..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    Func(forward&lt;T&gt;(t));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">double</span> &amp;&amp; m)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunHome</span><span class="params">(<span class="keyword">double</span> &amp;&amp; h)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunComp</span><span class="params">(<span class="keyword">double</span> &amp;&amp; c)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    PerfectForward(<span class="number">1.5</span>, RunComp);   <span class="comment">// 1.5     forwarded...</span></div><div class="line">    PerfectForward(<span class="number">8</span>, RunCode);     <span class="comment">// 8       forwarded...</span></div><div class="line">    PerfectForward(<span class="number">1.5</span>, RunHome);   <span class="comment">// 1.5     forwarded...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><p>声明个以initialize_list<t>模板类为参数的构造函数，就可以使得自定义的类使用列表初始化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> Gender &#123;boy, girl&#125;;</div><div class="line"><span class="keyword">class</span> People &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    People(<span class="built_in">initializer_list</span>&lt;pair&lt;<span class="built_in">string</span>, Gender&gt;&gt; l) &#123;  <span class="comment">// initializer_list的构造函数</span></div><div class="line">        <span class="keyword">auto</span> i = l.begin();</div><div class="line">        <span class="keyword">for</span> (;i != l.end(); ++i)</div><div class="line">            data.push_back(*i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, Gender&gt;&gt; data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">People ship2012 = &#123;&#123;<span class="string">"Garfield"</span>, boy&#125;, &#123;<span class="string">"HelloKitty"</span>, girl&#125;&#125;;</div></pre></td></tr></table></figure></t></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Mydata &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Mydata &amp; <span class="keyword">operator</span> [] (<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; l)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = l.begin(); i != l.end(); ++i)</div><div class="line">            idx.push_back(*i);</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    Mydata &amp; <span class="keyword">operator</span> = (<span class="keyword">int</span> v) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (idx.empty() != <span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = idx.begin(); i != idx.end(); ++i) &#123;</div><div class="line">                d.resize((*i &gt; d.size()) ? *i : d.size());</div><div class="line">                d[*i - <span class="number">1</span>] = v;</div><div class="line">            &#125;</div><div class="line">            idx.clear();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.begin(); i != d.end(); ++i) </div><div class="line">            <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idx;    <span class="comment">// 辅助数组，用于记录index</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Mydata d;</div><div class="line">    d[&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;] = <span class="number">7</span>;</div><div class="line">    d[&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>&#125;] = <span class="number">4</span>;</div><div class="line">    d.Print();  <span class="comment">// 4 7 7 4 4 0 0 4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="匿名非受限联合体"><a href="#匿名非受限联合体" class="headerlink" title="匿名非受限联合体"></a>匿名非受限联合体</h3><p>不知道是啥。</p><h3 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h3><p>如果自定义类型可以像内置类型一样向函数传递字面常量….<br>operator “”_C(…)<br>建议用下滑线开始，否则会被编译器出警。<br>如果字面量为整形数，那么字面量操作符函数只可接受ull或者const char<em>为其参数。(就是…里允许放的参数)当然返回值不受限制。<br>如果浮点型数，则只接受long double 或者const char</em><br>字符串：const char*,size_t为参数，sizet大概是自动获取的；字符就一个char</p><h3 id="内联命名空间"><a href="#内联命名空间" class="headerlink" title="内联命名空间"></a>内联命名空间</h3><p>可以通过把新的命名空间内联进去达成导入的效果。<br>ADL充满迷惑，尽量不要使用。<br>注意内联会破坏命名空间本身具有的封装性，所以谨慎使用。</p><h3 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h3><p>上次讲着讲着跑到萃取然后又不知道跑到哪了，这边再写一遍吧。<br>using定义别名丝毫不比typedef逊色。<br>在模板编程中更加灵活：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> MapString = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;T, <span class="keyword">char</span>*&gt;;</div><div class="line">MapString&lt;<span class="keyword">int</span>&gt; numberedString;</div></pre></td></tr></table></figure></p><p>因为template<typename t="">是没法直接typedef的，必须套一层的struct才行。</typename></p><h3 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h3><p>—Substitution failure is not an error<br>为了保证模板设计的灵活性，这样的推导规则比想象的更常见且普遍。<br>在c++11中又增加了扩展。</p><h3 id="auto——不能推导的情况："><a href="#auto——不能推导的情况：" class="headerlink" title="auto——不能推导的情况："></a>auto——不能推导的情况：</h3><p>1.auto不能是形参，泛型参数请用模板<br>2.非静态成员变量的类型不能是auto的<br>3.声明auto数组。<br>4.实例化模板时用auto作为参数(vector<auto>v = {1})</auto></p><h3 id="decltype——不弱于auto的东西。"><a href="#decltype——不弱于auto的东西。" class="headerlink" title="decltype——不弱于auto的东西。"></a>decltype——不弱于auto的东西。</h3><p>编译时进行的。<br>经常与typedef/using合用————using size_t = decltype(sizeof(0));<br>可以重用匿名类型（指strcut{}p这种）</p><h3 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h3><p>constexpr算作模板元编程的范畴。<br>同样，使用常量静态成员、变长参数，同样可以完成模板元编程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">long</span>... nums&gt; <span class="keyword">struct</span> Multiply;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">long</span> first, <span class="keyword">long</span>... last&gt;</div><div class="line"><span class="keyword">struct</span> Multiply&lt;first, last...&gt; &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = first * Multiply&lt;last...&gt;::val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> Multiply&lt;&gt; &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; Multiply&lt;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::val &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">// 120</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; Multiply&lt;<span class="number">22</span>, <span class="number">44</span>, <span class="number">66</span>, <span class="number">88</span>, <span class="number">9</span>&gt;::val &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 50599296</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="关于变长参数，你不知道的…"><a href="#关于变长参数，你不知道的…" class="headerlink" title="关于变长参数，你不知道的…"></a>关于变长参数，你不知道的…</h3><p>展开参数包的位置：<br>表达式<br>初始化列表<br>基类描述列表<br>类成员初始化列表<br>模板参数列表<br>通用属性列表<br>lambda函数的捕捉列表</p><p>一个trick<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt;<span class="keyword">class</span> T:<span class="keyword">private</span> B&lt;A&gt;...&#123;&#125;<span class="comment">//T&lt;X,Y&gt;--&gt;</span></div><div class="line"><span class="keyword">class</span> T&lt;X,Y&gt;:<span class="keyword">private</span> B&lt;X&gt;,<span class="keyword">private</span> B&lt;Y&gt;&#123;&#125;;<span class="comment">//多重继承的派生类</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt;<span class="keyword">class</span> T:<span class="keyword">private</span> B&lt;A...&gt;&#123;&#125;<span class="comment">//T&lt;X,Y&gt;--&gt;</span></div><div class="line"><span class="keyword">class</span> T&lt;X,Y&gt;:<span class="keyword">private</span> B&lt;X,Y&gt;&#123;&#125;;<span class="comment">//多参数的模板类的派生类</span></div></pre></td></tr></table></figure></p><p>sizeof…可以计算参数包中的参数个数<br>极具迷惑性的使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span>... B&gt; <span class="keyword">struct</span> Container&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> A, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span>... B&gt; </div><div class="line"><span class="keyword">struct</span> Container&lt;I, A, B...&gt; &#123;</div><div class="line">    A&lt;I&gt; a;</div><div class="line">    Container&lt;I, B...&gt; b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt; <span class="keyword">struct</span> Container&lt;I&gt;&#123;&#125;;</div></pre></td></tr></table></figure></p><p>更加恐怖的使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt; <span class="keyword">struct</span> S &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 两个模板参数包</span></div><div class="line"><span class="keyword">template</span>&lt;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... &gt; <span class="keyword">class</span> T, <span class="keyword">typename</span>... TArgs</div><div class="line">  , <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... &gt; <span class="keyword">class</span> U, <span class="keyword">typename</span>... UArgs</div><div class="line">  &gt;</div><div class="line">  <span class="keyword">struct</span> S&lt; T&lt; TArgs... &gt;, U&lt; UArgs... &gt; &gt; &#123;&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    S&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt;  p;</div><div class="line">    S&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;, <span class="built_in">std</span>::tuple&lt;<span class="keyword">float</span>&gt;&gt;  s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一个什么时候心情好有空可以看一下的例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> A &#123;</div><div class="line">    A()&#123;&#125;</div><div class="line">    A(<span class="keyword">const</span> A&amp; a) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Constructed "</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">    A(A&amp;&amp; a) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Constructed "</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> B &#123;</div><div class="line">    B()&#123;&#125;</div><div class="line">    B(<span class="keyword">const</span> B&amp; b) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Constructed "</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">    B(B&amp;&amp; b) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Constructed "</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 变长模板的定义</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="keyword">struct</span> MultiTypes;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... T&gt; </div><div class="line"><span class="keyword">struct</span> MultiTypes&lt;T1, T...&gt; : <span class="keyword">public</span> MultiTypes&lt;T...&gt;&#123;</div><div class="line">    T1 t1;</div><div class="line">    MultiTypes&lt;T1, T...&gt;(T1 a, T... b):</div><div class="line">        t1(a), MultiTypes&lt;T...&gt;(b...) &#123; </div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"MultiTypes&lt;T1, T...&gt;(T1 a, T... b)"</span> &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> MultiTypes&lt;&gt; &#123;</div><div class="line">    MultiTypes&lt;&gt;()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"MultiTypes&lt;&gt;()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 完美转发的变长模板</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class</span> VariadicType, <span class="keyword">typename</span>... Args&gt;</div><div class="line">VariadicType&lt;Args...&gt; Build(Args&amp;&amp;... args)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> VariadicType&lt;Args...&gt;(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    A a;</div><div class="line">    B b;</div><div class="line">    </div><div class="line">    Build&lt;MultiTypes&gt;(a, b);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>可以保证互斥。<br>注意，atomic模板类的拷贝构造函数、移动构造函数、operator=等总是默认被删除的.但可以从atomic<t>来构造。<br>对大多数原子类型，可以读、写、交换、比较并交换。注意查表即可。对于整形和指针标准中还有算术和逻辑运算的操作符。atomic_flag是无锁的。<br>下面是一个自旋锁的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="built_in">std</span>::atomic_flag lock = ATOMIC_FLAG_INIT;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (lock.test_and_set(<span class="built_in">std</span>::memory_order_acquire))    <span class="comment">// 尝试获得锁</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Waiting from thread "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 自旋</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; n &lt;&lt; <span class="string">" starts working"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; n &lt;&lt; <span class="string">" is going to start."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    lock.clear(); </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; n &lt;&lt; <span class="string">" starts working"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    lock.test_and_set();</div><div class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(f, <span class="number">1</span>)</span></span>;</div><div class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(g, <span class="number">2</span>)</span></span>; </div><div class="line"></div><div class="line">    t1.join();</div><div class="line">    usleep(<span class="number">100</span>);</div><div class="line">    t2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p><p>我试着跑也跑不出来…mingw真蒻。windows真蒻。明天换个版本的mingw，哎。<br>然后就跑出来了嗯</p><h4 id="强顺序-弱顺序"><a href="#强顺序-弱顺序" class="headerlink" title="强顺序-弱顺序"></a>强顺序-弱顺序</h4><p>强顺序：对于多线程，其看到的指令执行顺序是一致的。</p><h4 id="memory-order"><a href="#memory-order" class="headerlink" title="memory_order"></a>memory_order</h4><p>c++11中有7种memory_order的枚举值<br>operator之类的函数，事实上都是memory_order_seq_cst作为memory_order参数的原子操作的简单封装。<br>release-acquire顺序，即前者之前的写必须全部完成，后者之前的读必须全部完成，是一种传递的关系，比如A-B-C，那么A一定在C之前<br>release-consume顺序，即生产者消费者的同步顺序，消费者必须等待生产者<br>关于并行需要自行学习。</p><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>__thread前缀关键字可以将变量声明为TLS变量（线程局部存储）（g++/clang++/xlc++）<br>在c++11中，可以用 thread_local 修饰符来声明变量。<br>thread_local声明的变量在不同平台或不同的TLS实现上可能出现不同的性能。</p><h3 id="关于退出"><a href="#关于退出" class="headerlink" title="关于退出"></a>关于退出</h3><p>terminate函数是异常处理的一部分，是c++程序层面的“终止”<br>abort（源自c中）更加低层，甚至于terminate默认是调用abort的。默认情况下，它向POSIX系统抛出信号：SIGABRT。操作系统会默认释放进程所有资源，从而终止程序。这有时会带来一些问题，典型的如不健壮的交互进程中意外终止导致处于中间状态进而出现问题。<br>exit属于正常退出范畴的程序终止，会调用自动变量的析构函数，还会调用atexit注册的函数，与main函数结束时的清理工作是一样的。<br>但是会有类析构依次归还零散内存这种费力不讨好的事情————可以直接给操作系统统一回收，如果这些堆内存对其他程序不产生任何影响，这种析构就无意义。另外，在多线程情况下可能会有更严重的问题：等待I/O运行结束、信号顺序导致死锁卡死等复杂情况等等。<br>在c++11中，标准引入了quick_exit函数，与abort不同的是，quick_exit与exit同属于正常退出。也可以调用at_quick_exit注册函数。</p><h3 id="default和delete"><a href="#default和delete" class="headerlink" title="default和delete"></a>default和delete</h3><p>= default意味着显示指示编译器生成该函数的默认版本。<br>可以在提供缺省函数的版本和自定义版本间进行切换，对代码调试很有帮助。<br>= delete意味着指示编译器不生成函数的缺省版本，可以避免编译器做不必要的隐式数据类型转换<br>注意不要混用explicit和 = delete，前者修饰构造函数使其显示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ConvType&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ConvType(<span class="keyword">int</span> i)&#123;&#125;;</div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ConvType</span><span class="params">(<span class="keyword">char</span> c)</span> </span>= <span class="keyword">delete</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(ConvType ct)</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    Func(<span class="number">3</span>);</div><div class="line">    Func(<span class="string">'a'</span>);<span class="comment">//可以通过编译，没想到吧？</span></div><div class="line"></div><div class="line">    <span class="function">ConvType <span class="title">ci</span><span class="params">(<span class="number">3</span>)</span></span>;</div><div class="line">    <span class="function">ConvType <span class="title">cc</span><span class="params">(<span class="string">'a'</span>)</span></span>;<span class="comment">//无法通过编译。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>另外，显式删除的范围很广，可以作用于普通函数，使其调用编译失败。<br>于是可以推广到构建Singleton单件模式。</p><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    []&#123;&#125;;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</div><div class="line">    [=] &#123; <span class="keyword">return</span> a + b;&#125;;</div><div class="line">    <span class="keyword">auto</span> fun1 = [&amp;](<span class="keyword">int</span> c) &#123; b = a + c;&#125;;</div><div class="line">    <span class="keyword">auto</span> fun2 = [=,&amp;b](<span class="keyword">int</span> c)-&gt;<span class="keyword">int</span> &#123; <span class="keyword">return</span> b += a + c;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据现行的c++11标准，在块作用域以外的lambda函数捕捉列表必须为空。</p><p><em>lambda是仿函数的语法糖</em></p><p>lambda的捕捉列表中，值和引用的效果是不同的<br>让我们康一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">12</span>;</div><div class="line">    <span class="keyword">auto</span> by_val_lambda = [=] &#123; <span class="keyword">return</span> j + <span class="number">1</span>;&#125;;</div><div class="line">    <span class="keyword">auto</span> by_ref_lambda = [&amp;] &#123; <span class="keyword">return</span> j + <span class="number">1</span>;&#125;;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"by_val_lambda: "</span> &lt;&lt; by_val_lambda() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//13</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"by_ref_lambda: "</span> &lt;&lt; by_ref_lambda() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//13</span></div><div class="line"></div><div class="line">    j++;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"by_val_lambda: "</span> &lt;&lt; by_val_lambda() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//13</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"by_ref_lambda: "</span> &lt;&lt; by_ref_lambda() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//14</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不能改变没有声明mutable的lambda捕捉值</p><p>稍微做了个小实验，发现decltype nb，然后传引用的时候const很有影响，不要被迷惑了。<br>可以放一个未实现的函数模板f，通过其参数让编译器告诉你decltype推导出的类型。</p><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><p>alignof()查看数据对齐方式<br>alignas()设定对齐方式</p><p>标准建议用户在声明同一个变量时使用同样的对齐方式以免发生意外</p><p>alignas引入是为了解决固定容量的泛型数组的问题的。<br>aligned_storage和aligned_union专门为库模板类型设计。</p><p>总之，c++11对对齐方式的支持是全方面的。（想研究就自己去查吧【</p><h3 id="关于属性"><a href="#关于属性" class="headerlink" title="..关于属性"></a>..关于属性</h3><p>[[noreturn]]是用于标识不会返回的函数的。不会返回和没有返回值的(void)函数的区别。没有返回值的void在调用完成后，会接着执行函数后的代码；而不会返回的函数在被调用完成后，后续代码不会被执行。</p><p>[[carries_dependency]]则跟并行情况下的编译器优化有关。为了解决弱内存模型平台上使用memory_order_consume内存顺序枚举问题。</p><h3 id="关于unicode"><a href="#关于unicode" class="headerlink" title="关于unicode"></a>关于unicode</h3><p>unicode依然还是非常复杂的一部分<br>但是大体理解成utf-8用于存取，中间处理时可以转换成utf-16/utf-32，(char32_t,char16_t)<br>但是问题还是在于地区、接口、系统。知道了地区的locale，然后访问facet，然后codecvt….<br>如果需要，建议系统学习。这里只是了解一下c++11提供了一些支持。</p><h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><h3 id="关于c-11被删除的特性"><a href="#关于c-11被删除的特性" class="headerlink" title="关于c++11被删除的特性"></a>关于c++11被删除的特性</h3><p>被c++11移除的标准特性</p><ul><li>不再允许数组初始化时将数据类型收窄。</li><li>struct A{const int a;};这样静态初始化未定义的缺省构造函数被删除以提示可能存在的问题</li><li>去除了export特性，关键字保留</li><li>auto关键字（老式用法）</li><li>register关键字（老式用法，新式用于区别声明的变量仅仅拥有自动存储的生命期</li><li>隐式拷贝函数</li><li>auto_ptr(用unique_ptr替代)</li><li>bind1st,bind2nd被bind模板取代</li><li>adaptor弃用（函数适配器）</li><li>动态异常声明，空异常throw()被noexcept取代</li></ul><h3 id="本期结语"><a href="#本期结语" class="headerlink" title="本期结语"></a>本期结语</h3><p>《深入了解c++11》结束<br>笔记有点少，其实书的内容还是很多的。至少比cpp11faq多得多，不过因为属于补遗就只记了些前面没有或者是自己没记的<br>多线程和模板元还是困扰我的最大难题。<br>下期是c++14，14的内容不多，加油</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入了解c++11》阅读笔记&lt;br&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://oodtoodt.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="http://oodtoodt.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://oodtoodt.github.io/tags/c-11/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
  </entry>
  
  <entry>
    <title>cpp-11笔记_2</title>
    <link href="http://oodtoodt.github.io/2020/01/14/cpp-11-14-17%E7%AC%94%E8%AE%B0/cpp-11%E7%AC%94%E8%AE%B0-2/"/>
    <id>http://oodtoodt.github.io/2020/01/14/cpp-11-14-17%E7%AC%94%E8%AE%B0/cpp-11%E7%AC%94%E8%AE%B0-2/</id>
    <published>2020-01-14T04:52:18.000Z</published>
    <updated>2020-01-14T07:40:42.934Z</updated>
    
    <content type="html"><![CDATA[<p>大量POD预警，右值引用等<br><a id="more"></a></p><hr><h2 id="cpp-11-faq-阅读笔记"><a href="#cpp-11-faq-阅读笔记" class="headerlink" title="cpp-11-faq 阅读笔记"></a>cpp-11-faq 阅读笔记</h2><h3 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h3><p>在c++11中，POD的概念得到了规范和修正，我们还是先来看看POD是什么。<br>这里是一篇翻译自stackflow的文章，可能有些不通顺，然后因为我还加了一些东西所以…凑合着看，能看明白最好。</p><h4 id="一通乱七八糟的说明"><a href="#一通乱七八糟的说明" class="headerlink" title="一通乱七八糟的说明"></a>一通乱七八糟的说明</h4><p>所谓POD，指的是那些可以像C结构体一样直接操作的“普通”类型，对于该种类型，可以直接对它用meset()/memcpy()来进行初始化/拷贝等操作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> S &#123; <span class="keyword">int</span> a; &#125;;    <span class="comment">// S属于POD</span></div><div class="line"><span class="keyword">struct</span> SS &#123; <span class="keyword">int</span> a; SS(<span class="keyword">int</span> aa) : a(aa) &#123; &#125; &#125;; <span class="comment">// SS不属于POD在C98，但是在C11里它是</span></div><div class="line"><span class="keyword">struct</span> SSS &#123; <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">/* ... */</span> &#125;;</div></pre></td></tr></table></figure></p><p>C++11中引进或重新定义了POD、trivially-copyable类型、trivial类型、以及”标准布局”类型等概念，以用来处理C++98中原”POD”相关的一系列技术问题。<br>这里我们深入的了解一下关于Aggregate和POD类型</p><h5 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h5><blockquote><p>一个Aggregate是一个数组或者一个没有用户声明构造函数，没有私有或保护类型的非静态数据成员，没有父类和虚函数的类型 </p></blockquote><ul><li>这并不是说Aggregate类型就不能有构造函数，事实上，它可以拥有一个默认构造函数或者一个复制构造函数，只要他们是被编译器声明的，而不是被用户自己声明的。</li><li>不能拥有私有或者保护类型的非静态数据成员。你可以定义任意多的私有或者保护类型的成员方法（不包括构造函数）和静态类型的数据成员和方法，这都不违背Aggregate类型的规则。</li></ul><ul><li>Aggregate类型可以拥有用户声明的/用户定义的 赋值操作符或者析构函数</li><li>数组是Aggregate类型，即便是非Aggregate类型元素的数组。</li></ul><p>他们和非Aggregates类型不同，可以使用“{ }”初始化。</p><p>POD的含义可以从两个显著的特性说明：</p><p>1.它支持静态初始化，而且<br>2.在C++中编译POD类型会和C中编译的struct类型得到相同的内存布局</p><p>正是因为这个，这个定义被划分为两个不同的概念：trivial 类型和standard-layout 类型，因为这比POD类型更有用。新标准中已经很少使用POD这个术语了，而是更多的在使用更精确的概念：trival和stand-layout。</p><p>新的定义基本说明了POD类型既是trivial类型有事stand-layout，而且，这个特性递归地适用于每个非静态数据成员：</p><p>POD struct类型是既为trivial类型又为standard-layout类型，而且还没有非静态类型的non-POD struct和non-POD union（或者这些类型的数组）数据成员的non-union类型。相似地，POD union类型是极为trivial类型尤为standard-layout类型，而且还没有非静态类型的non-POD struct和non-POD union（或者这些类型的数组）数据成员的union类型。POD 类型包含POD struct和POD union这两种类型。</p><p>Wow，这个定义更难解读，不是吗？让我们吧unions剥离出去，更清晰的复述为：</p><blockquote><p>POD类型就是没有非静态类型的non-POD类型 （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的Aggregate类型。</p></blockquote><p>这个定义的有什么含义呢？（POD就是Plain Old Data）</p><p>1.所有的POD类型都是Aggregates类型，换句话说，如果不是aggregate类型，那么它一定不是POD类型。<br>2.类，和结构体一样可以为POD类型，因为标准中POD-struct这个术语包含了这两种情形。<br>3.和Aggregates类型一样，静态成员是什么类型则无关紧要</p><ul><li>POD类型是最接近于C语言中的结构体类型的。他们都没有改变对象的内存布局，但是，POD类型却可以有自己的成员函数和任意类型的静态成员。所以，如果你想写一个可在C甚至.net平台使用的可移植的动态库，你应该让暴露的所有的方法的返回值和参数都会POD类型。</li><li>非POD类型的对象的生命周期起始于构造函数，结束于析构函数调用完成。而POD类型对象的生命周期却起始于存储对象的空间被占用，结束于空间被释放或被重复利用。</li><li><p>对于POD类型的对象，C++标准保证当你使用memcpy将对象的内容拷贝到一个char类型或者unsigned char类型的数组中，在使用memcpy拷贝回来的时候，对象会保持不变。特别注意，非POD类型是无法保证这一点的。当然，你也可以安全的在对象之间拷贝POD类型。下面的这个例子假设T为POD类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N sizeof(T)</span></div><div class="line"><span class="keyword">char</span> buf[N];</div><div class="line">T obj; <span class="comment">// obj initialized to its original value</span></div><div class="line"><span class="built_in">memcpy</span>(buf, &amp;obj, N); <span class="comment">// between these two calls to memcpy,</span></div><div class="line"><span class="comment">// obj might be modified</span></div><div class="line"><span class="built_in">memcpy</span>(&amp;obj, buf, N); <span class="comment">// at this point, each subobject of obj of scalar type</span></div><div class="line"><span class="comment">// holds its original value</span></div></pre></td></tr></table></figure></li><li><p>goto 语句。你知道，使用goto从一个变量没有声明的点跳转到一个变量已经被声明的点是不合法的（编译器应该会有报错）。这个限制仅仅对非POD类型有效，下面这个例子f()是不合法的，而g()则是合法的。注意到微软的编译器对这条规则过于慷慨了，仅仅给出警告而已。</p></li><li>C++标准保证POD类型的对象在内存起始处没有便宜。也就是说如果一个POD类型A的第一个成员为T，你可以安全的调用reinterpret_cast  从A*转换为T*,得到第一个成员的指针，反过来也成立。</li></ul><p>之前，aggregate类型不能拥有用户声明的构造函数，现在，不能拥有用户提供的构造函数，有什么区别呢？因为现在你可以声明构造函数并设置为default。这依然是Aggregate类型，因为在声明时任何使用默认实现的构造函数（或者其他特殊成员函数）都不是用户提供的。</p><p>现在，Aggregate类型不能拥有任何{ }和=直接初始化(brace-or-equal-initializers)的非静态类型成员，什么意思呢？就是因为在新的标准下，我们可以像这样直接声明成员变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> NotAggregate &#123;</div><div class="line">     <span class="keyword">int</span> x = <span class="number">5</span>; <span class="comment">// valid in C++11</span></div><div class="line">     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// also valid</span></div><div class="line"> &#125;;</div></pre></td></tr></table></figure></p><p>//我们在上一篇里其实已经提到过啦，想不起来就回去复习！</p><h5 id="Trivial"><a href="#Trivial" class="headerlink" title="Trivial"></a>Trivial</h5><p>我们来分开、详细说明这两个特性。<br>好早之前说的：Trivial类型和Standard-layout类型<br>Trivial：支持静态初始化。它是拷贝不变[平凡复制 (Trivially Copyable)]的。c++中定义如下：<br>·没有non-trivial的复制构造函数<br>·没有non-trivial的转移构造函数<br>·没有non-trivial的赋值运算符<br>·没有non-trivial的转移赋值操作符<br>·有一个trivial的析构函数<br>一个trivial class类型是指由一个trivial类型的默认构造函数，而且是平凡复制 (Trivially Copyable)的class。(特别注意，拷贝不变类型和Trivial类型都不能由虚函数和虚基类)。那么这么trivial和non-trivial类型到底是什么呢？</p><p>Class X复制或转移构造函数是trivial类型的，如果他不是用户提供的，而且<br>· Class X没有任何虚函数和虚基类，而且<br>· 用于复制或转移直接基类的构造函数是trivial类型的，而且<br>· 复制或转移构造函数选择复制或转移的X内部的每一个非静态数据成员（或数组）必须是trivial类型的<br>否则，复制或转移构造函数就是non-trivial类型的<br>从根本上也就是说复制或转移构造函数是trivial类型的只要他不是用户提供的、类内部没有虚函数，而且这个规则要递归地适用于所有数据成员类型和基类。<br>Trivial类型赋值或转移操作符的定义类似，把构造函数替换为赋值操作符就可以了。<br>Trivial类型的析构函数也有类似的定义，不过要加一条限制，就是不能为虚函数。<br>Trivial类型的默认构造函数也需要加一条限制：上面我们已经看到了，不能拥有{ }或=初始化的（brace-or-equal-initializers）非静态数据成员。<br>这里有个几个例子能让你彻底明白每个类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// empty classes are trivial</span></div><div class="line"><span class="keyword">struct</span> Trivial1 &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// all special members are implicit</span></div><div class="line"><span class="keyword">struct</span> Trivial2 &#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Trivial3 : Trivial2 &#123; <span class="comment">// base class is trivial</span></div><div class="line">    Trivial3() = <span class="keyword">default</span>; <span class="comment">// not a user-provided ctor</span></div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Trivial4 &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line"><span class="keyword">private</span>: <span class="comment">// no restrictions on access modifiers</span></div><div class="line">    <span class="keyword">int</span> b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Trivial5 &#123;</div><div class="line">    Trivial1 a;</div><div class="line">    Trivial2 b;</div><div class="line">    Trivial3 c;</div><div class="line">    Trivial4 d;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Trivial6 &#123;</div><div class="line">    Trivial2 a[<span class="number">23</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Trivial7 &#123;</div><div class="line">    Trivial6 c;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// it's okay to have non-virtual functions</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Trivial8 &#123;</div><div class="line">     <span class="keyword">int</span> x;</div><div class="line">     <span class="keyword">static</span> NonTrivial1 y; <span class="comment">// no restrictions on static members</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Trivial9 &#123;</div><div class="line">     Trivial9() = <span class="keyword">default</span>; <span class="comment">// not user-provided</span></div><div class="line">      <span class="comment">// a regular constructor is okay because we still have default ctor</span></div><div class="line">     Trivial9(<span class="keyword">int</span> x) : x(x) &#123;&#125;;</div><div class="line">     <span class="keyword">int</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> NonTrivial1 : Trivial <span class="number">3</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// virtual members make non-trivial ctors</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> NonTrivial2 &#123;</div><div class="line">    NonTrivial2() : z(<span class="number">42</span>) &#123;&#125; <span class="comment">// user-provided ctor</span></div><div class="line">    <span class="keyword">int</span> z;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> NonTrivial3 &#123;</div><div class="line">    NonTrivial3(); <span class="comment">// user-provided ctor</span></div><div class="line">    <span class="keyword">int</span> w;</div><div class="line">&#125;</div><div class="line">NonTrivial3::NonTrivial3() = <span class="keyword">default</span>; <span class="comment">// defaulted but not on first declaration</span></div><div class="line">                                      <span class="comment">// still counts as user-provided</span></div><div class="line"><span class="keyword">struct</span> NonTrivial5 &#123;</div><div class="line">    <span class="keyword">virtual</span> ~NonTrivial5(); <span class="comment">// virtual destructors are not trivial</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h5 id="starndard-layout"><a href="#starndard-layout" class="headerlink" title="starndard-layout"></a>starndard-layout</h5><p>Standard-layout是第二个特性，C++标准中说它对语言间交互很有用，这是因为C++ standard-layout类型和C中struct或union类型有相同的内存布局。 </p><p>这是另一个需要所有成员和基类递归遵循的特性。而且，虚函数和虚基类也是不允许的，这会让内存布局与C不兼容。 </p><p>这里有一个规定放开了，那就是standard-layout类型的非静态数据成员必须是相同的访问控制，之前他们都必须是public类型的，但是现在他们可以是private或protected类型的了，只要他们都属于同一种。 </p><p>当使用继承时，在整个继承体系中，只允许一个类拥有非静态数据成员，而且第一个非静态数据成员不能是基类的（这可能打乱量化规则），否则，就不是standard-layout类型。 </p><p>C++标准中的是这样定义的：</p><p>standard-layout 类型的类是指：</p><p>没有 non-standard-layout类型（或这些类型的数组）和引用的非静态数据成员<br>没有虚函数和虚基类<br>非静态数据成员的访问控制必须是相同的<br>没有non-standard-layout的基类<br>在最底层的派生类中没有非静态数据成员，而且在最多有一个基类拥有非静态数据成员，或者没有拥有非静态数据成员<br>相同基类类型的非静态数据成员不能作为第一个成员<br>standard-layout类型struct就是以struct或class为关键字定义的standard-layout 类型。</p><p>standard-layout类型union就是以union为关键字定义的standard-layout 类型。</p><p>[注意：standard-layout类型在C++与其他语言交互时非常重要]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">现在我们来看几个例子：</div><div class="line"><span class="comment">// empty classes have standard-layout</span></div><div class="line"><span class="keyword">struct</span> StandardLayout1 &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> StandardLayout2 &#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> StandardLayout3 &#123;</div><div class="line"><span class="keyword">private</span>: <span class="comment">// both are private, so it's ok</span></div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> StandardLayout4 : StandardLayout1 &#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// perfectly fine to have non-virtual functions</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> StandardLayout5 : StandardLayout1 &#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    StandardLayout1 y; <span class="comment">// can have members of base type if they're not the first</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> StandardLayout6 : StandardLayout1, StandardLayout5 &#123;</div><div class="line">    <span class="comment">// can use multiple inheritance as long only</span></div><div class="line">    <span class="comment">// one class in the hierarchy has non-static data members</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> StandardLayout7 &#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">int</span> y;</div><div class="line">    StandardLayout7(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125; <span class="comment">// user-provided ctors are ok</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> StandardLayout8 &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    StandardLayout8(<span class="keyword">int</span> x) : x(x) &#123;&#125; <span class="comment">// user-provided ctors are ok</span></div><div class="line"><span class="comment">// ok to have non-static data members and other members with different access</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> StandardLayout9 &#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">static</span> NonStandardLayout1 y; <span class="comment">// no restrictions on static members</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> NonStandardLayout1 &#123;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// cannot have virtual functions</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> NonStandardLayout2 &#123;</div><div class="line">    NonStandardLayout1 X; <span class="comment">// has non-standard-layout member</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> NonStandardLayout3 : StandardLayout1 &#123;</div><div class="line">    StandardLayout1 x; <span class="comment">// first member cannot be of the same type as base</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> NonStandardLayout4 : StandardLayout3 &#123;</div><div class="line">    <span class="keyword">int</span> z; <span class="comment">// more than one class has non-static data members</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> NonStandardLayout5 : NonStandardLayout3 &#123;&#125;; <span class="comment">// has a non-standard-layout base class</span></div></pre></td></tr></table></figure></p><p>结论：</p><p>在新的标准下，很多新类型成为POD类型，而且，就算一个类型不是POD类型，我们也可以分别利用POD类型的特性（只要这个类型是trivial或者standard-layout）。</p><p>标准模板块（STL）在头文件<type_traits>中定义了对这些类型的检测：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> <span class="built_in">std</span>::is_pod;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> <span class="built_in">std</span>::is_trivial;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> <span class="built_in">std</span>::is_trivially_copyable;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> <span class="built_in">std</span>::is_standard_layout;</div></pre></td></tr></table></figure></type_traits></p><h4 id="另一份说明"><a href="#另一份说明" class="headerlink" title="另一份说明"></a>另一份说明</h4><p>我相信你看了上面那份文档之后什么也没看懂。<br>那么再来看这篇。。。</p><p><a href="https://www.jianshu.com/p/cf350108270f" target="_blank" rel="external">https://www.jianshu.com/p/cf350108270f</a></p><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>本段分三个部分讲，从最开始的C++03一直到目前的C++17。<br>首先要明白一个从属关系和这两个概念的基本：<br>聚类(aggregate)是PODs的一个超集，即如果一个class（在标准中，术语class代表了class，struct，union）是PODs，那么这个类就必为聚类，但是如果一个class是聚类，这个class不一定是一个PODs。<br>那么首先要明白的是，聚类的一个最明显的特性，一个聚类要求，其本身实例的结构和内部定义的结构一致，即和C中的struct一样，其实实际上是异常相似，里面的成员是什么，那么相应一个实例的内部构造就是这些东西组成的，并且要求以上说道的这些成员是语法可见的</p><h5 id="C-03"><a href="#C-03" class="headerlink" title="C++03"></a>C++03</h5><h6 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h6><ul><li><p>一个聚类由本身特性可知，聚类是不可能有多态的，因为如果存在，则必须在实例内保留一个指针指向虚表以确定正确执行当前实例动态类型的函数</p></li><li><p>以任意访问限定存在的成员函数，静态数据成员都是允许的，因为以上两者不会影响对象实例的内部结构</p></li><li><p>聚类不能有用户定义的任何形式的构造函数（以下统称构造函数），即移动，拷贝，构造，等，（下面是C++11的内容扩展）但是用户可以显示指定出来，即显示说明构造函数的访问限定（在构造函数后加=default)</p></li></ul><p>以上是PODs和聚类相同的地方。</p><p>不同的地方有：</p><ul><li><p>聚类可以有用户定义的复制函数，析构函数</p></li><li><p>聚类的非静态成员可以是非PODs的类型（包括数组，只要是一个数组，就是一个聚类）</p></li></ul><h6 id="PODs"><a href="#PODs" class="headerlink" title="PODs"></a>PODs</h6><ul><li>PODs要求，用户不能自定义复制函数，析构函数，并且非静态成员成员必须在满足聚类前提下不能是非PODs类型，以及引用类型</li></ul><p>以上是C++03的聚类和POD的定义，下面来看一下特点，示例请在<a href="https://github.com/KinoluKaslana/CPPLearning/blob/master/Aggregate_and_PODs.cpp" target="_blank" rel="external">https://github.com/KinoluKaslana/CPPLearning/blob/master/Aggregate_and_PODs.cpp</a> 中查看</p><ul><li><p>从数组说起，其初始化可以通过一个{}进行初始化（即进行显式初始化），当initlizer_list中的数量等于数组容量时，将对其进行等值拷贝，如果存在小于的情况，那么其余没有被值包括到的数据就会被按照默认的初始化方式进行初始化，对于表两类型，其会被初始化为0,对于成员类元素则是调用其默认构造函数，但是如果成员是引用，则无法对其进行默认初始化</p></li><li><p>对于其他的聚类也一样可以通过一对{}将其成员数据直接初始化，没有被包括的则按照默认初始化，如果类数据成员和引用不存在直接初始化数据（对于类数据则需要传入相应构造函数的数据格式）则会抛出错误</p></li></ul><p>注意，以上显式初始化并不走任何的构造函数</p><h5 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h5><h6 id="C-11较C-03"><a href="#C-11较C-03" class="headerlink" title="C++11较C++03"></a>C++11较C++03</h6><ul><li><p>对聚类的变化不大，只是对C++11中的新特性——在定义时类成员初始化做了限制，当一个类，存在非静态的类内成员初始化，那么这个类就不是一个聚类</p></li><li><p>对描述：不能有用户声明的构造函数；改为-&gt;不能有用户提供功能的构造函数</p></li><li><p>但是对于POD则进行了极大的改动，并且将其拆为了两个更加实用的两个类：<br>trivial和standard layout</p></li></ul><h6 id="trivial："><a href="#trivial：" class="headerlink" title="trivial："></a>trivial：</h6><p>要了解这个类，就必须了解什么是trivial和non-trivial<br>如果一个类型符合以下规定：</p><ul><li><p>没有用户提供的析构，复制，移动构造函数（赋值运算符），允许继承或被继承但没有虚函数，虚基类</p></li><li><p>对于所有的数据成员，基类数据成员，作为数据成员的数组的元素类型，必须递归的满足上述条件</p></li><li><p>对于构造函数，则同样满足之前Aggregate的规则同样也不能存在非静态数据成员的花括号，等号的初始化。</p></li><li><p>对于析构函数，也满足不能是虚函数条件</p></li></ul><p>那么这个类型就是一个trivial copyable的类型</p><p>所有的平凡约定，均代表默认，即非用户提供的<br>注意:</p><ul><li><p>trivially copyable是trivial的超集，前者不对默认构造函数有要求，后者对默认构造函数有要求，但是不对其他非移动，复制的构造之外的构造函数有限制。</p></li><li><p>对于standard layout 的类，不对任何构造函数，析构函数，复制、移动的构造函数，复制、移动的复制运算符做要求，同时，只要求所有的非静态数据成员不为非standard layout类型，和标量类型，同时不能有虚基类，虚函数，多继承是被允许的，对于所有的数据成员，并不做任何访问限制要求，唯一的规定是所有的数据成员必须是同一个访问限制的。</p></li><li><p>由于trivially copyable是不对任何默认构造函数有要求的，所以单独只能在trivially copyable以及std layout中使用member interlized对POD系成员进行初始化。</p></li></ul><h5 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h5><p>C++14中仅仅对aggregate做了一个小修改：</p><ul><li>允许使用成员初始化。</li></ul><p>那么到现在各部分的定义就为：</p><h6 id="aggregate："><a href="#aggregate：" class="headerlink" title="aggregate："></a>aggregate：</h6><ul><li><p>不允许当前将被定义为aggregate的类（以下称之为该类）在任何位置存在任何虚函数。</p></li><li><p>该类不允许出现非public的非静态成员</p></li><li><p>成员函数可以为任意访问限定</p></li><li><p>不允许有用户提供的构造函数，但是允许有用户提供的重载赋值运算符，析构函数，同样，这一条定义也必须符合前几条的规定</p></li><li><p>允许基类，非静态数据成员为任意类型，即非aggregate的都可以，并且允许其有成员初始化。</p></li></ul><h6 id="trivially-cpoyable"><a href="#trivially-cpoyable" class="headerlink" title="trivially cpoyable"></a>trivially cpoyable</h6><p>如果一个类是trivially copyable的话，则需要遵守以下规则：</p><ul><li><p>不允许出现非trivial（即用户提供的）复制、移动构造，重载赋值运算符，析构函数</p></li><li><p>其可以继承，但不允许出现虚基类，虚函数</p></li><li><p>所有的非静态数据成员，基类必须递归满足上述条件即trivially copyable的</p></li></ul><h6 id="trivial"><a href="#trivial" class="headerlink" title="trivial"></a>trivial</h6><p>如果一个类是trivial的话，需要遵守以下规则：</p><ul><li><p>必须满足所有的trivially copyable的规定</p></li><li><p>默认构造函数必须为平凡，即不允许出现成员初始化。</p></li><li><p>对所有的trivial成员，基类，必须递归满足上述两条。</p></li></ul><h6 id="standard-layout"><a href="#standard-layout" class="headerlink" title="standard layout"></a>standard layout</h6><p>如果一个类是standard layout的话，需要遵守以下规则：</p><ul><li><p>所有的非静态数据成员必须是同一个访问限定，并且不能是非standard layout的，同时第一个非静态数据成员不能是基类类型</p></li><li><p>不能有虚基类，虚函数。</p></li><li><p>继承树上，只允许有一成员存在非静态数据成员</p></li><li><p>对于所有基类，数据成员递归检测上述约定不能存在菱形继承。</p></li></ul><h5 id="C-17："><a href="#C-17：" class="headerlink" title="C++17："></a>C++17：</h5><h6 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h6><p>一、<br>在C++14的基础上，允许aggregate存在继承，但是继承必须是非虚，非private，protected，并不强制要求基类为aggregate</p><p>二、<br>不允许存在继承构造，explicit的构造函数</p><p>三、<br>如果成员，基类为非aggregate那么他们仍然是list-initialized,此时调用的是相应参数的构造函数，如果不存在，则抛出错误。</p><h6 id="trivial-1"><a href="#trivial-1" class="headerlink" title="trivial"></a>trivial</h6><p>trivially copyable：<br>对C++14中明确规定的必须包含非trivial的复制，移动构造，运算符重载进行重申——一个要求为trivial的类至少包含一个为非删除的其中以上的所有函数，并且必须包含一个trivial的非析构函数，对于其成员类型，以上函数被声明为删除是会影响当前类的trivially copyable的特性的。</p><p>trivial：<br>同上，在满足上述trivially copyable的情况下，也必须包含一个trivial的，非删除的默认构造函数</p><h6 id="standard-layout："><a href="#standard-layout：" class="headerlink" title="standard layout："></a>standard layout：</h6><p>C++17对standard layout的继承，有了更加严格的定义：</p><ul><li><p>当存在第一个数据成员为以下类型时，其对应的基类类型不能是：</p></li><li><p>数据成员为X，其不含有非静态数据成员，那么基类类型的限制集为空集</p></li><li><p>数据成员为X，其中第一个非静态数据成员类型为X0（有可能是一个匿名union）那么此时基类的限制类型为X0和其X0的元素（如果存在的话）组成</p></li><li><p>数据成员为X，X是一个union，那么基类限制集为X中所有的类型，并且对其union的类型的成员进行递归本定义的所有条款。</p></li><li><p>数据成员为X，X是类型为X1的数组那么集合为X1和X1的类型集合组成，该条规定递归本定义中所有条款</p></li><li><p>数据成员不X，为类，不为数组类型，那么集合为空。</p></li></ul><p>注意，所有条款中，出现子类型的均对其子类型递归执行上述所有条款。</p><hr><h3 id="原生字符串标识"><a href="#原生字符串标识" class="headerlink" title="原生字符串标识"></a>原生字符串标识</h3><p>来了来了，lua必备嗷<br>string s = “\w\\\w”;<br>string s = R”(\w\\w)”;<br>引发原生字符串标识提议的是这样一个“惊天地泣鬼神”的例子：<br>“(‘(?:[^\\‘]|\\.)<em>‘|\”(?:[^\\\”]|\\.)</em>\”)|”  // 这五个反斜杠是否正确?<br>      // 即使是专家，也很容易被这么多反斜杠搞得晕头转向<br>我傻了。<br>通过在“(…)”的(…)前后添加显式的自定义分隔号(译注:例如下面例子中的三个星号<em>)，我们还可以创造出任何我们想要的分隔语法。<br>// 字符串为：”quoted string containing the usual terminator (“)”<br>R”**</em>(“quoted string containing the usual terminator (“)”)<em>*</em>“<br>这一点和lua不谋而合（应该说肯定是有的肯定是抄的另一个233）</p><h3 id="右角括号"><a href="#右角括号" class="headerlink" title="右角括号"></a>右角括号</h3><p>考虑如下代码<br>list<vector<string>&gt; lvs;<br>在C++98中，这是一个语法错误，因为两个右角括号(‘&gt;’)之间没有空格（译注：因此，编译器会将它分析为”&gt;&gt;”操作符）。C++0x可以正确地分辨出这是两个右角括号(‘&gt;’)，是两个模板参数列表的结尾。</vector<string></p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>作者：Tinro<br>链接：<a href="https://www.zhihu.com/question/22111546/answer/30801982" target="_blank" rel="external">https://www.zhihu.com/question/22111546/answer/30801982</a><br>来源：知乎<br>右值引用至少可以解决以下场景中的移动语义缺失问题：</p><ol><li>按值传入参数<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> People &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  People(<span class="built_in">string</span> name) <span class="comment">// 按值传入字符串，可接收左值、右值。接收左值时为复制，接收右值时为移动</span></div><div class="line">  : name_(move(name)) <span class="comment">// 显式移动构造，将传入的字符串移入成员变量</span></div><div class="line">  &#123;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">string</span> name_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">People <span class="title">a</span><span class="params">(<span class="string">"Alice"</span>)</span></span>; <span class="comment">// 移动构造name</span></div><div class="line"></div><div class="line"><span class="built_in">string</span> bn = <span class="string">"Bob"</span>;</div><div class="line"><span class="function">People <span class="title">b</span><span class="params">(bn)</span></span>; <span class="comment">// 拷贝构造name</span></div></pre></td></tr></table></figure></li></ol><p>如果你要在构造函数中接收std::shared_ptr<x>并且存入类的成员（这是非常常见的），那么按值传入更是不二选择。拷贝std::shared_ptr<x>需要线程同步，相比之下移动std::shared_ptr是非常轻松愉快的。</x></x></p><ol><li>按值返回<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;* vec)</span></span>; <span class="comment">// 一个按值语义定义的字符串拆分函数。这里不考虑分隔符，假定分隔符是固定的。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_split(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) &#123;</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">return</span> v; <span class="comment">// v是左值，但优先移动，不支持移动时仍可复制。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>return语句又直接返回了一个栈上的左值对象（输入参数除外）时，标准要求优先调用移动构造函数，如果不符再调用拷贝构造函数。尽管v是左值，仍然会优先采用移动语义，返回vector<string>从此变得云淡风轻。<br>对于std::unique_ptr来说，这简直就是福音。</string></p><ol><li>接受右值表达式</li></ol><p>没有移动语义时，以表达式的值（例为函数调用）初始化对象或者给对象赋值是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_split(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s);</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = str_split(<span class="string">"1,2,3"</span>); <span class="comment">// 返回的vector用以拷贝构造对象v。为v申请堆内存，复制数据，然后析构临时对象（释放堆内存）。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2;</div><div class="line">v2 = str_split(<span class="string">"1,2,3"</span>); <span class="comment">// 返回的vector被复制给对象v（拷贝赋值操作符）。需要先清理v2中原有数据，将临时对象中的数据复制给v2，然后析构临时对象。</span></div><div class="line">注：v的拷贝构造调用有可能被优化掉，尽管如此在语义上仍然是有一次拷贝操作。同样的代码，在支持移动语义的世界里就变得更美好了。<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_split(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s);</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = str_split(<span class="string">"1,2,3"</span>); <span class="comment">// 返回的vector用以移动构造对象v。v直接取走临时对象的堆上内存，无需新申请。之后临时对象成为空壳，不再拥有任何资源，析构时也无需释放堆内存。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2;</div><div class="line">v2 = str_split(<span class="string">"1,2,3"</span>); <span class="comment">// 返回的vector被移动给对象v（移动赋值操作符）。先释放v2原有数据，然后直接从返回值中取走数据，然后返回值被析构。</span></div></pre></td></tr></table></figure></p><p>注：v的移动构造调用有可能被优化掉，尽管如此在语义上仍然是有一次移动操作。不用多说也知道上面的形式是多么常用和自然。而且这里完全没有任何对右值引用的显式使用，性能提升却默默的实现了。</p><ol><li>对象存入容器</li></ol><p>这个问题和前面的构造函数传参是类似的。不同的是这里是按两种引用分别传参。参见std::vector的push_back函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">( <span class="keyword">const</span> T&amp; value )</span></span>; <span class="comment">// (1)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">( T&amp;&amp; value )</span></span>; <span class="comment">// (2)</span></div></pre></td></tr></table></figure></p><p>不用多说自然是左值调用1右值调用2。如果你要往容器内放入超大对象，那么版本2自然是不2选择。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; vv;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">"123"</span>, <span class="string">"456"</span>&#125;;</div><div class="line">v.push_back(<span class="string">"789"</span>); <span class="comment">// 临时构造的string类型右值被移动进容器v</span></div><div class="line">vv.push_back(move(v)); <span class="comment">// 显式将v移动进vv</span></div></pre></td></tr></table></figure></p><p>困扰多年的难言之隐是不是一洗了之了？</p><ol><li><p>std::vector的增长又一个隐蔽的优化。当vector的存储容量需要增长时，通常会重新申请一块内存，并把原来的内容一个个复制过去并删除。对，复制并删除，改用移动就够了。<br>对于像vector<string>这样的容器，如果频繁插入造成存储容量不可避免的增长时，移动语义可以带来悄无声息而且美好的优化。</string></p></li><li><p>std::unique_ptr放入容器曾经，由于vector增长时会复制对象，像std::unique_ptr这样不可复制的对象是无法放入容器的。但实际上vector并不复制对象，而只是“移动”对象。所以随着移动语义的引入，std::unique_ptr放入std::vector成为理所当然的事情。<br>容器中存储std::unique_ptr有太多好处。想必每个人都写过这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyObj::MyObj() &#123;</div><div class="line">  <span class="keyword">for</span> (...) &#123;</div><div class="line">    vec.push_back(<span class="keyword">new</span> T());</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">MyObj::~MyObj() &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;T*&gt;::iterator iter = vec.begin(); iter != vec.end(); ++iter) &#123;</div><div class="line">    <span class="keyword">if</span> (*iter) <span class="keyword">delete</span> *iter;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>繁琐暂且不说，异常安全也是大问题。使用vector<unique_ptr<t>&gt;，完全无需显式析构，unqiue_ptr自会打理一切。完全不用写析构函数的感觉，你造吗？<br>unique_ptr是非常轻量的封装，存储空间等价于裸指针，但安全性强了一个世纪。实际中需要共享所有权的对象（指针）是比较少的，但需要转移所有权是非常常见的情况。auto_ptr的失败就在于其转移所有权的繁琐操作。unique_ptr配合移动语义即可轻松解决所有权传递的问题。<br>注：如果真的需要共享所有权，那么基于引用计数的shared_ptr是一个好的选择。shared_ptr同样可以移动。由于不需要线程同步，移动shared_ptr比复制更轻量。</unique_ptr<t></p><ol><li>std::thread的传递<br>thread也是一种典型的不可复制的资源，但可以通过移动来传递所有权。同样std::future std::promise std::packaged_task等等这一票多线程类都是不可复制的，也都可以用移动的方式传递。</li></ol><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>除了移动语义，右值引用还解决了C++03中引用语法无法转发右值的问题，实现了完美转发，才使得std::function能有一个优雅的实现。<br>==这部分不再展开了。==</p><h3 id="静态编译期断言"><a href="#静态编译期断言" class="headerlink" title="静态编译期断言"></a>静态编译期断言</h3><p>在判断代码的编译环境方面十分有用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span>) &gt;= <span class="number">8</span>,</div><div class="line">   “<span class="number">64</span>-bit code generation required <span class="keyword">for</span> <span class="keyword">this</span> library.”);</div><div class="line"><span class="keyword">struct</span> S &#123; X m1; Y m2; &#125;;</div><div class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(S)==<span class="keyword">sizeof</span>(X)+<span class="keyword">sizeof</span>(Y),</div><div class="line">    ”unexpected padding in S”);</div></pre></td></tr></table></figure></p><h3 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> alias_map</div><div class="line">&#123;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, T&gt; <span class="built_in">map</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">alias_map&lt;<span class="keyword">int</span>&gt;::<span class="built_in">map</span> <span class="keyword">map_t</span>;</div><div class="line">alias_map&lt;<span class="keyword">int</span>&gt;::<span class="built_in">map</span> map_str;</div></pre></td></tr></table></figure><p>在c++11中就可以这样实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> alias_map = <span class="built_in">std</span>::<span class="built_in">map</span> &lt; <span class="built_in">std</span>::<span class="built_in">string</span>, T &gt; ;</div><div class="line"> </div><div class="line">alias_map&lt;<span class="keyword">int</span>&gt;  <span class="keyword">map_t</span>;</div><div class="line">alias_map&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; map_str;</div></pre></td></tr></table></figure></p><p>另外二者在普通类型的别名定义上基本等效。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFD)</span><span class="params">(<span class="keyword">double</span>)</span></span>;            <span class="comment">// 傳統語法</span></div><div class="line"><span class="keyword">using</span> PFD = <span class="keyword">void</span> (*)(<span class="keyword">double</span>);           <span class="comment">// 新增語法</span></div></pre></td></tr></table></figure></p><p>其实我没看懂这个例子，也编译不了，先讲点别的：<br>c++11——type_traits 类型萃取<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">is_pod</span><span class="params">(T)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::is_pod&lt;T&gt;::value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在展开traits之前，我们来讨论一下typename的问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_dstructor trivial_destructor</div></pre></td></tr></table></figure></p><p>那么我们还需要知道几个概念</p><h5 id="限定名和非限定名"><a href="#限定名和非限定名" class="headerlink" title="限定名和非限定名"></a>限定名和非限定名</h5><p>限定名(qualified name)，故名思义，是限定了命名空间的名称。看下面这段代码，cout和endl就是限定名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>cout和endl前面都有std::，它限定了std这个命名空间，因此称其为限定名。</p><p>如果在上面这段代码中，前面用using std::cout;或者using namespace std;，然后使用时只用cout和endl，它们的前面不再有空间限定std::，所以此时的cout和endl就叫做非限定名(unqualified name)。</p><p>依赖名(dependent name)是指依赖于模板参数的名称，而非依赖名(non-dependent name)则相反，指不依赖于模板参数的名称。看下面这段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> MyClass &#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vitr;</div><div class="line"> </div><div class="line">    T t;</div><div class="line">    <span class="built_in">vector</span>&lt;T&gt; vt;</div><div class="line">    <span class="built_in">vector</span>&lt;T&gt;::iterator viter;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>因为是内置类型，所以类中前三个定义的类型在声明这个模板类时就已知。然而对于接下来的三行定义，只有在模板实例化时才能知道它们的类型，因为它们都依赖于模板参数T。因此，T, vector<t>和vector<t>::iterator称为依赖名。前三个定义叫做非依赖名。</t></t></p><p>更为复杂一点，如果用了typedef T U; U u;，虽然T没再出现，但是U仍然是依赖名。由此可见，不管是直接还是间接，只要依赖于模板参数，该名称就是依赖名。</p><h5 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h5><p>在类外部访问类中的名称时，可以使用类作用域操作符，形如MyClass::name的调用通常存在三种：静态数据成员、静态成员函数和嵌套类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> MyClass &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">B</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> C;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>MyClass::A, MyClass::B, MyClass::C分别对应着上面三种。</p><h5 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">    T::iterator * iter;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> ContainsAType &#123;</div><div class="line">    <span class="keyword">struct</span> iterator &#123; <span class="comment">/*...*/</span> &#125;;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo&lt;ContainsAType&gt;();</div></pre></td></tr></table></figure><p>前面例子中的ContainsAType::iterator是嵌套类型，完全没有问题。可如果是静态数据成员呢？如果实例化foo模板函数的类型是像这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ContainsAnotherType &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> iterator;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>那么，T::iterator <em> iter;被编译器实例化为ContainsAnotherType::iterator </em> iter;，这是什么？前面是一个静态成员变量而不是类型，那么这便成了一个乘法表达式，只不过iter在这里没有定义，编译器会报错：<br>error C2065: ‘iter’ : undeclared identifier<br>但如果iter是一个全局变量，那么这行代码将完全正确，它是表示计算两数相乘的表达式，返回值被抛弃。</p><p>同一行代码能以两种完全不同的方式解释，而且在模板实例化之前，完全没有办法来区分它们，这绝对是滋生各种bug的温床。这时C++标准委员会再也忍不住了，与其到实例化时才能知道到底选择哪种方式来解释以上代码，委员会决定引入一个新的关键字，这就是typename。</p><p>对于用于模板定义的依赖于模板参数的名称，只有在实例化的参数中存在这个类型名，或者这个名称前使用了typename关键字来修饰，编译器才会将该名称当成是类型。除了以上这两种情况，绝不会被当成是类型。</p><p>因此，如果你想直接告诉编译器T::iterator是类型而不是变量，只需用typename修饰：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">typename</span> T::iterator * iter;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样编译器就可以确定T::iterator是一个类型，而不再需要等到实例化时期才能确定，因此消除了前面提到的歧义。</p><p>不过整个的这个规则看起来有些复杂，可以参考MSDN：</p><blockquote><p>typename在下面情况下禁止使用：</p><blockquote><p>模板定义之外，即typename只能用于模板的定义中非限定类型，比如前面介绍过的int，vector<int>之类<br>    基类列表中，比如template <class t=""> class C1 :T::InnerType不能在T::InnerType前面加typename<br>    构造函数的初始化列表中如果类型是依赖于模板参数的限定名，那么在它之前必须加typename(除非是基类列表，或者在类的初始化成员列表中)<br>    其它情况下typename是可选的，也就是说对于一个不是依赖名的限定名，该名称是可选的，例如vector<int> vi;</int></class></int></p></blockquote></blockquote><h3 id="统一初始化的语法和语义"><a href="#统一初始化的语法和语义" class="headerlink" title="统一初始化的语法和语义"></a>统一初始化的语法和语义</h3><p>按照对象的类型以及初始化时的上下文，C++提供了五花八门的对象初始化的方式。若不慎误用，可能会产生匪夷所思的谬误，而且还伴随着莫名其妙的错误（调试）信息。考虑如下的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> a[] = &#123; “foo”, ” bar” &#125;;  <span class="comment">//正确：初始化数组变量</span></div><div class="line"><span class="comment">//错误：初始化列表应用在了非聚合的向量上</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123; “foo”, ” bar” &#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">string</span> a[])</span></span>;</div><div class="line">f( &#123; “foo”, ” bar” &#125; );   <span class="comment">//语法错误，把一个块（block）作为了参数</span></div><div class="line">以及：</div><div class="line"></div><div class="line"><span class="keyword">int</span> a = <span class="number">2</span>;         <span class="comment">//“赋值风格”的初始化</span></div><div class="line"><span class="keyword">int</span> aa[] = &#123; <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">//用初始化列表进行的赋值风格的初始化</span></div><div class="line"><span class="function"><span class="keyword">complex</span> <span class="title">z</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;   <span class="comment">//“函数风格”的初始化</span></div><div class="line">x = Ptr(y);     <span class="comment">// “函数风格”的转换/赋值/构造操作</span></div><div class="line">再如：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">//变量的定义</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>;    <span class="comment">//函数的声明</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">(foo)</span></span>;    <span class="comment">// 变量的定义，或者函数的声明</span></div></pre></td></tr></table></figure></p><p>要记住这么多种初始化规则，并从中选用最合适的一种，绝非易事。<br>C++11的解决方法是对于所有的初始化，均可使用“{}-初始化变量列表”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">X x1 = X&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</div><div class="line">X x2 = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;     <span class="comment">// 此处的'='可有可无</span></div><div class="line">X x3&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</div><div class="line">X* p = <span class="keyword">new</span> X&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> D : X &#123;</div><div class="line">    D(<span class="keyword">int</span> x, <span class="keyword">int</span> y) :X&#123;x,y&#125; &#123; <span class="comment">/* … */</span> &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> S &#123;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">3</span>];</div><div class="line">    <span class="comment">// 对于旧有问题的解决方案</span></div><div class="line">    S(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) :a&#123;x,y,z&#125; &#123; <span class="comment">/* … */</span> &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>与以往相比最为关键的变动是，X{a}方式的初始化，在所有的语境中都能构造出同样的结果，所以凡是能用“{}”的初始化，得到的结果都是一致的。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">X x&#123;a&#125;;</div><div class="line">X* p = <span class="keyword">new</span> X&#123;a&#125;;</div><div class="line">z = X&#123;a&#125;;         <span class="comment">// 使用了类型转换</span></div><div class="line">f(&#123;a&#125;);           <span class="comment">// a作为函数的X型实参</span></div><div class="line"><span class="keyword">return</span> &#123;a&#125;;       <span class="comment">// a作为函数的X型返回值</span></div></pre></td></tr></table></figure></p><h3 id="关于union"><a href="#关于union" class="headerlink" title="关于union"></a>关于union</h3><p>在C/C++程序的编写中，当多个基本数据类型或复合数据结构要占用同一片内存时，我们要使用联合体；当多种类型，多个对象，多个事物只取其一时（我们姑且通俗地称其为“n选1”），我们也可以使用联合体来发挥其长处</p><p>union，在某种程度上类似结构体struct的一种数据结构，共用体(union)和结构体(struct)同样可以包含很多种数据类型和变量。<br>不过区别也挺明显：<br>结构体(struct)中所有变量是“共存”的——优点是“有容乃大”，全面；缺点是struct内存空间的分配是粗放的，不管用不用，全分配。<br>而联合体(union)中是各变量是“互斥”的——缺点就是不够“包容”；但优点是内存使用更为精细灵活，也节省了内存空间。</p><p>编写一段程序判断系统中的CPU是Little endian还是Big endian模式？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123; <span class="keyword">char</span> c[<span class="number">4</span>]; <span class="keyword">unsigned</span> <span class="keyword">long</span> l; &#125; endian_test = &#123; &#123; <span class="string">'l'</span>, <span class="string">'?'</span>, <span class="string">'?'</span>, <span class="string">'b'</span> &#125; &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ENDIANNESS ((char)endian_test.l)</span></div></pre></td></tr></table></figure></p><p>C++11中的对union的限制条件重新定义如下：<br>不含虚函数（与C++98相同）<br>不含引用成员（与C++98相同）<br>没有基类（与C++98相同）<br>若union的某个成员的类型含有自定义构造/拷贝/析构函数，那么该union的相应构造/拷贝/析构函数将会被自动“禁用”（译注：在C++11中我们可以使用delete关键字来“禁用”构造/析构函数），随之而来的后果是：该union不能被实例化成对象。（新增的所谓“第四条规则”）</p><p>==广义联合体==，扩充了对union的定义，但是它所说的“可识别union”我并没看懂，而且给出的例子里面出现了原地拷贝构造语法，极为奇怪（</p><h3 id="用户定义数据标识（User-defined-literals）"><a href="#用户定义数据标识（User-defined-literals）" class="headerlink" title="用户定义数据标识（User-defined literals）"></a>用户定义数据标识（User-defined literals）</h3><p>C++11通过在变量后面加上一个后缀来标定所需的类型以支持“用户定义数据标识”，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">complex</span> <span class="keyword">operator</span> <span class="string">""</span> i(<span class="keyword">long</span> <span class="keyword">double</span> d)    <span class="comment">// 设计中的数据标识</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="number">0</span>,d&#125;;    <span class="comment">//complex是一个数据标识</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 将n个字符构造成字符串std::string对象的数据标识</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">operator</span><span class="string">""</span>s (<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">size_t</span> n)    </div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(p,n);    <span class="comment">// 需要释放存储空间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>有以下四种数据标识的情况，可以被用户定义后缀来使用用户自定义数据标识：<br>· 整型标识：允许传入一个unsigned long long或者const char<em>参数<br>· 浮点型标识：允许传入一个long double或者const char</em>参数<br>· 字符串标识：允许传入一组(const char<em>,size_t)参数<br>· 字符标识：允许传入一个char参数。<br>注意，你为字符串标识定义的标识操作符不能只带有一个const char</em>参数（而没有大小）。<br>不同的命名空间可以避免标识冲突。</p><h3 id="混进来一点笔记"><a href="#混进来一点笔记" class="headerlink" title="混进来一点笔记"></a>混进来一点笔记</h3><p>static_cast主要管：有继承关系类的指针和内置数据类型的转换（和C的内置类型转换规则一致，可能改变底层的位，也可能不改变）。<br>reinterpret_cast主要管：所有指针(引用)之间的转换<br>在它们管理的交叉点处——有继承关系的指针的转换，处理方式有所不同。</p><p>哪怕在lua中被垃圾收集了，也依然可以在c++中获得到</p><p>是这样的，看到了<a href=""></a>-&gt;就回去补了下lambda，然后就看到了std::make_unique，我就寻思还是先把c++11整完了再说吧</p><h3 id="可变参数模板（变长）"><a href="#可变参数模板（变长）" class="headerlink" title="可变参数模板（变长）"></a>可变参数模板（变长）</h3><p>然后一头扎进这个叫可变参数模板的东西里<br>大概分成两部分，一部分是延伸而出的标准的「元组」的使用，另一部分就是可变参数模板自己的一部分的东西</p><p>分开讲，先讲可变参数模板自身：</p><h4 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template&lt;typename ... T&gt; </div><div class="line">void func(T ... args)//T叫模板参数包，args叫函数参数包</div><div class="line"></div><div class="line">template&lt;typename... a&gt; class Car &#123;&#125;;</div><div class="line">template&lt;typename... A&gt; class BMW : public Car&lt;A...&gt; &#123; &#125;;</div><div class="line">BMW&lt;int, char&gt; car;</div><div class="line">// A...称之为包扩展(pack extension)，包扩展是可以传递的。</div></pre></td></tr></table></figure><p>展开参数包可以通过递归或非递归实现，递归需要实现一个终止函数<br>逗号表达式展开<br>递归函数展开参数包是一种标准做法，也比较好理解，但也有一个缺点,就是必须要一个重载的递归终止函数，即必须要有一个同名的终止函数来终止递归，这样可能会感觉稍有不便。有没有一种更简单的方式呢？其实还有一种方法可以不通过递归方式来展开参数包，这种方式需要借助逗号表达式和初始化列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span>&#123;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">(Args... args)</span></span>&#123;</div><div class="line">   <span class="keyword">int</span> arr[] = &#123;(print(args), <span class="number">0</span>)...&#125;;</div><div class="line">&#125;</div><div class="line">expand(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</div><div class="line"><span class="comment">//用到数组的初始化列表，这个数组的目的纯粹是为了在数组构造的过程展开参数包。</span></div><div class="line"><span class="comment">//&#123;(printarg(args), 0)...&#125;将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )，</span></div><div class="line"><span class="comment">//最终会创建一个元素值都为0的数组int arr[sizeof...(Args)]。printarg便会处理参数包中每一个参数。</span></div><div class="line"></div><div class="line"><span class="comment">//支持lambda表达式</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">(<span class="keyword">const</span> F&amp; f, Args&amp;&amp;...args)</span> </span>&#123;<span class="comment">//这里用到了完美转发</span></div><div class="line">  <span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&#123;(f(<span class="built_in">std</span>::forward&lt; Args&gt;(args)),<span class="number">0</span>)...&#125;;</div><div class="line">&#125;</div><div class="line">expand([](<span class="keyword">int</span> i)&#123;<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;&#125;, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div></pre></td></tr></table></figure></p><p>唔，看起来你并没有看www（这里是几天之后发现自己根本没记住也没看懂这东西到底是怎么用的）<br>我们写一个，再常见不过的用法来增强一下记忆<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</div><div class="line"><span class="function">T <span class="title">f</span><span class="params">(Args&amp;&amp;...args)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> T&#123;<span class="built_in">std</span>::forward&lt;Args&gt;(args)...&#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> i = f&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</div><div class="line"><span class="keyword">auto</span> up = f&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">42</span>&#125;);</div></pre></td></tr></table></figure></p><hr><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p>c++11中的tuple（元组）。tuple看似简单，其实它是简约而不简单，可以说它是c++11中一个既简单又复杂的东东，关于它简单的一面是它很容易使用，复杂的一面是它内部隐藏了太多细节，要揭开它神秘的面纱时又比较困难。</p><p>　　tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。和c#中的tuple类似，但是比c#中的tuple强大得多。我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。</p><p>构造一个tuple<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>&gt;tp = make_tuple(sendPack,nSendSize); <span class="comment">//构造一个tuple</span></div><div class="line">这个tuple等价于一个结构体</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct</span> A</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span>* p;</div><div class="line">    <span class="keyword">int</span> len;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>用tuple<const char*,="" int="">tp就可以不用创建这个结构体了，而作用是一样的，是不是更简洁直观了。还有一种方法也可以创建元组，用std::tie，它会创建一个元组的左值引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> tp = <span class="keyword">return</span> <span class="built_in">std</span>::tie(<span class="number">1</span>, <span class="string">"aa"</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">//tp的类型实际是：</span></div><div class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>&amp;,<span class="built_in">string</span>&amp;, <span class="keyword">int</span>&amp;&gt;</div></pre></td></tr></table></figure></const></p><p>还有一种方法也可以获取元组的值，通过std::tie解包tuple<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x,y;</div><div class="line"><span class="built_in">string</span> a;</div><div class="line"><span class="built_in">std</span>::tie(x,a,y) = tp;</div></pre></td></tr></table></figure></p><p>通过tie解包后，tp中三个值会自动赋值给三个变量。</p><p>解包时，我们如果只想解某个位置的值时，可以用std::ignore占位符来表示不解某个位置的值。比如我们只想解第三个值时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::tie(<span class="built_in">std</span>::ignore,<span class="built_in">std</span>::ignore,y) = tp; <span class="comment">//只解第三个值了</span></div></pre></td></tr></table></figure></p><p>还有一个创建右值的引用元组方法：forward_as_tuple。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m;</div><div class="line">m.emplace(<span class="built_in">std</span>::forward_as_tuple(<span class="number">10</span>, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="number">20</span>, <span class="string">'a'</span>)));</div></pre></td></tr></table></figure></p><p>它实际上创建了一个类似于std::tuple<int&&, std::string&&="">类型的tuple。</int&&,></p><p>我们还可以通过tuple_cat连接多个tuple<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">float</span>&gt; t1(<span class="number">10</span>, <span class="string">"Test"</span>, <span class="number">3.14</span>);</div><div class="line"><span class="keyword">int</span> n = <span class="number">7</span>;</div><div class="line"><span class="keyword">auto</span> t2 = <span class="built_in">std</span>::tuple_cat(t1, <span class="built_in">std</span>::make_pair(<span class="string">"Foo"</span>, <span class="string">"bar"</span>), t1, <span class="built_in">std</span>::tie(n));</div><div class="line">n = <span class="number">10</span>;</div><div class="line">print(t2);</div><div class="line"><span class="comment">//(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 10)</span></div></pre></td></tr></table></figure></p><p>通过std::tuple_element获取元素类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::tuple_element&lt;<span class="number">0</span>,Tuple&gt;::type first = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt; (mytuple);</div></pre></td></tr></table></figure></p><p>获取tuple中元素的个数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tuple t;</div><div class="line"><span class="keyword">int</span> size = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(t))&gt;::value;</div></pre></td></tr></table></figure></p><p>遍历tuple中的每个元素<br>　　因为tuple的参数是变长的，也没有for_each函数，如果我们想遍历tuple中的每个元素，需要自己写代码实现。比如我要打印tuple中的每个元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Tuple, <span class="built_in">std</span>::<span class="keyword">size_t</span> N&gt;</div><div class="line"><span class="keyword">struct</span> TuplePrinter &#123;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Tuple&amp; t)</span></span></div><div class="line">    &#123;</div><div class="line">        TuplePrinter&lt;Tuple, N - <span class="number">1</span>&gt;::print(t);</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;N - <span class="number">1</span>&gt;(t);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Tuple&gt;</div><div class="line"><span class="keyword">struct</span> TuplePrinter&lt;Tuple, <span class="number">1</span>&gt;&#123;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Tuple&amp; t)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(t);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTuple</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</div><div class="line">    TuplePrinter&lt;<span class="keyword">decltype</span>(t), <span class="keyword">sizeof</span>...(Args)&gt;::print(t);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">")\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>根据tuple元素值获取其对应的索引位置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> detail</div><div class="line">&#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line">    <span class="keyword">struct</span> find_index</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="built_in">std</span>::tuple&lt;Args...&gt; <span class="keyword">const</span>&amp; t, T&amp;&amp; val)</span></span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> (<span class="built_in">std</span>::get&lt;I - <span class="number">1</span>&gt;(t) == val) ? I - <span class="number">1</span> :</div><div class="line">                find_index&lt;I - <span class="number">1</span>, T, Args...&gt;::call(t, <span class="built_in">std</span>::forward&lt;T&gt;(val));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line">    <span class="keyword">struct</span> find_index&lt;<span class="number">0</span>, T, Args...&gt;</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="built_in">std</span>::tuple&lt;Args...&gt; <span class="keyword">const</span>&amp; t, T&amp;&amp; val)</span></span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> (<span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(t) == val) ? <span class="number">0</span> : <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="built_in">std</span>::tuple&lt;Args...&gt; <span class="keyword">const</span>&amp; t, T&amp;&amp; val)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> detail::find_index&lt;<span class="number">0</span>, <span class="keyword">sizeof</span>...(Args) - <span class="number">1</span>, T, Args...&gt;::</div><div class="line">           call(t, <span class="built_in">std</span>::forward&lt;T&gt;(val));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; a(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(a, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// Prints 2</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(a, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// Prints 0</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(a, <span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// Prints -1 (not found)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>展开tuple，并将tuple元素作为函数的参数。这样就可以根据需要对tuple元素进行处理了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">#include &lt;tuple&gt;</div><div class="line">#include &lt;type_traits&gt;</div><div class="line">#include &lt;utility&gt;</div><div class="line"></div><div class="line">template&lt;size_t N&gt;</div><div class="line">struct Apply &#123;</div><div class="line">    template&lt;typename F, typename T, typename... A&gt;</div><div class="line">    static inline auto apply(F &amp;&amp; f, T &amp;&amp; t, A &amp;&amp;... a)-&gt; decltype(Apply&lt;N-1&gt;::apply(::std::forward&lt;F&gt;(f), ::std::forward&lt;T&gt;(t),::std::get&lt;N-1&gt;(::std::forward&lt;T&gt;(t)), ::std::forward&lt;A&gt;(a)...))&#123;</div><div class="line">        return Apply&lt;N-1&gt;::apply(::std::forward&lt;F&gt;(f), ::std::forward&lt;T&gt;(t),::std::get&lt;N-1&gt;(::std::forward&lt;T&gt;(t)), ::std::forward&lt;A&gt;(a)...);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template&lt;&gt;</div><div class="line">struct Apply&lt;0&gt; &#123;</div><div class="line">    template&lt;typename F, typename T, typename... A&gt;</div><div class="line">    static inline auto apply(F &amp;&amp; f, T &amp;&amp;, A &amp;&amp;... a)-&gt; decltype(::std::forward&lt;F&gt;(f) (::std::forward&lt;A&gt;(a)...))&#123;</div><div class="line">        return ::std::forward&lt;F&gt;(f)(::std::forward&lt;A&gt; (a)...);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template&lt;typename F, typename T&gt;</div><div class="line">inline auto apply(F &amp;&amp; f, T &amp;&amp; t)-&gt; decltype(Apply&lt; ::std::tuple_size&lt;typename ::std::decay&lt;T&gt;::type&gt;::value&gt;::apply(::std::forward&lt;F&gt;(f), ::std::forward&lt;T&gt;(t)))</div><div class="line">&#123;</div><div class="line">    return Apply&lt; ::std::tuple_size&lt;typename ::std::decay&lt;T&gt;::type&gt;::value&gt;::apply(::std::forward&lt;F&gt;(f), ::std::forward&lt;T&gt;(t));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void one(int i, double d)</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; "function one(" &lt;&lt; i &lt;&lt; ", " &lt;&lt; d &lt;&lt; ");\n";</div><div class="line">&#125;</div><div class="line">int two(int i)</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; "function two(" &lt;&lt; i &lt;&lt; ");\n";</div><div class="line">    return i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试代码</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::tuple&lt;int, double&gt; tup(23, 4.5);</div><div class="line">    apply(one, tup);</div><div class="line"></div><div class="line">    int d = apply(two, std::make_tuple(2));</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>有些困难的代码，以后看吧。但是有助于理解变长模板怎么用，看的时候稍微注意一下。</p><p>tuple和vector比较：<br>vector只能容纳同一种类型的数据，tuple可以容纳任意类型的数据；</p><p>tuple和variant比较：<br>二者都可以容纳不同类型的数据，但是variant的类型个数是固定的，而tuple的类型个数不是固定的，是变长的，更为强大。<br>c++17好像对variant有一波改造，我们到时候见。</p><hr><p>I expect lambdas to be a bit overused initially (like all powerful mechanisms)</p><hr><p>新算法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all_of</span><span class="params">(Iter first, Iter last, Pred pred)</span></span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">any_of</span><span class="params">(Iter first, Iter last, Pred pred)</span></span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">none_of</span><span class="params">(Iter first, Iter last, Pred pred)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Iter <span class="title">find_if_not</span><span class="params">(Iter first, Iter last, Pred pred)</span></span>;</div><div class="line"></div><div class="line"><span class="function">OutIter <span class="title">copy_if</span><span class="params">(InIter first, InIter last,</span></span></div><div class="line">        OutIter result, Pred pred);</div><div class="line"><span class="function">OutIter <span class="title">copy_n</span><span class="params">(InIter first, InIter::difference_type n,</span></span></div><div class="line">        OutIter result);</div><div class="line"></div><div class="line"><span class="function">OutIter <span class="title">move</span><span class="params">(InIter first, InIter last, OutIter result)</span></span>;</div><div class="line"><span class="function">OutIter <span class="title">move_backward</span><span class="params">(InIter first, InIter last, OutIter result)</span></span>;</div><div class="line"></div><div class="line">pair&lt;OutIter1, OutIter2&gt; partition_copy(InIter first, InIter last,</div><div class="line">        OutIter1 out_true, OutIter2 out_false, Pred pred);</div><div class="line"><span class="function">Iter <span class="title">partition_point</span><span class="params">(Iter first, Iter last, Pred pred)</span></span>;</div><div class="line"></div><div class="line"><span class="function">RAIter <span class="title">partial_sort_copy</span><span class="params">(InIter first, InIter last,</span></span></div><div class="line">        RAIter result_first, RAIter result_last);</div><div class="line"><span class="function">RAIter <span class="title">partial_sort_copy</span><span class="params">(InIter first, InIter last,</span></span></div><div class="line">        RAIter result_first, RAIter result_last, Compare comp);</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_sorted</span><span class="params">(Iter first, Iter last)</span></span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_sorted</span><span class="params">(Iter first, Iter last, Compare comp)</span></span>;</div><div class="line"><span class="function">Iter <span class="title">is_sorted_until</span><span class="params">(Iter first, Iter last)</span></span>;</div><div class="line"><span class="function">Iter <span class="title">is_sorted_until</span><span class="params">(Iter first, Iter last, Compare comp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">(Iter first, Iter last)</span></span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">(Iter first, Iter last, Compare comp)</span></span>;</div><div class="line"><span class="function">Iter <span class="title">is_heap_until</span><span class="params">(Iter first, Iter last)</span></span>;</div><div class="line"><span class="function">Iter <span class="title">is_heap_until</span><span class="params">(Iter first, Iter last, Compare comp)</span></span>;</div><div class="line"></div><div class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="built_in">initializer_list</span>&lt;T&gt; t)</span></span>;</div><div class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="built_in">initializer_list</span>&lt;T&gt; t, Compare comp)</span></span>;</div><div class="line"><span class="function">T <span class="title">max</span><span class="params">(<span class="built_in">initializer_list</span>&lt;T&gt; t)</span></span>;</div><div class="line"><span class="function">T <span class="title">max</span><span class="params">(<span class="built_in">initializer_list</span>&lt;T&gt; t, Compare comp)</span></span>;</div><div class="line">pair&lt;<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;&gt; minmax(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b);</div><div class="line">pair&lt;<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;&gt; minmax(<span class="keyword">const</span> T&amp; a,</div><div class="line">        <span class="keyword">const</span> T&amp; b,</div><div class="line">         Compare comp);</div><div class="line">pair&lt;<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;&gt; minmax(<span class="built_in">initializer_list</span>&lt;T&gt; t);</div><div class="line">pair&lt;<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;&gt; minmax(<span class="built_in">initializer_list</span>&lt;T&gt; t,</div><div class="line">         Compare comp);</div><div class="line">pair&lt;Iter, Iter&gt; minmax_element(Iter first, Iter last);</div><div class="line">pair&lt;Iter, Iter&gt; minmax_element(Iter first, Iter last, Compare comp);</div><div class="line"></div><div class="line"><span class="comment">// 填充[first,last]范围内的每一个元素</span></div><div class="line"><span class="comment">// 第一个元素为value，第二个为++value，以此类ui</span></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="comment">// *(d_first)   = value;</span></div><div class="line"><span class="comment">// *(d_first+1) = ++value;</span></div><div class="line"><span class="comment">// *(d_first+2) = ++value;</span></div><div class="line"><span class="comment">// *(d_first+3) = ++value; ...</span></div><div class="line"><span class="comment">// 注意函数名，是iota而不是itoa哦</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">iota</span><span class="params">(Iter first, Iter last, T value)</span></span>;</div></pre></td></tr></table></figure></p><p>move操作<br>lambda操作<br>initialize lists操作</p><hr><h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h3><p>std::array是一个支持随机访问且大小（size）固定的容器（译注：可以认为是一个紧缩版的vector吧）。它有如下特点：<br>不预留多余空间，只分配必须空间（译注：size() == capacity()）。<br>可以使用初始化表（initializer list）的方式进行初始化。<br>保存了自己的size信息。<br>不支持隐式指针类型转换。<br>换句话说，可以认为它是一个很不错的内建数组类型。<br>array非常适合在嵌入式系统（和有类似限制/性能敏感/安全关键系统等）中使用。它提供了序列型容器该有的大部分通用函数（和vector很像）</p><hr><p>具有作用域的内存分配器<br>没看懂，鸽</p><hr><h3 id="一点关于智能指针的介绍"><a href="#一点关于智能指针的介绍" class="headerlink" title="一点关于智能指针的介绍"></a>一点关于智能指针的介绍</h3><p>unique_ptr十分依赖于右值引用和移动语义。<br>unique_ptr（定义在中）提供了一种严格的语义上的所有权<br>拥有它所指向的对象<br>无法进行复制构造，也无法进行复制赋值操作（译注：也就是对其无法进行复制，我们无法得到指向同一个对象的两个unique_ptr），但是可以进行移动构造和移动赋值操作<br>保存指向某个对象的指针，当它本身被删除释放的时候（例如，离开某个作用域），会使用给定的删除器（deleter）删除释放它指向的对象，<br>unique_ptr的使用能够包括：<br>为动态申请的内存提供异常安全<br>将动态申请内存的所有权传递给某个函数<br>从某个函数返回动态申请内存的所有权<br>在容器中保存指针</p><p>另外，不要不加思考地把指针替换为shared_ptr来防止内存泄露。shared_ptr并不是万能的，而且使用它们的话也是需要一定的开销的：<br>环状的链式结构shared_ptr将会导致内存泄露（你需要一些逻辑上的复杂化来打破这个环。比如使用weak_ptr）。<br>共享拥有权的对象一般比限定作用域的对象生存更久。从而将导致更高的平均资源使用时间。<br>在多线程环境中使用共享指针的代价非常大。这是因为你需要避免关于引用计数的数据竞争。<br>共享对象的析构器不会在预期的时间执行。<br>与非共享对象相比，在更新任何共享对象时，更容易犯算法或者逻辑上的错误。<br>shared_ptr用于表示共享拥有权。然而共享拥有权并不是我的初衷。在我看来，一个更好的办法是为对象指明拥有者并且为对象定义一个可以预测的生存范围。</p><p>将weak_ptr看成是指向具有下列特征的对象的指针更好一些。<br>只有当对象存在的时候，你才需要对其进行访问<br>并且它可能被其他人删除释放<br>并且在最后一次使用之后调用其析构函数（通常用于释放那些不具名的内存(anon-memory)资源<br>（译注：weak_ptr可以保存一个“弱引用”，指向一个已经用shared_ptr进行管理的对象。为了访问这个对象，一个weak_ptr可以通过shared_ptr的构造函数或者是weak_ptr的成员函数lock()转化为一个shared_ptr。当最后一个指向这个对象的shared_ptr退出其生命周期并且这个对象被释放之后，将无法从指向这个对象的weak_ptr获得一个shared_ptr指针，shared_ptr的构造函数会抛出异常，而weak_ptr::lock也会返回一个空指针。）</p><h3 id="cpp-11-faq结束啦"><a href="#cpp-11-faq结束啦" class="headerlink" title="cpp-11-faq结束啦"></a>cpp-11-faq结束啦</h3><hr><p>智能指针我慢慢补，然后就是多线程的诸类事项。<br>先看这本《深入理解C++11：C++11新特性解析与应用》</p><hr><p>静态断言可以避免一些运行时才出错的问题，还是很有用的，比如enum的枚举。<br>但是记住，只能是编译期就能进行判断的东西。</p><hr><p>下面就是新书深入理解c++11了，各种补充细节吧可以说是。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大量POD预警，右值引用等&lt;br&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://oodtoodt.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="http://oodtoodt.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://oodtoodt.github.io/tags/c-11/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
  </entry>
  
  <entry>
    <title>cpp-11笔记_1</title>
    <link href="http://oodtoodt.github.io/2020/01/13/cpp-11-14-17%E7%AC%94%E8%AE%B0/cpp-11%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://oodtoodt.github.io/2020/01/13/cpp-11-14-17%E7%AC%94%E8%AE%B0/cpp-11%E7%AC%94%E8%AE%B0-1/</id>
    <published>2020-01-13T09:33:38.000Z</published>
    <updated>2020-01-14T09:19:38.542Z</updated>
    
    <content type="html"><![CDATA[<p>c++11的东西有点多，我到现在还欠着几项东西没学<br>这篇包含lambda、enum、constexpr、explicit等，详见目录<br><a id="more"></a></p><hr><h1 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h1><p>好了我要动手c++11了<br>主要是剩下一部分sol都比较深入了，我现在看不进去……（？）下午看看睡一觉会不会好一点</p><h2 id="先放一个小故事"><a href="#先放一个小故事" class="headerlink" title="先放一个小故事"></a>先放一个小故事</h2><p>看到一个知乎回答，我觉得让我知道了移动语义的价值所在：<br>普通解答：打开冰箱门，取出大象，关上冰箱门，打开另一台冰箱门，放进大象，关上冰箱门。<br>2B解答：在第二个冰箱中启动量子复制系统，克隆一只完全相同的大象，然后启动高能激光将第一个冰箱内的大象气化消失。  </p><p>注意到这里我们需要移动的是一头大象。那么这个代价是相当高昂的。当然代价是其次的，我们要从一个更高的角度理解这个问题，就是一种正常的语义理解，或者说某种功能要求——移动。（哲学！</p><p>不严格的来说，左值对应变量的存储位置，而右值对应变量的值本身不严格的来说，左值对应变量的存储位置，而右值对应变量的值本身</p><p><a href="http://zh.wikipedia.org/zh-cn/C++11" target="_blank" rel="external">http://zh.wikipedia.org/zh-cn/C++11</a></p><p>顺便说个笑话，我看到–bullet这个东西在c++里出现，第一反应当然是lua注释？不在script字符串域里啊。那就是c++11新特性了？<br>等等？这个++怎么回事。<br>卧槽。</p><hr><h2 id="cpp-11-faq阅读笔记"><a href="#cpp-11-faq阅读笔记" class="headerlink" title="cpp 11 faq阅读笔记"></a>cpp 11 faq阅读笔记</h2><h3 id="auto血强。"><a href="#auto血强。" class="headerlink" title="auto血强。"></a>auto血强。</h3><h3 id="Attributes（属性）"><a href="#Attributes（属性）" class="headerlink" title="Attributes（属性）"></a>Attributes（属性）</h3><p>c++11里没啥东西，但是要认识[[]]这东西。不知道以后会不会有更多的开放的东西加进来。（noreturn这种写法确实很爽（？</p><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>?我没看懂这个C99特性可还行。</p><p>枚举类：我竟然对这东西没印象、当新东西学了（不是没印象，是根本没见过）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//enum Alert&#123;green,yellow,election,red&#125; //传统枚举  </span></div><div class="line"><span class="keyword">enum</span> <span class="keyword">class</span> Color&#123;red,blue&#125;;  </div><div class="line"><span class="keyword">int</span> a = Alert::red;</div></pre></td></tr></table></figure></p><p>具有传统枚举的功能，也有了一些类的特点。<br>注意如果没有class原有的枚举也是存在的。好处是不会隐式转换成int<br>枚举等价于常量<br>这东西可以用在switch语句里。<br>用了一下，不是那么会用。。具体就是说除了强制转换无法给枚举类型赋其他值，然后其他操作基本等同常量，注意可见是整个域内的，所以有了枚举类这种东西，默认int，枚举类可以前向声明类型</p><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>constexpr可以认为是强制要求表达式等在编译时期计算其结果值，并能保证表达式在语义上是类型安全的，比较#define的文本替换而无检查能力，以及比较const表达对接口的写权限控制及优化而言，constexpr修饰的对象强制要求其初始化表达式能够在编译器完成计算，constexpr 将编译期常量概念延伸至括用户自定义常量以及常量函数，其值的不可修改性由编译器保证，因而constexpr 表达式是一般化的，受保证的常量表达式。<br>注意constexpr如果要计算某些值必须由右值或者常量组成。<br>关于constexpr函数：<br>constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法有其他函数类似，不过要遵循几项约定：函数的返回值类型及所以形参的类型都是字面值类型，而且函数体中必须有且只有一条return语句。为了能在编译过程中随时展开，constexpr函数被隐式指定地指定为内联函数。<br>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名以及using声明。<br>允许constexpr函数的返回值并非一个常量：<br>constexpr int scale(int cnt){return 5<em>cnt;}//如果arg是常量表达式，则scale（arg）也是常量表达式<br>　　当scale的实参是常量表达式时，它的返回值也是常量表达式；反之则不然。如果我们用一个非常量表达式调用scale函数，比如int类型的对象i，则返回值是一个非常量表达式。当把scale函数用在需要常量表达式的上下文时，由编译器负责检查函数的结果是否符合要求。如果结果恰好不是常量表达式，编译器将发出错误信息。constexpr函数不一定返回常量表达式。——这里指的是用在模板类中的情况，可能会忽略constexpr<br><em>*注意这东西…后面会反复提到，感觉地位还是很高的。c++14添了新属性，c++17添了新属性，从每次出现的新特性次数来说感觉跟auto差不多了</em></em></p><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype – 推断表达式的数据类型,auto的某种机制，如果只需要类型可以用一下，不然直接auto就好啦<br>然而并没有那么简单。很多时候只需要类型，尤其是在传递参数的时候，特别点名一些标准库</p><h3 id="delete-default"><a href="#delete-default" class="headerlink" title="delete/default"></a>delete/default</h3><p>有了default关键字，我们可以定义所有行为哪怕没有行为了，对于阅读者和编译器都很好。<br>注意，default可以用在任何的默认函数中，delete则可以用于修饰任何函数。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>委托构造函数：在一个构造函数中调用另外一个构造函数，这就是委托的意味，不同的构造函数自己负责处理自己的不同情况，把最基本的构造工作委托给某个基础构造函数完成，实现分工协作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> X(int x) &#123; if (0&lt;x &amp;&amp; x&lt;=max) a=x; else throw bad_X(x); &#125;</div><div class="line">// 构造函数X()调用构造函数X(int x)</div><div class="line">X() :X&#123;42&#125; &#123; &#125;</div><div class="line">// 构造函数X(string s)调用构造函数X(int x)</div><div class="line">X(string s) :X&#123;lexical_cast&lt;int&gt;(s)&#125; &#123; &#125;</div></pre></td></tr></table></figure></p><h3 id="欠着"><a href="#欠着" class="headerlink" title="欠着"></a>欠着</h3><p>我发现官方文档（？其实我不知道微软这篇是不是官方的）里给出了分类，这些内容都是并发中的：</p><p>atomic_operations原子操作。这里为多线程操作提供了一套原子操作，我们之后理解了多线程和各种锁之后回来再说。<br>current_exception()捕捉当前的异常，返回一个异常智能指针<br>Reworded sequence points<br>String compare and exchange<br>Bidirectional fences<br>Memory model<br>data-dependency ordering<br>Data-dependency ordering:function annotation<br>quick_exit<br>Atomics in signal handlers<br>Thread-local storage<br>Magic statics</p><p>线程本地化存储</p><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>noexcept – 阻止异常的传播与扩散<br>如果一个经过noexcept修饰的函数抛出异常（异常会尝试逃出这个函数（？）），程序会通过调用terminate()来结束执行，异常不会抛出或者不会被接受并处理<br>extern “C” double sqrt(double) noexcept;//永远不会抛出异常</p><p>关于noexcept<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line">void do_f(vector&lt;T&gt;&amp; v) noexcept(noexcept(f(v.at(0)))) // can throw if f(v.at(0)) can</div><div class="line">&#123;</div><div class="line">    for(int i; i&lt;v.size(); ++i)</div><div class="line">        v.at(i) = f(v.at(i));</div><div class="line">&#125;</div><div class="line">//这里的第一个noexcept()是修饰符，第二个是运算符，判断f(v.at(0))是否会抛出异常。</div></pre></td></tr></table></figure></p><p>若 expression 含有至少一个下列潜在求值的构造则结果为 false ：<br>1、调用无不抛出异常指定的任意类型函数，除非它是常量表达式。<br>2、throw 表达式。<br>3、目标类型是引用类型，且转换时需要运行时检查的 dynamic_cast 表达式<br>4、参数类型是多态类类型的 typeid 表达式<br>5、所有其他情况下结果是 true 。<br>还是单纯的理解成：如果v.at(0)不发生异常，那么do_f()一定不发生异常  </p><h4 id="以下情形鼓励使用noexcept："><a href="#以下情形鼓励使用noexcept：" class="headerlink" title="以下情形鼓励使用noexcept："></a>以下情形鼓励使用noexcept：</h4><p>移动构造函数（move constructor）<br>移动分配函数（move assignment）<br>析构函数（destructor）。这里提一句，在新版本的编译器中，析构函数是默认加上关键字noexcept的。下面代码可以检测编译器是否给析构函数加上关键字noexcept。<br>叶子函数（Leaf Function）。叶子函数是指在函数内部不分配栈空间，也不调用其它函数，也不存储非易失性寄存器，也不处理异常。</p><h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><h4 id="先来历史，c-98："><a href="#先来历史，c-98：" class="headerlink" title="先来历史，c++98："></a>先来历史，c++98：</h4><p>这里是C++98的特性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> E &#123; <span class="function"><span class="keyword">explicit</span> <span class="title">E</span><span class="params">(<span class="keyword">int</span>)</span></span>; &#125;;    <span class="comment">// 显式构造函数</span></div><div class="line"><span class="function">E <span class="title">e1</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">// ok</span></div><div class="line">E e2 = <span class="number">1</span>;    <span class="comment">// 错误（但是常常会让人感到意外——这怎么会错呢？）</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(E)</span></span>;</div><div class="line"><span class="comment">// 该处会产生编译错误（而非编译通过），以避免因隐式类型转换而得到莫名其妙的结果。</span></div><div class="line"><span class="comment">// 例如std::vector::vector(int size), 该构造函数在标准库中定义为显式类型转换，</span></div><div class="line"><span class="comment">// （译注：以避免程序员为了初始化一个只含有一个元素10的数组而写出如下代码:</span></div><div class="line"><span class="comment">//    vector&lt;int&gt; vec = 10; </span></div><div class="line"><span class="comment">//   而实际上该代码的含义却是定义一个初始包含10个元素的数组）</span></div><div class="line">f(<span class="number">1</span>);</div></pre></td></tr></table></figure></p><h4 id="c-11中的explicit"><a href="#c-11中的explicit" class="headerlink" title="c++11中的explicit"></a>c++11中的explicit</h4><p>C++98中无法定义”显式转换操作符”来完全禁止某个类相关的隐式转换（因为除此之外鲜有用武之地）。C++11则高瞻远瞩，添加了这个特性<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> S &#123; S(<span class="keyword">int</span>) &#123; &#125; &#125;;</div><div class="line"><span class="keyword">struct</span> SS &#123;</div><div class="line">    <span class="keyword">int</span> m;</div><div class="line">    SS(<span class="keyword">int</span> x) :m(x) &#123; &#125;</div><div class="line">    <span class="comment">// 因为结构体S中没有定义构造函数S(SS)</span></div><div class="line">    <span class="comment">// 无法将SS转换为S，所以只好在SS中定义一个返回S的转换操作符，</span></div><div class="line">    <span class="comment">// 将自己转换为S。</span></div><div class="line">    <span class="comment">// 转换动作，可以由目标类型S提供，也可以由源类型SS提供。）</span></div><div class="line">     <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">S</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> S(m); &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function">SS <span class="title">ss</span><span class="params">(<span class="number">1</span>)</span></span>;    <span class="comment">// ok; 默认构造函数</span></div><div class="line">S s1 = ss;    <span class="comment">// 错误; 拷贝构造函数不能使用显式转换</span></div><div class="line"><span class="function">S <span class="title">s2</span><span class="params">(ss)</span></span>;    <span class="comment">// ok; 直接构造函数可以使用显式转换</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(S)</span></span>;</div><div class="line">f(ss);        <span class="comment">// 错误; 从SS向S的转换必须是显式的.</span></div><div class="line"><span class="comment">// 译注: 强制类型转换也可使用显式转换，例如</span></div><div class="line"><span class="comment">// S s3 = static_cast&lt;S&gt;(ss);</span></div></pre></td></tr></table></figure></p><p>explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的（当那些参数没有默认值的时候，有并且只传1个那就有效了)<br>发生隐式转换，除非有心利用，隐式转换常常带来程序逻辑的错误，而且这种错误一旦发生是很难察觉的。<br>再来一例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> String&#123;</div><div class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</div><div class="line">      String(<span class="keyword">const</span> <span class="keyword">char</span> *p);</div><div class="line">&#125;;</div><div class="line">String s1 = <span class="string">'a'</span>; <span class="comment">//错误：不能做隐式char-&gt;String转换</span></div><div class="line"><span class="function">String <span class="title">s2</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">//可以：调用explicit String(int n);</span></div><div class="line">String s3 = String(<span class="number">10</span>);<span class="comment">//可以：调用explicit String(int n);再调用默认的复制构造函数</span></div><div class="line">String s4 = <span class="string">"Brian"</span>; <span class="comment">//可以：隐式转换调用String(const char *p);再调用默认的复制构造函数</span></div><div class="line"><span class="function">String <span class="title">s5</span><span class="params">(<span class="string">"Fawlty"</span>)</span></span>; <span class="comment">//可以：正常调用String(const char *p);</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(String)</span></span>;</div><div class="line">­</div><div class="line"><span class="function">String <span class="title">g</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    f(<span class="number">10</span>); <span class="comment">//错误：不能做隐式int-&gt;String转换</span></div><div class="line">    f(<span class="string">"Arthur"</span>); <span class="comment">//可以：隐式转换，等价于f(String("Arthur"));</span></div><div class="line">    <span class="keyword">return</span> <span class="number">10</span>; <span class="comment">//同上</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CxString  <span class="comment">// 使用关键字explicit的类声明, 显式转换  </span></div><div class="line">&#123;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="keyword">char</span> *_pstr;  </div><div class="line">    <span class="keyword">int</span> _size;  </div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CxString</span><span class="params">(<span class="keyword">int</span> size)</span>  </span></div><div class="line">    &#123;  </div><div class="line">        _size = size;  </div><div class="line">        <span class="comment">// 代码同上, 省略...  </span></div><div class="line">    &#125;  </div><div class="line">    CxString(<span class="keyword">const</span> <span class="keyword">char</span> *p)  </div><div class="line">    &#123;  </div><div class="line">        <span class="comment">// 代码同上, 省略...  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line">    <span class="comment">// 下面是调用:  </span></div><div class="line">  </div><div class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">24</span>)</span></span>;     <span class="comment">// 这样是OK的  </span></div><div class="line">    CxString string2 = <span class="number">10</span>;    <span class="comment">// 这样是不行的, 因为explicit关键字取消了隐式转换 （原来可以）</span></div><div class="line">    CxString string3;         <span class="comment">// 这样是不行的, 因为没有默认构造函数  </span></div><div class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">"aaaa"</span>)</span></span>; <span class="comment">// 这样是OK的  </span></div><div class="line">    CxString string5 = <span class="string">"bbb"</span>; <span class="comment">// 这样也是OK的, 调用的是CxString(const char *p)  </span></div><div class="line">    CxString string6 = <span class="string">'c'</span>;   <span class="comment">// 这样是不行的, 其实调用的是CxString(int size), 且size等于'c'的ascii码, 但explicit关键字取消了隐式转换  （原来可以）</span></div><div class="line">    string1 = <span class="number">2</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换  </span></div><div class="line">    string2 = <span class="number">3</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换 (原来可以，分配3字节)</span></div><div class="line">    string3 = string1;        <span class="comment">// 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符"="的重载 (原来是可以的，但是如果析构free掉_pstr可能出错)</span></div></pre></td></tr></table></figure><h3 id="扩展整型"><a href="#扩展整型" class="headerlink" title="扩展整型"></a>扩展整型</h3><p>在实际的编程中，由于这5种基本的整型适用性有限，所以有时编译器出于需要，也会自行扩展一些整型。在C++11中，标准对这样的扩展做出了一些规定。具体地讲，除了标准整型（standard integer type）之外，C++11标准允许编译器扩展自有的所谓扩展整型（extended integer type）。这些扩展整型的长度（占用内存的位数）可以比最长的标准整型（long long int，通常是一个64位长度的数据）还长，也可以介于两个标准整数的位数之间。比如在128位的架构上，编译器可以定义一个扩展整型来对应128位的的整数；而在一些嵌入式平台上，也可能需要扩展出48位的整型；不过C++11标准并没有对扩展出的类型的名称有任何的规定或建议，只是对扩展整型的使用规则做出了一定的限制。</p><p>1.长度越高的整形等级越高。<br>2.长度相同的情况下，标准等级高于扩展类型<br>3.相同大小的有符号和无符号等级相同</p><h3 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h3><h4 id="先来历史"><a href="#先来历史" class="headerlink" title="先来历史"></a>先来历史</h4><p>模板的局限性:<br>不能for all。即不能适用于所有的类型。<br>一种方案是，重载运算符+、=、&lt;等等，另一种方案是，为特定类型提供具体化的模板定义。<br>c++98中提供了这样的方法：<br>对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。<br>显式具体化的原型和定义应以template&lt;&gt;开头，并通过名称来指出类型。<br>具体化优先于常规模板，而非模板函数优先于具体化和常规模板。</p><blockquote><p>记住，在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例(instantiation)。例如，上面代码中，函数调用Swap(i, j)导致编译器生成Swap()的一个实例，该实例使用int类型。模板并非函数定义，但使用int的模板实例是函数定义。这种实例化方式被称为隐式实例化(implict instantiation)，因为编译器之所以知道需要进行定义，是由于程序调用Swap()函数时提供了int参数。<br>最初，编译器只能通过隐式实例化， 来使用模板生成函数定义。但现在C++还允许显式实例化(explici instantiation)。这意味着可以直接命令编译器创建特定的实例，如Swap<int>()。<br>其语法是，声明所需的种类——用&lt;&gt;符号指示类型，并在声明前加上关键字template:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> <span class="keyword">void</span> Swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> , <span class="keyword">int</span>);<span class="comment">//explicit instantiation</span></div></pre></td></tr></table></figure></int></p></blockquote><p>实现了这种特性的编译器看到上述声明后，将使用Swap()模板生成一个使用int类型的实例。也就是说，该声明的意思是”使用Swap()模板生成int类型的函数定义。“<br>与显式实例化不同的是，显式具体化使用下面两个等价的声明之一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> Swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> &amp;, <span class="keyword">int</span> &amp;);<span class="comment">//explicit specialization</span></div><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;, <span class="keyword">int</span> &amp;)</span></span>;<span class="comment">//explicit specialization</span></div></pre></td></tr></table></figure></p><p>区别在于，这些声明的意思是“不要使用Swap()模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义。”这些原型必须有自己的函数定义。显式具体化声明在关键字template后包含&lt;&gt;，而显式实例化没有。<br>警告：试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化将出错。<br>注意必须要给出具体化的定义<br>还可通过在程序中使用函数来创建显式实例化。</p><h4 id="为什么要显式实例化？"><a href="#为什么要显式实例化？" class="headerlink" title="为什么要显式实例化？"></a>为什么要显式实例化？</h4><pre><code>主要是提高效率，当显式实例化模板时，在使用模板之前，编译器根据显式实例化指定的类型生成模板实例然而通常又有一些特殊的情况，不能直接使用泛型模板展开实现，这时就需要针对某个特殊的类型或者是某一类特殊的类型，而实现一个特例模板————即模板特化当T如果为 一个 struct类型的，它的交换就无法进行，所以我们针对这种特殊的情形，我们专门写了一个函数，只有当T为 这种struct类型时候，才会调用这个特化的函数</code></pre><p>(具体化)</p><h4 id="铺垫结束，c-11："><a href="#铺垫结束，c-11：" class="headerlink" title="铺垫结束，c++11："></a>铺垫结束，c++11：</h4><p>c++11中，为了这种特性添加了外部(extern)模板声明<br>为了去除重复的不同代码的编译和链接可以使得实例化去冗余化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">void</span> fun&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>);</div></pre></td></tr></table></figure></p><h3 id="序列for！"><a href="#序列for！" class="headerlink" title="序列for！"></a>序列for！</h3><p>只要定义了begin()和end()，就可以<br>for (auto x : v) cout&lt;&lt;x&lt;&lt;’n’;<br>for (auto&amp; x : v) ++x;<br>超级好用的属性</p><h3 id="返回值类型后置："><a href="#返回值类型后置：" class="headerlink" title="返回值类型后置："></a>返回值类型后置：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;</div><div class="line">??? mul(T x, U y)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> x*y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>是不能直接用x和y来推断的，因为x和y不在作用域内。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;class T, class U&gt;</div><div class="line">auto mul(T x, U y) -&gt; decltype(x*y)</div><div class="line">&#123;</div><div class="line">    return x*y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是最初并不是用于模板和返回值类型推导的，它实际是用于解决作用域问题的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> List &#123;</div><div class="line">    <span class="keyword">struct</span> Link &#123; <span class="comment">/* ... */</span> &#125;;</div><div class="line">    <span class="function">Link* <span class="title">erase</span><span class="params">(Link* p)</span></span>;   <span class="comment">// 移除p并返回p之前的链接</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">List::Link* List::erase(Link* p) &#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure></p><p>第一个List::是必需的，这仅是因为List的作用域直到第二个List::才有效。更好的表示方式是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> List::erase(Link* p) -&gt; Link* &#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure></p><h3 id="类成员的内部初始化"><a href="#类成员的内部初始化" class="headerlink" title="类成员的内部初始化"></a>类成员的内部初始化</h3><p>看一眼例子就懂了。<br>C++11的基本思想是，允许非静态（non-static）数据成员在其声明处（在其所属类内部）进行初始化。这样，在运行时，需要初始值时构造函数可以使用这个初始值。考虑下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> a = <span class="number">7</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这等同于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    A() : a(<span class="number">7</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>单纯从代码来看，这样只是省去了一些文字输入，其实它的真正用武之地在于拥有多个构造函数的类。因为大多情况下，对于同一个成员，多个构造函数应使用相同的值去初始化。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">     A(): a(<span class="number">7</span>), b(<span class="number">5</span>), hash_algorithm(“MD5″),</div><div class="line">       s(“Constructor run”) &#123;&#125;</div><div class="line">    A(<span class="keyword">int</span> a_val) :</div><div class="line">      a(a_val), b(<span class="number">5</span>), hash_algorithm(“MD5″),</div><div class="line">      s(“Constructor run”)</div><div class="line">      &#123;&#125;</div><div class="line">    A(D d) : a(<span class="number">7</span>), b(g(d)),</div><div class="line">        hash_algorithm(“MD5″), s(“Constructor run”)</div><div class="line">        &#123;&#125;</div><div class="line">    <span class="keyword">int</span> a, b;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// 哈希加密函数可应用于类A的所有实例</span></div><div class="line">    HashingFunction hash_algorithm;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;  <span class="comment">// 用以指明对象正处于生命周期内何种状态的字符串</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>对于每一个构造函数，程序员必须使用完全一样的字面值来来初始化hash_algorithm和s这两个成员。但是并不是所有人都记得严格遵守这条规则，一旦出现纰漏，程序将难以维护。C++11给出了解决之道：可在成员声明的地方直接赋以初值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(): a(<span class="number">7</span>), b(<span class="number">5</span>) &#123;&#125;</div><div class="line">    A(<span class="keyword">int</span> a_val) : a(a_val), b(<span class="number">5</span>) &#123;&#125;</div><div class="line">    A(D d) : a(<span class="number">7</span>), b(g(d)) &#123;&#125;</div><div class="line">    <span class="keyword">int</span> a, b;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//哈希加密函数可应用于类A的所有实例</span></div><div class="line">    HashingFunction hash_algorithm&#123;“MD5″&#125;;</div><div class="line">    <span class="comment">//用以指明对象正处于生命周期内何种状态的字符串</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s&#123;“Constructor run”&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>如果一个成员同时在类内部初始化时和构造函数内被初始化，则只有构造函数的初始化有效（这个初始化值“优先于”默认值）（译注：可以认为，类内部初始化先于构造函数初始化进行，如果是对同一个变量进行初始化，构造函数初始化会覆盖类内部初始化）。因此，我们可以进一步简化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A() &#123;&#125;</div><div class="line">    A(<span class="keyword">int</span> a_val) : a(a_val) &#123;&#125;</div><div class="line">    A(D d) : b(g(d)) &#123;&#125;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">7</span>;</div><div class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//哈希加密函数可应用于类A的所有实例</span></div><div class="line">    HashingFunction hash_algorithm&#123;“MD5″&#125;;</div><div class="line">    <span class="comment">//用以指明对象正处于生命周期内何种状态的字符串</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s&#123;“Constructor run”&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><h4 id="原来在c-98中"><a href="#原来在c-98中" class="headerlink" title="原来在c++98中"></a>原来在c++98中</h4><p>是这样的，为了解决类成员函数和变量的作用域问题，在c++98中，可以将普通的重载函数从基类“晋级”到派生类里来解决这个问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> D:B&#123;</div><div class="line">    <span class="keyword">using</span> B::f;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="现在在c-11中"><a href="#现在在c-11中" class="headerlink" title="现在在c++11中"></a>现在在c++11中</h4><p>在c++11中构造函数中也可以晋级了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// 提升Base类的f函数到Derived类的作用范围内</span></div><div class="line">    <span class="comment">// 这一特性已存在于C++98标准内</span></div><div class="line">    <span class="keyword">using</span> Base::f;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>)</span></span>;     <span class="comment">// 提供一个新的f函数</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 与Base类的f(int)函数相比更常用到这个f函数</span></div><div class="line">    <span class="comment">// 提升Base类的构造函数到Derived的作用范围内</span></div><div class="line">    <span class="comment">// 这一特性只存在于C++11标准内</span></div><div class="line">    <span class="keyword">using</span> Base::Base;</div><div class="line">    Derived(<span class="keyword">char</span>);    <span class="comment">// 提供一个新的构造函数</span></div><div class="line">    <span class="comment">// 与Base类的构造函数Base(int)相比</span></div><div class="line">    <span class="comment">// 更常用到这个构造函数</span></div><div class="line">    Derived(<span class="keyword">int</span>);</div><div class="line">    <span class="comment">// …</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>注意这里的继承构造函数是隐式声明的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> A &#123;</div><div class="line"> A(<span class="keyword">int</span> a = <span class="number">3</span>, <span class="keyword">double</span> b = <span class="number">2.4</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> B : A&#123;</div><div class="line"> <span class="keyword">using</span> A::A;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>A的构造函数可能有A(int = 3, double = 2.4); A(int = 3); A(const A &amp;)（默认的复制构造函数）; A();则相应地，B中的构造函数也会有：<br>B(int, double); B(int); B(const B &amp;); B();</p><p>若碰到继承构造函数冲突的问题，需要通过显式定义继承类的冲突的构造函数，阻止隐式生成相应的继承构造函数。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> A &#123; A(<span class="keyword">int</span>) &#123;&#125; &#125;;</div><div class="line"><span class="keyword">struct</span> B &#123; B(<span class="keyword">int</span>) &#123;&#125; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> C: A, B &#123;</div><div class="line"> <span class="keyword">using</span> A::A;</div><div class="line"> <span class="keyword">using</span> B::B; <span class="comment">//会造成冲突</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//使用显式定义来解决：</span></div><div class="line"><span class="keyword">struct</span> C: A, B &#123;</div><div class="line"> <span class="keyword">using</span> A::A;</div><div class="line"> <span class="keyword">using</span> B::B;</div><div class="line"></div><div class="line"> C(<span class="keyword">int</span> i):A(i),B(i) &#123;&#125; <span class="comment">//显式定义</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>注意的问题：<br>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。且一旦使用继承构造函数，编译器就不会再为派生类生成默认构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> A &#123; A(<span class="keyword">int</span>) &#123;&#125;&#125;;</div><div class="line"><span class="keyword">struct</span> B : A &#123; <span class="keyword">using</span> A::A; &#125;;</div><div class="line">B b; <span class="comment">//错误，B没有默认构造函数</span></div></pre></td></tr></table></figure></p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v2 = &#123;<span class="number">9</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp;)</span></span>;</div><div class="line">f(&#123;<span class="number">9</span>&#125;);<span class="comment">//以列表&#123;9&#125;为参数被调用</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; args)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p=args.begin(); p!=args.end(); ++p)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意仅有一个std::initializer_list的单参数构造函数被称为初始化列表构造函数，标准库容器、string和正则类型均具有初始化列表构造函数，及初始化列表赋值函数。初始化列表也可以作为一种序列供auto for使用<br>是统一初始化方案的一部分。</p><h3 id="内联命名空间"><a href="#内联命名空间" class="headerlink" title="内联命名空间"></a>内联命名空间</h3><p>被inline修饰的内联命名空间，其内部所包含的所有类/函数/变量等声明，看起来就好像是直接在外围的命名空间中进行声明的一样。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h4 id="什么是lambda"><a href="#什么是lambda" class="headerlink" title="什么是lambda"></a>什么是lambda</h4><p>Lambda表达式是一种描述函数对象的机制，它的主要应用是描述某些具有简单行为的函数（Lambda表达式也可以称匿名函数，具有复杂行为的函数可以采用命名函数对象【匿名函数！匿名函数！lua！lua！】）<br>一个例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">50</span>, <span class="number">-10</span>, <span class="number">20</span>, <span class="number">-30</span>&#125;;</div><div class="line"><span class="built_in">std</span>::sort(v.begin(), v.end());    <span class="comment">// 排序时按照默认规则</span></div><div class="line"><span class="comment">// 此时v中的数据应该是 &#123; -30, -10, 20, 50 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 利用Lambda表达式，按照绝对值排序</span></div><div class="line"><span class="built_in">std</span>::sort(v.begin(), v.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)</div><div class="line">&#123; <span class="keyword">return</span> <span class="built_in">abs</span>(a)&lt;<span class="built_in">abs</span>(b); &#125;);</div><div class="line"><span class="comment">// 此时v应该是 &#123; -10, 20, -30, 50 &#125;</span></div></pre></td></tr></table></figure></p><p>这里的[]类似于function 真就匿名函数</p><h4 id="捕捉列表"><a href="#捕捉列表" class="headerlink" title="捕捉列表"></a>捕捉列表</h4><p>[&amp;] 是一个“捕捉列表(capture list)”，用于描述将要被lambda函数以引用传参方式使用的局部变量。如果我们仅想“捕捉”参数v，则可以写为: [&amp;v]。而如果我们想以传值方式使用参数v，则可以写为：[=v]。如果什么都不捕捉，则为：[]。将所有的变量以引用传递方式使用时采用[&amp;], 而相对地，使用[=] 则相应地表示以传值方式使用所有变量。（译注：“所有变量”即指lambda表达式在被调用处，所能见到的所有局部变量）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;Record&gt;&amp; v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices(v.size());</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    generate(indices.begin(),indices.end(),[&amp;count]()</div><div class="line">    &#123; <span class="keyword">return</span> count++; &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 对indices按照记录的名字域顺序进行排序</span></div><div class="line">    <span class="built_in">std</span>::sort(indices.begin(), indices.end(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)</div><div class="line">    &#123; <span class="keyword">return</span> v[a].name&lt;v[b].name; &#125;);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一般来说,lambda就可以当成是lua的匿名函数。</p><h4 id="一小段自己的总结"><a href="#一小段自己的总结" class="headerlink" title="一小段自己的总结"></a>一小段自己的总结</h4><p>至于闭包，只能说lambda简化了闭包的操作，使得以前需要用伪函数然后重载operator()来实现的东西更简单了。<br>但是！还是存在着问题的，我们看看在c++14和c++17里有无改进（关于变量作用范围等等，我们慢慢来）<br>这么一说c++真的很深，在某些地方的奇技淫巧上相当的古怪，明明是些简单的特性却能发展出如此难以理解的东西（。</p><h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><p>lambda基本形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type &#123;body&#125;</div></pre></td></tr></table></figure></p><p>[]叫做捕获说明符，表示一个lambda表达式的开始。接下来是参数列表，即这个匿名的lambda函数的参数。<br>parameters，普通参数列表<br>mutable修饰符，默认情况下，lambda总是一个const函数，使用该修饰符时，参数列表不可省略<br>-&gt;return-type表示返回类型，如果没有返回类型，则可以省略这部分。这涉及到c++11的另一特性，参见自动类型推导，最后就是函数体部分。另外，返回类型明确也可以用auto</p><hr><h4 id="关于lambda与闭包"><a href="#关于lambda与闭包" class="headerlink" title="关于lambda与闭包"></a>关于lambda与闭包</h4><h5 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h5><p>以下是几手资料。看一看，能加深一点理解也是好的。</p><p>一个lambda表达式，没有绑定其它环境时，我们称它为open lambda，而绑定了其它环境的lambda表达式，我们称它们为闭包（closure），评估一个open lambda的结果就是一个闭包。</p><p>而关于动态作用域其实还有另一个知识我们需要知道：deep binding（深约束）和shallow binding（浅约束）。<br>在一开始的有关动态作用域的说明中，按照函数调用顺序遍历找到最近的与之相关的符号，我们称之为浅约束。<br>而将函数作为参数时，需要将自由变量在单独的一个环境中保存，然后该函数引用这个单独的环境，我们称之为深约束。而这样捆绑起来的整体也就是我们所说的闭包。<br>换句话说，动态作用域中解决FUNARG问题的技术是深约束，而深约束中使用到的环境和函数这个整体称为闭包。</p><p>深约束的实现是非常困难的，另外程序员使用起来也是非常困难的，或者说非常容易出错，因为它需要使用到特殊的关键字标记函数或变量。</p><p>而将闭包发扬光大的是Scheme语言（1975年），Scheme是首个使用了词法作用域的LISP方言，据说它评估lambda表达式都会产生闭包，不需要程序员们考虑深约束浅约束的问题，不需要太关心自由变量引发的FUNARG问题。所以闭包也被称为词法闭包，解析器可以通过作用域自己判断产生闭包而不需要通过预定义的关键字去标记它。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>总的来说，如果想解释闭包是什么，有两种意义，分别是形式上的和概念上的。<br>概念上的闭包：在实现深约束（解决FUNARG问题）的过程中，函数需要引用到一个环境，而函数和这个环境形成的整体我们称为闭包。可以说闭包无处不在，例如对象。<br>形式上的闭包：词法上下文中引用了自由变量的函数，在不同语言中有不同的表现形式，并且衍生了很多运用方式，比如隐藏数据，作为简易对象使用。</p><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>相关的一些概念：</p><p>lambda表达式：可以用来表示函数的语法糖，本质是一个匿名函数。<br>动态/词法作用域：动态作用域中变量的作用范围和函数的调用顺序和定义方式有关，运行时才能确定。而词法作用域中，变量的作用范围是在源代码中就可以确定的。<br>深约束：动态作用域中为了解决FUNARG问题的技术，将引用环境和函数绑定在一起，函数会在绑定的环境中查找binding，实现起来非常困难。<br>浅约束：动态作用域的查找binding的默认工作方式，函数通过遍历调用过程，找到最近的binding。</p><h4 id="例子拉满"><a href="#例子拉满" class="headerlink" title="例子拉满"></a>例子拉满</h4><p>捏妈的，贴个大例子<br><a href="https://www.cnblogs.com/npbool/archive/2013/11/22/3434757.html" target="_blank" rel="external">https://www.cnblogs.com/npbool/archive/2013/11/22/3434757.html</a></p><h5 id="匿名函数：lambda表达式"><a href="#匿名函数：lambda表达式" class="headerlink" title="匿名函数：lambda表达式"></a>匿名函数：lambda表达式</h5><p>假设你有一个vector<int> v, 想知道里面大于4的数有多少个。for循环谁都会写，但是STL提供了现成算法count_if，不用可惜。C++03时代，我们会这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gt4</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> x&gt;<span class="number">4</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> GT4&#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> x&gt;<span class="number">4</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">　　<span class="comment">//很多</span></div><div class="line">    v.push_back(...);</div><div class="line">　　 ...</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;count_if(v.begin(),v.end(),gt4)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;count_if(v.begin(),v.end(),GT4())&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></int></p><p>就为这样一个微功能，要么写一个函数，要么写个仿函数functor，还不如手写循环简单，这是我的感受。如果用过其他语言的lambda表达式，这种写法完全是渣渣。</p><p>C++引入的lambda表达式提供了一种临时定义匿名函数的方法，可以这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> res = count_if(v.begin(),v.end(),[](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x&gt;<span class="number">4</span>; &#125;);</div></pre></td></tr></table></figure></p><p>世界瞬间美好了。既然是匿名函数，函数名自然不用写了，连返回类型都不用写了~想用一个函数，用的时候再写，大大提高了algorithm里各种泛型算法的实用性。</p><p>一般的lambda表达式语法是</p><p>[捕获列表] (参数列表) -&gt; 返回类型 {函数体}<br>(和上面那个一样的，翻译了一下(。</p><p>-&gt;返回类型可以省略；如果是无参的，(参数列表)也可以省略，真是各种省。匿名函数是个lambda对象，和函数指针有区别，但一般不用关心它。如果你想把一个匿名函数赋给一个函数指针类似物以待后续使用，可以用auto<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> func = [](<span class="keyword">int</span> arg) &#123; ... &#125;;</div></pre></td></tr></table></figure></p><p>但捕获列表是什么？接下来：</p><h5 id="闭包closure"><a href="#闭包closure" class="headerlink" title="闭包closure"></a>闭包closure</h5><p>如果改主意了，要求&gt;k的个数，k运行时指定，怎么办？你可能会写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> k;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;k;</div><div class="line"><span class="keyword">int</span> res = count_if(v.begin(),v.end(),[](<span class="keyword">int</span> x)&#123;</div><div class="line">    <span class="keyword">return</span> x&gt;k;</div><div class="line">&#125;); <span class="comment">//WRONG!</span></div></pre></td></tr></table></figure></p><p>但是编译器报错：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">error: variable <span class="string">'k'</span> cannot be implicitly captured <span class="keyword">in</span> a lambda</div><div class="line">      with no capture-default specified</div><div class="line">        <span class="built_in">return</span> x&gt;k;</div></pre></td></tr></table></figure></p><p>匿名函数不能访问外部函数作用域的变量？太弱了！</p><p>如果真是这样，实用性的确有限。lambda的捕获列表就是指定你要访问哪些外部变量，这里是k，于是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> res = count_if(v.begin(),v.end(),[k](<span class="keyword">int</span> x)&#123; <span class="comment">//注意[]里的</span></div><div class="line">     <span class="keyword">return</span> x&gt;k;</div><div class="line">&#125;); <span class="comment">//OK!</span></div></pre></td></tr></table></figure></p><p>如果要捕获多个变量，可以用逗号隔开。如果要捕获很多变量，干脆一起打包算了，用’=’捕获所有：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> res = count_if(v.begin(),v.end(),[=](<span class="keyword">int</span> x)&#123;</div><div class="line">     <span class="keyword">return</span> x&gt;k;</div><div class="line">&#125;); <span class="comment">//OK, too!</span></div></pre></td></tr></table></figure></p><p>通俗的说：子函数可以使用父函数中的局部变量，这种行为就叫做闭包。</p><p>解释一下各种捕获方式：</p><p>捕获capture有些类似传参。使用[k], [=]声明的捕获方式是复制copy，类似传值。区别在于，函数参数传值时，对参数的修改不影响外部变量，但copy的捕获直接禁止你去修改。如果想修改，可以使用引用方式捕获，语法是[&amp;k]或[&amp;]。引用和复制可以混用，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i,j;</div><div class="line">[=i, &amp;j] ()&#123;...&#125;;</div></pre></td></tr></table></figure></p><p>但闭包的能力远不止“使用外部变量”这么简单，最奇幻的是它可以超越传统C++对变量作用域生存期的限制。我们尝试一些刺激的。</p><h5 id="词法域"><a href="#词法域" class="headerlink" title="词法域"></a>词法域</h5><p>其实怎么说呢，这个东西放在别的语言就很自然，放在c++就很魔幻。<br>假设你要写一个等差数列生成器，初值公差运行时指定，行为和函数类似，第k次调用生成第k个值，并且各个生成器互不干扰，怎么写？</p><p>普通函数不好优雅地保存状态（全局变量无力了吧）。用仿函数好了，成员变量保存每个计数器的状态:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Counter</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> cur;</div><div class="line">    <span class="keyword">int</span> step;</div><div class="line">    Counter(<span class="keyword">int</span> _init,<span class="keyword">int</span> _step)&#123;</div><div class="line">        cur = _init;</div><div class="line">        step = _step;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</div><div class="line">        cur = cur+step;</div><div class="line">        <span class="keyword">return</span> cur-step;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span></span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;c()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125; <span class="comment">//输出1 4 7 10 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是我们现在有了闭包！把状态作为父函数中的局部变量，各个counter就可以不影响了。由于要修改外部变量，根据之前的介绍，声明成引用捕获[&amp;]。写起来大体像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">??? Counter(<span class="keyword">int</span> init,<span class="keyword">int</span> step)&#123;</div><div class="line">    <span class="keyword">int</span> cur = init;</div><div class="line">    <span class="keyword">return</span> [&amp;]&#123;</div><div class="line">        cur += step;</div><div class="line">        <span class="keyword">return</span> cur-step;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">auto</span> c = Counter(<span class="number">1</span>,<span class="number">3</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;c()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个问题！</p><p>第一个：Counter函数的返回类型怎么写？？？</p><p>Counter返回值是一个lambda，赋给c时可以用auto骗过去，但声明时写类型是躲不过去了。返回类型后置+decltype救不了你，因为后置了decltype还是获取不到返回值类型。lambda对象，虽然行为像函数指针，但是不能直接赋给一个函数指针。</p><p>介绍一个C++11新的模板类function，是消灭丑陋函数指针的大杀器。你可以把一个函数指针或lambda赋给它，例如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">float</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">&#125;</div><div class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">float</span>,<span class="keyword">float</span>)&gt; pfunc = func;</div><div class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">float</span>,<span class="keyword">float</span>)&gt; plambda = [](<span class="keyword">float</span> a,<span class="keyword">float</span> b)&#123; <span class="keyword">return</span> a+b;&#125;;</div></pre></td></tr></table></figure></p><p>比函数指针好看多了。<br><strong>但是要注意，这里是有转换的，lambda的返回值并不是任何一种值</strong>，如果你用decltype去推断然后扔到template里，编译器会这样告诉你：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">In instantiation of <span class="string">'T f() [with T = &lt;lambda(int, int)&gt;::&lt;lambda()&gt;]'</span>:</div></pre></td></tr></table></figure></p><p>只是可以转进到function里，方便使用</p><p>于是这里可以写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function&lt;<span class="keyword">int</span>()&gt; Counter(<span class="keyword">int</span> init,<span class="keyword">int</span> step)&#123; ... &#125;</div></pre></td></tr></table></figure></p><p>但是！如果再疯狂一点，匿名函数可以省略返回类型，auto可以推导类型，结合起来这样写是可以的！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> Counter = [](<span class="keyword">int</span> init,<span class="keyword">int</span> step)&#123;</div><div class="line">    <span class="keyword">int</span> cur = init;</div><div class="line">    <span class="keyword">return</span> [&amp;]()&#123;</div><div class="line">        cur += step;</div><div class="line">        <span class="keyword">return</span> cur-step;</div><div class="line">    &#125;;</div><div class="line">&#125;; <span class="comment">//不要漏';' 根本上还是赋值语句</span></div></pre></td></tr></table></figure></p><p>“类型推导, auto和decltype”一节里留的trick就是这个。javascript的即视感有木有！</p><p>第二个：编译通过，运行输出是这个？？？</p><p>$$<br>1<br>167772160<br>167772160<br>167772160<br>$$<br>看起来像是访问了无效内存。的确是这样。cur,step这两个局部变量在父函数的栈帧中，内部的匿名函数返回以后，父函数的栈帧就销毁了，而我们用的是“引用”，引用的变量已经没了。</p><p>既然放在栈上会有生存期问题，那就放堆里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> Counter = [](<span class="keyword">int</span> init,<span class="keyword">int</span> step)&#123;</div><div class="line">    <span class="keyword">int</span>* pcur = <span class="keyword">new</span> <span class="keyword">int</span>(init);</div><div class="line">    <span class="keyword">int</span>* pstep = <span class="keyword">new</span> <span class="keyword">int</span>(step);</div><div class="line">    <span class="keyword">return</span> [=]()&#123; <span class="comment">//注意！&amp;变成了=</span></div><div class="line">        *pcur += *pstep;</div><div class="line">        <span class="keyword">return</span> *pcur-*pstep;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>注意使用了[=]而不是[&amp;]。解释：</p><p>我们没有直接修改捕获的指针变量，而是修改它指向的变量，和[=]的规则不冲突<br>外部的指针还是在栈上，如果用[&amp;]还是会引用到已销毁的指针。我们只需要复制一份指针值。<br>这样输出的确正常了，但是内存泄漏了。程序员的节操呢？</p><p>用智能指针可以解决内存泄漏：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> Counter = [](<span class="keyword">int</span> init,<span class="keyword">int</span> step)&#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pcur(<span class="keyword">new</span> <span class="keyword">int</span>(init));</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pstep(<span class="keyword">new</span> <span class="keyword">int</span>(step));</div><div class="line">    <span class="keyword">return</span> [=]()&#123;</div><div class="line">        *pcur += *pstep;</div><div class="line">        <span class="keyword">return</span> *pcur-*pstep;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>虽然解决了问题，但过于繁琐了。本质上，我们需要的效果是把父函数的局部变量生存期延长，至少和子函数一样长。C++11提供了mutable关键字，可以模拟这一功能：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> Counter = [](<span class="keyword">int</span> init,<span class="keyword">int</span> step)&#123;</div><div class="line">    <span class="keyword">int</span> cur = init;</div><div class="line">    <span class="keyword">return</span> [=] () <span class="keyword">mutable</span> &#123;</div><div class="line">        cur += step;</div><div class="line">        <span class="keyword">return</span> cur-step;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>加上mutable，就告诉编译器，这个变量是父子函数共享的，子函数对它的修改要反映到外部，并且它的生存期要和子函数一样长！</p><p>这里可能有点绕，函数哪来的生存期？注意这里“子函数”并不是真正的函数，只是一个lambda类型的变量，只是有函数的行为，一样有生存期。</p><p>闭包最大的用处在于写回调函数，比如事件响应。当初学Java的时候，Swing里用户界面各种内部类，感觉很烦。现在Java终于也有闭包了（Java8）~（语言都是相通的嘛）</p><hr><h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>在C++98中，局部类和未命名类不能作为模板参数，这或许是一个负担，C++11则放宽了这方面的限制：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;X&gt;&amp; v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> Less &#123;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> X&amp; a, <span class="keyword">const</span> X&amp; b)</span></span></div><div class="line">        &#123; <span class="keyword">return</span> a.v&lt;b.v; &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// C++98: 错误: Less是局部类</span></div><div class="line">        <span class="comment">// C++11: 正确</span></div><div class="line">        sort(v.begin(), v.end(), Less());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当然除了这里的局部类之外，在C++11中，我们还可以采用Lambda表达式来做同样的事情：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;X&gt;&amp; v)</span></span></div><div class="line">&#123;</div><div class="line">    sort(v.begin(), v.end(),</div><div class="line">        [] (<span class="keyword">const</span> X&amp; a, <span class="keyword">const</span> X&amp; b) &#123; <span class="keyword">return</span> a.v&lt;b.v; &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="窄转换"><a href="#窄转换" class="headerlink" title="窄转换"></a>窄转换</h3><p>(窄转换已经不被允许了，忘了在哪看到的了）<br>窄转换——使用初始化列表进行初始化可以防止发生窄转换（即从高等级类型下降到低等级类型，当然如果可以无损转换，则不存在）</p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>超级无敌的——nullptr<br>NULL可以认为是一个常数0的宏，nullptr是一个关键字，内建标识符，可以认为是(char *)</p><h3 id="override-final"><a href="#override-final" class="headerlink" title="override,final"></a>override,final</h3><p>override表示必须被重载<br>final表示阻止继续重写<br>我们在后面还会看到这点</p><hr><h3 id="本期结语"><a href="#本期结语" class="headerlink" title="本期结语"></a>本期结语</h3><p>别放弃(。<br>其实多看几遍感觉还都能记住…?<br>很多地方加了太多的扩展，就是为了能理解的更好，印象更深刻一点。<br>后面还有很多，加油、</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c++11的东西有点多，我到现在还欠着几项东西没学&lt;br&gt;这篇包含lambda、enum、constexpr、explicit等，详见目录&lt;br&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://oodtoodt.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="http://oodtoodt.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://oodtoodt.github.io/tags/c-11/"/>
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
  </entry>
  
  <entry>
    <title>sol2笔记</title>
    <link href="http://oodtoodt.github.io/2020/01/13/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/sol2%E7%AC%94%E8%AE%B0/"/>
    <id>http://oodtoodt.github.io/2020/01/13/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/sol2%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-13T09:16:15.000Z</published>
    <updated>2020-01-13T10:32:36.854Z</updated>
    
    <content type="html"><![CDATA[<p>sol2是一个轻量的用于C+绑定Lua脚本的库，仅由头文件组成，方便集成，并提供了大量易用的API接口，可以便利地将Lua脚本与C+代码绑定起来，而不必去关心如何使用那些晦涩的Lua C API。<br><a id="more"></a></p><hr><p>哦既然写到了sol2，那么也写一下lua的。<br>找了半天没找到个合适的说明</p><p>摘一段知乎的吧<br>    Python有明确的OOP系统，使用方式一致，便于创建各种库和进行分享（OOP对复用来说是决定性质的）。而Lua的优势也是它的弱势，它太自由了，我们用一个第三方Lua库，几乎只能使用它，而很难基于它进行二次封装和开发，你可以看LuaOOP里面有多少种，还不提没写在里面的。定义方式无法统一，就很难做反射，编辑器也没法针对每种实现给出提示。<br>    Lua现在活跃的场所，都是平台本身或者第三方加入了支持后，能够以确定方式使用的场景，这也是Lua自身定位，所以它大多使用在游戏内，或者软件内，导致它基本是作为内部项目使用，不会有什么曝光度。而Python的定位是独立语言的，这也决定它受限更小，应用场景更大。<br>    单纯论语言的话，我还是更喜欢Lua，语法设计太优秀了<br>    作者：Kurapica<br>    链接：<a href="https://www.zhihu.com/question/273743493/answer/370642314" target="_blank" rel="external">https://www.zhihu.com/question/273743493/answer/370642314</a><br>    来源：知乎<br>    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>另外似乎我们这边很看重lua比起c++来说的高安全性</p><p>废话有点多了，笔记，来!</p><hr><h2 id="sol2笔记"><a href="#sol2笔记" class="headerlink" title="sol2笔记"></a>sol2笔记</h2><p>范哥nb！<br>今天跳过各种c调用lua的api，进入sol2学习。</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>首先惯例（起手<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sol::state lua;</div><div class="line">lua.open_libraries(sol::lib::base);</div></pre></td></tr></table></figure></p><h3 id="运行一个脚本"><a href="#运行一个脚本" class="headerlink" title="运行一个脚本"></a>运行一个脚本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lua.script();</div><div class="line">lua.script_file();<span class="comment">//注意运行lua代码要检查</span></div><div class="line"><span class="keyword">auto</span> bad_code_result = lua.script(<span class="string">".."</span>,[](lua_State*, sol::protected_function_result pfr)</div><div class="line">c_assert(!bad_code_result.valid());</div><div class="line"><span class="comment">//使用.safe_script来看到更多的安全方法</span></div></pre></td></tr></table></figure><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>传参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用...访问</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; my_script = <span class="string">R"(//?</span></div><div class="line">    local a,b,c = ... </div><div class="line">    print(a,b,c)</div><div class="line">)";</div><div class="line">sol::load_result fx = lua.load(my_script);</div><div class="line"><span class="keyword">if</span>(!fx.valid()) &#123;</div><div class="line">    sol::error err = fx;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">"failed to load string-based script in the program"</span>&lt;&lt;err.what()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">fx(<span class="string">"your"</span>,<span class="string">"arguments"</span>,<span class="string">"here"</span>);</div></pre></td></tr></table></figure><h3 id="转序列化"><a href="#转序列化" class="headerlink" title="转序列化"></a>转序列化</h3><p>不是，这个转序列化也太强了吧。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sol::load_result lr = lua.load(<span class="string">"a = function (v) print(v) return v end"</span>);</div><div class="line">c_assert(lr.valid())</div><div class="line">sol::protected_function target = lr;</div><div class="line">sol::bytecode target_bc = target.dump()</div><div class="line"><span class="keyword">auto</span> result2 = lua2.safe_script(target_bc.as_string_view(), sol::script_pass_on_error);</div><div class="line"><span class="comment">// check if it was done properly</span></div><div class="line">c_assert(result2.valid());</div><div class="line"></div><div class="line"><span class="comment">// check in the second state if it was valid</span></div><div class="line">sol::protected_function pf = lua2[<span class="string">"a"</span>];</div><div class="line"><span class="keyword">int</span> v = pf(<span class="number">25557</span>)</div><div class="line"><span class="comment">//注意这里各种前面的类型，所以我就直接都贴过来了。</span></div></pre></td></tr></table></figure></p><p>不过流程只能看懂一部分，但是具体逻辑搞不懂qaq</p><h3 id="变量的设置和获取"><a href="#变量的设置和获取" class="headerlink" title="变量的设置和获取"></a>变量的设置和获取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lua.<span class="built_in">set</span>()</div><div class="line">lua[<span class="string">""</span>] = ...</div><div class="line">lua[<span class="string">"a"</span>] = lua.create_table_with(<span class="string">"v"</span>,<span class="number">2</span>)<span class="comment">//a = &#123;v = 2&#125;</span></div><div class="line">lua[<span class="string">"a_function"</span>] = []() &#123; <span class="keyword">return</span> <span class="number">100</span>; &#125;;==a_function = function () <span class="keyword">return</span> <span class="number">100</span> end,</div><div class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>()&gt; a_std_function = a_function;</div></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>object和其他sol::来检查lua类型<br>设置成nullptr或者set成sol::nua_nil<br>注意到这里如果是c++类型的userdata/usertype，“则析构函数仅在垃圾收集器认为适合破坏内存时才运行。如果您依赖于将析构函数设置为时运行的析构函数sol::lua_nil，那么您可能犯了一个错误”</p><h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>script 起手都是一个R”()”啊，我也没懂，c++11特性？<br>即原始字符串，不会对反斜杠做特殊合理，空白和换行符都是字符串的一部分。妙啊。<br>看来c++111417迫在眉睫</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>表的操作非常方便。<br>sol::table 是一个表，支持各种[]的操作<br>但是深入要注意安全<br>表的声明非常简单</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>可以绑定函数。<br>不绑定的函数需要传实例化的参数进去。<br>即两种如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> some_class&#123;</div><div class="line">    <span class="keyword">int</span> variable = <span class="number">30</span>;</div><div class="line">&#125;;</div><div class="line">lua.set_function(<span class="string">"v2"</span>,&amp;some_class::variable,some_class&#123;&#125;);</div><div class="line">lua[<span class="string">"v1"</span>] = &amp;some_class::variable;</div><div class="line">v2(<span class="number">254</span>);</div><div class="line">v1(sc,<span class="number">212</span>);</div></pre></td></tr></table></figure></p><p>c++里可以用self来模拟:带来的语法糖（谁模拟谁也不好说ww</p><p>多组返回应用std::tuple&lt;…,…,…&gt;建预设类型的表，或者是直接先用类型后tie起来暂时当一体用<br>（绝了这也是c++11</p><p>多个到lua的返回值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lua[<span class="string">"f"</span>] = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b,sol::object c)&#123;</div><div class="line">    <span class="comment">// sol::object can be anything here: just pass it through</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(a,b,c)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="c-类中的类"><a href="#c-类中的类" class="headerlink" title="c++类中的类"></a>c++类中的类</h3><p>所有不是原始类、string类、函数类、指定的sol类: sol::table,sol::thread,sol::error,sol::object，透明参数类型:sol::varidic_arg,sol::this_state,sol::this_environment，usertype<t>类: sol::usertype<br>的都被设置为userdata+usertype</t></p><p>来了来了，移动语义、浅拷贝（其实不是浅拷贝，只是说是被lua拥有了，然后会被lua的虚拟机在垃圾回收的时候删掉），正常的等号都会拷贝<br>std::unique_ptr/std::shared_ptr会受到尊重（</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The following stores a reference, and does not copy/move</span></div><div class="line"><span class="comment">// lifetime is same as dog in C++</span></div><div class="line"><span class="comment">// (access after it is destroyed is bad)</span></div><div class="line">lua[<span class="string">"dog"</span>] = &amp;dog;</div><div class="line"><span class="comment">// Same as above: respects std::reference_wrapper</span></div><div class="line">lua[<span class="string">"dog"</span>] = <span class="built_in">std</span>::ref(dog);</div><div class="line"><span class="comment">// These two are identical to above</span></div><div class="line">lua.<span class="built_in">set</span>( <span class="string">"dog"</span>, &amp;dog );~</div><div class="line">lua.<span class="built_in">set</span>( <span class="string">"dog"</span>, <span class="built_in">std</span>::ref( dog ) );</div><div class="line">Doge&amp; dog_ref = lua[<span class="string">"dog"</span>]; <span class="comment">// References Lua memory</span></div><div class="line">Doge* dog_pointer = lua[<span class="string">"dog"</span>]; <span class="comment">// References Lua memory</span></div><div class="line">Doge dog_copy = lua[<span class="string">"dog"</span>]; <span class="comment">// Copies, will not affect lua</span></div></pre></td></tr></table></figure><h3 id="lua中的c-类"><a href="#lua中的c-类" class="headerlink" title="lua中的c++类"></a>lua中的c++类</h3><p>鸽了，要用几个大例子的，例子里到处都是看不懂的c++11语法</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>用表在lua里模拟c++的命名空间（注意和本身的环境做一下区分)</p><p>…先搞c++11吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sol2是一个轻量的用于C+绑定Lua脚本的库，仅由头文件组成，方便集成，并提供了大量易用的API接口，可以便利地将Lua脚本与C+代码绑定起来，而不必去关心如何使用那些晦涩的Lua C API。&lt;br&gt;
    
    </summary>
    
    
      <category term="lua" scheme="http://oodtoodt.github.io/categories/lua/"/>
    
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="lua" scheme="http://oodtoodt.github.io/tags/lua/"/>
    
      <category term="sol2" scheme="http://oodtoodt.github.io/tags/sol2/"/>
    
  </entry>
  
  <entry>
    <title>lua笔记整理(2)</title>
    <link href="http://oodtoodt.github.io/2020/01/13/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%862/"/>
    <id>http://oodtoodt.github.io/2020/01/13/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%862/</id>
    <published>2020-01-13T07:45:32.000Z</published>
    <updated>2020-01-13T09:15:27.089Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下关于lua的笔记</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="day6（元表）"><a href="#day6（元表）" class="headerlink" title="day6（元表）"></a>day6（元表）</h3><h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><p>我惊了 我居然卡了。</p><p>将一个函数用作<strong>index元方法，让所有只读表共享同一个元表<br>首先，用</strong>index就必须要访问nil，所以原表必须是空的，然后访问元表的<strong>index。<br>那么如何共享同一个元表呢？这感觉就很不现实啊，不同只读表用同一元表访问的时候调用</strong>index，在元素不同的情况下怎么保证访问元素正确呢？然后最后的问题在于，为什么只读表使用index方法？</p><p>找了一圈也没找到这种只读的实现，只能理解成题目有问题了。不过也不是一无所获，至少对于这个代理的过程轻车熟路了。</p><p>我参考了一下，也许是<strong>newindex，这样共享同一个也说得通，然后每次访问之前set一下</strong>index，可能是想表达这样一个东西吧（<br>但是如果不set就会去访问别的表hhh<br>但是面临一个问题，就是必须把原表以某种形式存下来，因为代理里肯定没东西，那么代理因为要index别人跑了拐回来就必须调用这个存下来的数据</p><p>算了，不搞了，mdzz</p><p>弱智字符串不支持遍历 不支持下标<br>然后记得string_to_table是有要求的，那就是形式上是符合table格式的！<br>如<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> string_1 = <span class="string">'&#123; [name] = "string_1", [color] = "red" &#125;'</span></div><div class="line"><span class="keyword">local</span> string_2 = <span class="string">'&#123; [name] = "string_2", [color] = "blue" &#125;'</span></div><div class="line"><span class="keyword">local</span> string_3 = <span class="string">'&#123; [name] = "string_3", [color] = "green" &#125;'</span></div><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">str2tbl</span><span class="params">(str)</span></span></div><div class="line">   <span class="keyword">return</span> <span class="built_in">assert</span>((<span class="built_in">loadstring</span> <span class="keyword">or</span> <span class="built_in">load</span>)(<span class="string">'return '</span>..str:gsub(<span class="string">'%[(.-)]'</span>,<span class="string">'["%1"]'</span>)))()</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>另外放弃你那弱智的遍历高速的思想，我求。</p><p>t1 = {nil}<br>t2 = {1,nil,2}<br>t3 = {1,nil,2,nil}<br>t4 = {1,nil,2,nil,3}<br>t5 = {1,nil,2,nil,3,nil}<br>t6 = {1,nil,2,nil,3,nil,nil}<br>print(#t1,#t2,#t3,#t4,#t5,#t6)<br>–[[0   3   1   5    3    5]]</p><p>惊了，真实神奇，简直就是switch出来的数据</p><p>突然卡壳，不知道对偶的stack怎么写<br>正常而言，一个对偶接近于一个倒排索引，虽然不是调换key和value位置就是了<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[key] = value<span class="comment">---key[a] = value</span></div></pre></td></tr></table></figure></p><p>然后很反直觉的，对于一个双向队列来说，key[a]取出的东西是什么就非常奇怪<br>如果是值，那么正反向获取不到，如果是位置，那么就必须存两端的位置，然后另外开一个东西记录数据。（其实我不很懂这么两次用表的意义）（在于继承和私有）<br>最后没开，直接就用的self，对偶扔外面了</p><h4 id="然后还是写了？实现只读表"><a href="#然后还是写了？实现只读表" class="headerlink" title="然后还是写了？实现只读表"></a>然后还是写了？实现只读表</h4><p>可能是有问题的，应该是吧，烂摊子不太想管<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> </div><div class="line">    <span class="keyword">local</span> mt = &#123;&#125;</div><div class="line">    mt.__newindex = <span class="function"><span class="keyword">function</span> <span class="params">(t,k,v)</span></span></div><div class="line">        <span class="built_in">error</span>(<span class="string">"attempt to update a read-obly table"</span>,<span class="number">2</span>)</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setVisT</span><span class="params">(t)</span></span></div><div class="line">        mt.__index = t.vvvIn</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">readOnly</span><span class="params">(t)</span></span></div><div class="line">        <span class="keyword">local</span> temp = &#123;&#125;</div><div class="line">        temp.vvvIn = t</div><div class="line">        <span class="comment">--setVisT(t)</span></div><div class="line">        <span class="built_in">setmetatable</span>(temp,mt)</div><div class="line">        <span class="keyword">return</span> temp</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">local</span> a = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line">    <span class="keyword">local</span> b = readOnly(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</div><div class="line">    setVisT(b)</div><div class="line">    <span class="comment">--a[1] = 2</span></div><div class="line">    <span class="built_in">print</span>(inspect(a))</div><div class="line">    <span class="built_in">print</span>(b[<span class="number">2</span>])</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><h4 id="代理使得pairs-t-遍历一个文件的所有字节"><a href="#代理使得pairs-t-遍历一个文件的所有字节" class="headerlink" title="代理使得pairs(t)遍历一个文件的所有字节"></a>代理使得pairs(t)遍历一个文件的所有字节</h4><p>创建一个以文件为参数，返回为文件的代理的代理表<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fileasArray</span><span class="params">(fn)</span></span></div><div class="line">        <span class="keyword">local</span> proxy = &#123;&#125;</div><div class="line">        <span class="keyword">local</span> fr = <span class="built_in">io</span>.open(fn,<span class="string">"r"</span>)</div><div class="line">        <span class="keyword">local</span> alfile = fr:read(<span class="string">"a"</span>)</div><div class="line">        <span class="keyword">local</span> str2tab = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i = <span class="number">1</span>,#alfile <span class="keyword">do</span></div><div class="line">            str2tab[i] = <span class="built_in">string</span>.sub(alfile,i,i)</div><div class="line">        <span class="keyword">end</span></div><div class="line">        <span class="keyword">local</span> mt = &#123;</div><div class="line">            __index = str2tab,</div><div class="line">            __newindex = <span class="function"><span class="keyword">function</span> <span class="params">(_,i,ch)</span></span></div><div class="line">                str2tab[i] = ch</div><div class="line">            <span class="keyword">end</span>,</div><div class="line">            __len = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> #str2tab <span class="keyword">end</span>,</div><div class="line">            __tostring = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></div><div class="line">                <span class="keyword">local</span> l = &#123;&#125;</div><div class="line">                <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(str2tab) <span class="keyword">do</span></div><div class="line">                    l[#l + <span class="number">1</span>] = <span class="built_in">tostring</span>(v)</div><div class="line">                <span class="keyword">end</span></div><div class="line">                <span class="keyword">return</span> <span class="string">"&#123;"</span> .. <span class="built_in">table</span>.concat(l,<span class="string">""</span>) .. <span class="string">"&#125;"</span></div><div class="line">            <span class="keyword">end</span>,</div><div class="line">            __pairs = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">                <span class="keyword">local</span> i = <span class="number">0</span></div><div class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">                    i = i + <span class="number">1</span></div><div class="line">                    <span class="keyword">if</span> i &gt; #str2tab <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">end</span></div><div class="line">                    <span class="keyword">return</span> i,str2tab[i]</div><div class="line">                <span class="keyword">end</span></div><div class="line">            <span class="keyword">end</span>, </div><div class="line">        &#125;</div><div class="line">        <span class="built_in">setmetatable</span>(proxy,mt)</div><div class="line">        <span class="keyword">return</span> proxy</div><div class="line">    <span class="keyword">local</span> t = fileasArray(f1)</div><div class="line">    <span class="keyword">local</span> t2 = fileasArray(f1)</div><div class="line">    <span class="built_in">print</span>(inspect(t))</div><div class="line">    <span class="built_in">print</span>(t)</div><div class="line">    t[<span class="number">1</span>] = <span class="string">"?"</span></div><div class="line">    t[<span class="number">10</span>] = <span class="keyword">nil</span></div><div class="line">    <span class="built_in">print</span>(t)</div><div class="line">    <span class="built_in">print</span>(#t2,#t)</div><div class="line">    <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="built_in">print</span>(v) <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><h3 id="day7（环境）"><a href="#day7（环境）" class="headerlink" title="day7（环境）"></a>day7（环境）</h3><h4 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h4><p>把旧环境装入新环境的方式是使用继承<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">1</span></div><div class="line"><span class="keyword">local</span> newgt = &#123;&#125;</div><div class="line"><span class="built_in">setmetatable</span>(newgt,&#123;__index = <span class="built_in">_G</span>&#125;)</div><div class="line">_ENV = newgt</div><div class="line"><span class="built_in">print</span>(a)</div><div class="line">a = <span class="number">10</span></div><div class="line"><span class="built_in">print</span>(a,<span class="built_in">_G</span>.a)<span class="comment">--10       1</span></div></pre></td></tr></table></figure></p><p>应该这么讲：之后的赋值都发生在新的表中，与全局环境无关了，但是这跟表的继承相悖啊。为什么改了_G，_ENV不会变？好怪<br>做了下实验，懂了。因为这里的a = 10直接就给赋值了，所以第二次就没动__index元方法而是跑的_ENV本身的。还是太不熟了。</p><p>模式匹配真难啊，匹配所有.然后split写了一中午<br>先是[%w_]<em>%.匹配到最后尝试匹配最后一个.<br>然后想了半天没想出好法子，至少不能写一个类似的匹配语句来做，想到的居然是reverse一下然后再gsub(“(.-)%.(.</em>)$”,”%1”)这么整活，依赖于reverse的复杂度，问题是reverse还不够复杂?新开一个表然后遍历一遍。<br>何苦呢，怎么不再用find或者gmatch”%.”到底?<br>最后，split有简单实现的啊。[^t]+ t是任意字符不好吗<br>或者干脆您就原字符串后面加个.，最后去了，不也行吗(gmatch根本不需要去掉，加着就行)</p><p>虽然写好了，但是错误处理不知道怎么调</p><p>弱引用中，不管是键还是值被回收了整个键值对就木了。</p><p>然后这个常量函数工厂给我整蒙了<br>虽然表中的键是弱引用的，但是表中的值却不是弱引用的，由于值不是弱引用的，所以每个函数都存在以强引用，每个函数指向其对象，于是每个键都存在一强引用<br>似乎作者也不是很想在这里纠结？就是说类似成环的闭包引用了指回闭包的对象的这种情况。</p><p>析构重要的是概念，所以必须先占个位</p><p>析构器的对象调用析构器前先清理弱引用表的值，调用后清理键，原因在于析构器可能需要访问带有弱引用键的表来保存对象的属性   </p><h4 id="么得代码"><a href="#么得代码" class="headerlink" title="么得代码"></a>么得代码</h4><h3 id="day8（垃圾收集）"><a href="#day8（垃圾收集）" class="headerlink" title="day8（垃圾收集）"></a>day8（垃圾收集）</h3><h4 id="笔记-2"><a href="#笔记-2" class="headerlink" title="笔记"></a>笔记</h4><p>我太菜了（不知道怎么写出一个证明lua需要瞬表的代码<br>弱引用键、强引用值，加上一些嵌套自环，我整个人都不好了</p><p>诶？为什么我这里的输出跟网上的截然不同？别人讲得头头是道，我这根本理解不能？<br>好的<strong>gc 打错成 </strong>gcd了 我佛了<br>写一下我的猜测哈：第一次count为0意味着所有的析构器已经调用完成了，这时已经完成的应该是清除了每个元素，但是元素悬挂的元表应该只是被标记并没有被清除，第二次就清除</p><h4 id="需要解释的代码："><a href="#需要解释的代码：" class="headerlink" title="需要解释的代码："></a>需要解释的代码：</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> </div><div class="line">    <span class="keyword">local</span> count = <span class="number">0</span></div><div class="line">    <span class="keyword">local</span> mt = &#123;__gc = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> count = count - <span class="number">1</span> <span class="keyword">end</span>&#125;</div><div class="line">    <span class="keyword">local</span> a = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10000</span> <span class="keyword">do</span> </div><div class="line">        count = count + <span class="number">1</span></div><div class="line">        a[i] = <span class="built_in">setmetatable</span>(&#123;&#125;,mt)</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="built_in">collectgarbage</span>()</div><div class="line">    <span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"count"</span>) * <span class="number">1024</span>, count)</div><div class="line">    a = <span class="keyword">nil</span></div><div class="line">    <span class="built_in">collectgarbage</span>()</div><div class="line">    <span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"count"</span>) * <span class="number">1024</span>, count)</div><div class="line">    <span class="built_in">collectgarbage</span>()</div><div class="line">    <span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"count"</span>) * <span class="number">1024</span>, count)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">--[[</span></div><div class="line">604716.0        10000</div><div class="line">342576.0        0</div><div class="line">22576.0         0</div><div class="line">]]<span class="comment">--</span></div></pre></td></tr></table></figure><h3 id="day9（协程）"><a href="#day9（协程）" class="headerlink" title="day9（协程）"></a>day9（协程）</h3><h4 id="笔记-3"><a href="#笔记-3" class="headerlink" title="笔记"></a>笔记</h4><p>他这里用的这个全排列挺反我的直觉的，因为我的思路就是dfs，每次添加一未使用的数据这样；他的思路是每次交换元素继续对剩下的元素做同样的递归操作，因为会按次序都移回来所以保证了能访问到所有排列。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">permgen</span><span class="params">(a,n)</span></span></div><div class="line">    n = n <span class="keyword">or</span> #a</div><div class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">then</span></div><div class="line">        <span class="comment">--coroutine.yield(a)</span></div><div class="line">        printResult(a)</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">for</span> i = <span class="number">1</span>,n <span class="keyword">do</span></div><div class="line">            a[n],a[i] = a[i],a[n]</div><div class="line"></div><div class="line">            permgen(a,n<span class="number">-1</span>)</div><div class="line"></div><div class="line">            a[n],a[i] = a[i],a[n]</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>其实整个思路我最不能明白的部分就是为什么需要用协程的迭代器。<br>可以离线，那么就可以在中间断开搞协程。这样高的好处是啥？没搞明白。调用上更简单？<br>但是就实现而言，二者没有区别（指思路），单纯就是好用不需要关心内部吗？那么协程之间会不会发生什么呢？</p><p>不过这个传参return的方法值得学习（</p><p>新的问题：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i = <span class="number">1</span>,#a <span class="keyword">do</span></div><div class="line">    <span class="keyword">local</span> t = i</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">        t = t + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> t</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>如果这是个迭代器,会得到正确结果吗？我怀疑不会。<br>因为迭代器上来就返回了第一个函数然后应该就定死了，upvalue是不会在上层变，而只会在迭代器里改变，要充分理解到这一点。<br>回到我们实际的情况：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> t = solve(a,n)</div><div class="line"><span class="keyword">for</span> i = <span class="number">1</span>,#t <span class="keyword">do</span></div><div class="line">    <span class="keyword">local</span> co = <span class="built_in">coroutine</span>.create(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> permgen(t[i],n) <span class="keyword">end</span>)</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">local</span> code,res = <span class="built_in">coroutine</span>.resume(co)</div><div class="line">        <span class="keyword">return</span> res</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>co就已经是初值了，因为它是一个协程，所以它是会执行的自己跑到某个地方然后停下，由迭代器再启动它。<br>但是不可能有第二个co的值。</p><p>ok！顺带还搞明白了迭代器，舒服。</p><p>然后就又卡了。写一个基于协程库的行迭代器来读文件。问题在于原用的协程是coroutine.running()，取得是当前的协程，我这里要读文件应该怎么处理？需要对应不同的协程？for循环里还需要指定协程吗？不指定的话，直接使用当前协程不会出问题吗？<br>整个流程很明确倒是，因为行迭代器无非就是每次读的时候resume，yield，然后可能稍微卡一下传参，但是搞不清楚前面这些我就很憋，不想写。</p><p>使用基于协程库来同时运行多个线程。一个简单的场景是多文件一起读写，问题是这里我们数据不够大根本看不出区别，只要没bug应该就是成功的。<br>不想写，鸽一会。</p><p>两个结合在一起我觉得可以搞。<br>但是问题就是迭代器要求的是直接遍历，总感觉有些冲突，我再读点网上材料。网上没讨论这个的。。我的问题在于多线程在这个问题里到底怎么解释，就是说我是同时遍历所有文件对吧？</p><p>那如果，不能迭代器结合多线程，那我写基于协程库的迭代器意义在哪里呢<br>草26章有讲多线程，回头说回头说…什么鬼设计嘛<br><strong>（别想了，回头也什么也说不出来</strong></p><h4 id="使用生产者驱动重写生产者消费者示例"><a href="#使用生产者驱动重写生产者消费者示例" class="headerlink" title="使用生产者驱动重写生产者消费者示例"></a>使用生产者驱动重写生产者消费者示例</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span> </div><div class="line">            <span class="keyword">local</span> x = receive()</div><div class="line">            <span class="built_in">io</span>.write(x,<span class="string">"\n"</span>)            </div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span> </div><div class="line">            <span class="keyword">local</span> x = <span class="built_in">io</span>.read()</div><div class="line">            send(x)</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">local</span> value = <span class="built_in">coroutine</span>.yield()</div><div class="line">        <span class="keyword">return</span> value</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></div><div class="line">        <span class="built_in">coroutine</span>.resume(consumer,x)</div><div class="line">    <span class="keyword">end</span></div><div class="line">    consumer = <span class="built_in">coroutine</span>.create(consumer)</div><div class="line">    <span class="built_in">print</span>(<span class="built_in">coroutine</span>.status(consumer))</div><div class="line">    <span class="built_in">coroutine</span>.resume(consumer)</div><div class="line">    <span class="comment">--producer()</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="comment">--以下是消费者驱动</span></div><div class="line"><span class="keyword">do</span> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span> </div><div class="line">            <span class="keyword">local</span> x = <span class="built_in">io</span>.read()</div><div class="line">            send(x)</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span> </div><div class="line">            <span class="keyword">local</span> x = receive()</div><div class="line">            <span class="built_in">io</span>.write(x,<span class="string">"\n"</span>)            </div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">local</span> status,value = <span class="built_in">coroutine</span>.resume(producer)</div><div class="line">        <span class="keyword">return</span> value</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></div><div class="line">        <span class="built_in">coroutine</span>.yield(x)</div><div class="line">    <span class="keyword">end</span></div><div class="line">    producer = <span class="built_in">coroutine</span>.create(producer)</div><div class="line">    <span class="built_in">print</span>(<span class="built_in">coroutine</span>.status(producer))</div><div class="line">    <span class="comment">--consumer()</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><h4 id="编写一个函数输出制定数组的所有组合，使用协程修改为组合的生成器"><a href="#编写一个函数输出制定数组的所有组合，使用协程修改为组合的生成器" class="headerlink" title="编写一个函数输出制定数组的所有组合，使用协程修改为组合的生成器"></a>编写一个函数输出制定数组的所有组合，使用协程修改为组合的生成器</h4><p>我用了个二进制的模拟，意外的难写ww<br>也许有更直接的思路吧，不过我这脑子真转不来了。<br>~=4，所以里面其实控制位数没写好？应该是啥？#a吧<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--[[</span></div><div class="line">    function permutations(a)</div><div class="line">        local co = coroutine.create(function()permagen(a)end)</div><div class="line">        return function()</div><div class="line">            local code,res = coroutine.resume(co)</div><div class="line">            return res</div><div class="line">        end</div><div class="line">    end</div><div class="line"></div><div class="line">    等同于</div><div class="line"></div><div class="line">    function permutations(a)</div><div class="line">        return coroutine.wrap(function()permgen(a) end)</div><div class="line">    end</div><div class="line">]]</div><div class="line"></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">solve</span><span class="params">(a,n)</span></span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"?"</span>)</div><div class="line">        <span class="keyword">local</span> num = <span class="number">2</span>^(#a)</div><div class="line">        <span class="keyword">local</span> t = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i = <span class="number">0</span>,num<span class="number">-1</span> <span class="keyword">do</span> </div><div class="line">            <span class="keyword">local</span> temp = i</div><div class="line">            <span class="keyword">local</span> t_now = &#123;&#125;</div><div class="line">            <span class="keyword">local</span> t_pos = <span class="number">1</span></div><div class="line">            <span class="keyword">while</span>(temp ~= <span class="number">0</span>) <span class="keyword">do</span></div><div class="line">                t_now[t_pos] = temp % <span class="number">2</span></div><div class="line">                temp = temp//<span class="number">2</span></div><div class="line">                t_pos = t_pos + <span class="number">1</span></div><div class="line">            <span class="keyword">end</span></div><div class="line">            <span class="keyword">while</span> #t_now ~= <span class="number">4</span> <span class="keyword">do</span> </div><div class="line">                t_now[#t_now + <span class="number">1</span>] = <span class="number">0</span></div><div class="line">                <span class="comment">--if #t_now &lt; 10 then print(#t_now) end</span></div><div class="line">            <span class="keyword">end</span></div><div class="line">            <span class="keyword">local</span> t_now_now = &#123;&#125;</div><div class="line">            <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t_now) </div><div class="line">                <span class="keyword">do</span> <span class="keyword">if</span> v == <span class="number">1</span> <span class="keyword">then</span> t_now_now[#t_now_now+<span class="number">1</span>] = a[i] <span class="keyword">end</span> </div><div class="line">            <span class="keyword">end</span></div><div class="line">            t_now = <span class="keyword">nil</span></div><div class="line">            <span class="comment">--控制</span></div><div class="line">            <span class="keyword">if</span> #t_now_now == n <span class="keyword">then</span></div><div class="line">                t[#t+<span class="number">1</span>] = t_now_now</div><div class="line">            <span class="keyword">end</span></div><div class="line">            <span class="comment">--print(inspect(t_now_now),i)</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">        <span class="keyword">return</span> t</div><div class="line">        <span class="comment">--printResult(a,t)</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">permutations</span><span class="params">(a,n)</span></span></div><div class="line">        <span class="keyword">local</span> t = solve(a,n)</div><div class="line">        <span class="keyword">local</span> i = <span class="number">1</span></div><div class="line">        <span class="keyword">local</span> len = #t</div><div class="line">        <span class="keyword">local</span> co = <span class="built_in">coroutine</span>.create(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> permgen(t[i],n) <span class="keyword">end</span>)</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">                <span class="keyword">local</span> code,res = <span class="built_in">coroutine</span>.resume(co)</div><div class="line">                <span class="keyword">if</span> res == <span class="keyword">nil</span> <span class="keyword">then</span> </div><div class="line">                    i = i + <span class="number">1</span></div><div class="line">                    <span class="keyword">if</span> i &gt; #t <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">end</span></div><div class="line">                    co = <span class="built_in">coroutine</span>.create(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> permgen(t[i],n) <span class="keyword">end</span>)</div><div class="line">                    code,res = <span class="built_in">coroutine</span>.resume(co)</div><div class="line">                <span class="keyword">end</span></div><div class="line">                <span class="keyword">return</span> res</div><div class="line">            <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">permgen</span><span class="params">(a,n)</span></span></div><div class="line">        n = n <span class="keyword">or</span> #a</div><div class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">then</span></div><div class="line">            <span class="built_in">coroutine</span>.yield(a)</div><div class="line">            <span class="comment">--printResult(a)</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">for</span> i = <span class="number">1</span>,n <span class="keyword">do</span></div><div class="line">                a[n],a[i] = a[i],a[n]</div><div class="line"></div><div class="line">                permgen(a,n<span class="number">-1</span>)</div><div class="line"></div><div class="line">                a[n],a[i] = a[i],a[n]</div><div class="line">            <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printResult</span><span class="params">(a)</span></span></div><div class="line">        <span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span> </div><div class="line">            <span class="comment">--if t[i] == 1 then io.write(a[t[i]]," ") end</span></div><div class="line">            <span class="built_in">io</span>.write(a[i],<span class="string">" "</span>)</div><div class="line">        <span class="keyword">end</span></div><div class="line">        <span class="built_in">io</span>.write(<span class="string">"\n"</span>)</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> permutations(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,<span class="number">3</span>) <span class="keyword">do</span></div><div class="line">        <span class="comment">--sprintResult(p)</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><h3 id="day10（反射）"><a href="#day10（反射）" class="headerlink" title="day10（反射）"></a>day10（反射）</h3><p>老实说我没什么印象了<br>hook还有一点印象ww</p><h4 id="笔记-4"><a href="#笔记-4" class="headerlink" title="笔记"></a>笔记</h4><p>改进了getvarvalue使之可以处理协程，见下，但是必须要传我现在这个协程进去。不过想想也是必须的不是嘛（。<br>改值这居然有坑等着我，就当修改global变量的时候取_ENV之后居然是直接出上值的。感觉我是强行修的。不过似乎，也许只有这一种情况吧。</p><p>第三题又没看懂：是要我做一个随时调用每次调用都会显示当前函数内所有可见变量还是说参数里带函数名的去找?<br>有点类似离线还是在线的意思，就我当前这体感来说，debug都是离线的。</p><p>mgj这几个题读起来都费劲。<br>第四题：<br>「该函数在调用debug.debug函数的词法定界中运行指定的命令」<br>what the fuck<br>在debug.debug的词法定界里跑指定的函数。<br>根据提示的话，这里应该是用__index元方法=getvarvalue得出的某个upvalue表这样，简单的复习了一下词法定界，感觉没什么问题。upvalue的upvalue其实在upvalue里就是普通变量而已（针对我的某个疑惑）</p><p>好挫败啊，昨天和今天的基本上都没弄懂。<br>昨天的垃圾分类器马马虎虎根本不知所以，今天协程反射重拳出击我人都打傻了。</p><p>注意到这个25.3是 返回 一个表，那么应当是在线的了。</p><p>我一开始想写的是直接扫描到我这个函数处在的位置的所有可用（见）变量，但是好像做不到。我不知道怎么获取到我调用这个的位置。比如traceback是显示栈范围内的变量，原getvalue是指定变量名搜索，我们现在的需求是找到当前范围内的可见变量。一个想法是传进我当前函数名。但是这样肯定不够智能。一个可选的操作是用钩子？调用这个函数的时候返回，而调用这个函数之前一直记录直到分成两种情况：当前函数在这个函数里，不在（在另一个外层函数里），不过上下层其实分析不出来，总不能每次都来一个getlocal跑个level出来吧，这么麻烦不如传函数名呢还。<br>放弃啦（<br>就传函数名，并且无视掉重名的各种local情况（无非就是表中表，先记录下所有的位置，然后跑循环。懒得弄了）</p><p>我tm惊奇的发现原来的getvalue tmd本来就只能获取到当前位置的变量。我傻了。<br>问题出在这个debug.getinfo(level,”f”).func</p><p>认认真真的读了一下这个getinfo的level的意义：当前getinfo为0，调用getinfo的函数A的层次为1，调用A函数的函数的层次是2，getlocal同理，所以默认从2的local找起就是此理。<br>这里要纠正一个思维上的误区：getinfo找到所有当前层次的函数，不，只会找到调用getinfo当前这个函数栈内的层层函数。<br>懂了吗（？<br>我佛了，当时是怎么写出协程版本的getvalue的。。。。估计就照抄来的：为什么level-1呢，就是要直接获取第一层的函数：因为这时候有协程参数，会直接进协程这个函数体内（如果有？必须有吧？）</p><p>emmm，我有很多发现。<br>比如如果我放到迭代器里，会多出好几个层次的表，而且都是loc的，loc的loc又包含一个新的表，而且有迭代专属的几个变量，是很好的分析材料（。<br>单独放的时候，不知道为什么打印数据用的inspect会被加进表里。还是放进的loc表，说明是个隐藏的局部变量？藏在每个层次里？有待深究，不过意义不大。</p><p>upvalue里有一个_ENV，boom</p><p>大概明了的一点就是upvalue只在使用之后才会成为upvalue，然后就算你放到了一个函数里面，调用的地方还是会使得整个值发生变化<br>具体来说就是：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> t = <span class="number">11</span></div><div class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line"><span class="keyword">local</span> u = <span class="number">111</span></div><div class="line">t = t + <span class="number">1</span></div><div class="line"><span class="keyword">local</span> ans = getvarvalue()</div><div class="line"><span class="keyword">return</span> ans</div><div class="line"></div><div class="line"><span class="comment">---&gt; loc:n=u,v=111;upv:n=t,v=12;</span></div><div class="line"></div><div class="line"><span class="keyword">local</span> t = <span class="number">11</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">qq</span><span class="params">()</span></span></div><div class="line"><span class="keyword">local</span> u = <span class="number">111</span></div><div class="line">t = t +<span class="number">1</span></div><div class="line"><span class="keyword">return</span> getvarvalue()</div><div class="line"></div><div class="line">ans = qq()</div><div class="line"></div><div class="line"><span class="comment">---&gt;loc:n = t,v = 12;n = "it"（这是另一个local函数),v = function 3; n = "qq,v = function 4；upv:nil</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">local</span> t = <span class="number">11</span></div><div class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line"><span class="keyword">local</span> u = <span class="number">111</span></div><div class="line">t = t + <span class="number">1</span></div><div class="line"><span class="built_in">print</span>(inspect(getvarvalue()))</div><div class="line"></div><div class="line"><span class="comment">---&gt; loc: n = u, v = 111;n = "(*temporary)", v = function 1;n = "(*temporary)", v = &lt;1&gt;&#123;KEY = inspect.KEY......&#125;</span></div></pre></td></tr></table></figure></p><p>这里可能忽略了一些引号，但不是重点。重点在于三种使用在逻辑上我认为是等效的，但其实不然。</p><p>其实作为迭代器里的return会出现更加难以捉摸的结果，不过我已经不想动了。</p><p>函数还能更改的地方在于不断up level，找到up level之后的值扔进新的表里做层次递进，这样比单纯的用upvalue好多了（体验过这乱七八糟不靠谱之后）<br>不想整活了，留个坑，以后填。</p><p>26章居然就是网上一篇资料的原文出处，我傻了。事到如今又看了点资料，感觉我对协程是有理解了，但是我对怎么写还很模糊。<br>另一个感慨就是要多学点底层的东西。<br>回过头来看这个24.5，能否基于它来跑多线程?可以。修改？把running给夜改了，改成传参的方式可能好一点，方便调用。</p><p>想跑一下26的代码都么得，难过。环境啊qaq</p><p>盲猜一下24.4的代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getline</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> co = <span class="built_in">coroutine</span>.running()</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">local</span> callback = <span class="function"><span class="keyword">function</span><span class="params">(l)</span></span> <span class="built_in">coroutine</span>.resume(co,l)<span class="keyword">end</span> </div><div class="line">        lib.readline(stream,callback)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">coroutine</span>.yield(co)</div><div class="line">    <span class="keyword">end</span> </div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> getline(inp) <span class="keyword">do</span> </div><div class="line">    ...</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>这难度跨越真就不讲道理啊。<br>编写一个允许脚本限制其lua状态能够使用的总内存大小的库。设置自己的内存分配函数，检查总量。<br>初步考虑是newstate调用自己写的分配函数。具体还要多构思一些。</p><h4 id="修改getvarvalue"><a href="#修改getvarvalue" class="headerlink" title="修改getvarvalue"></a>修改getvarvalue</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> <span class="comment">--first try no need to see</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getsetvalue</span><span class="params">(name,val,level,isenv)</span></span></div><div class="line">        <span class="keyword">local</span> value </div><div class="line">        <span class="keyword">local</span> found = <span class="keyword">false</span></div><div class="line">        level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></div><div class="line">        <span class="keyword">local</span> pre_value</div><div class="line">        <span class="keyword">for</span> i = <span class="number">1</span>,<span class="built_in">math</span>.huge <span class="keyword">do</span> </div><div class="line">            <span class="keyword">local</span> n,v = <span class="built_in">debug</span>.getlocal(level,i)</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></div><div class="line">            <span class="keyword">if</span> n == name <span class="keyword">then</span></div><div class="line">                found = <span class="keyword">true</span></div><div class="line">                pre_value = v</div><div class="line">                <span class="built_in">debug</span>.setlocal(level,i,val)</div><div class="line">                _,value = <span class="built_in">debug</span>.getlocal(level,i)</div><div class="line">            <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">        <span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">"local"</span>, pre_value,value <span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">local</span> func = <span class="built_in">debug</span>.getinfo(level,<span class="string">"f"</span>).func</div><div class="line">        <span class="keyword">for</span> i = <span class="number">1</span>,<span class="built_in">math</span>.huge <span class="keyword">do</span></div><div class="line">            <span class="keyword">local</span> n,v = <span class="built_in">debug</span>.getupvalue(func,i)</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></div><div class="line">            <span class="keyword">if</span> n == name <span class="keyword">then</span> </div><div class="line">                <span class="keyword">if</span>(n == <span class="string">"_ENV"</span>) <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,<span class="keyword">nil</span>,v <span class="keyword">end</span></div><div class="line">                <span class="built_in">debug</span>.setupvalue(func,i,val)</div><div class="line">                <span class="keyword">local</span> temp = v</div><div class="line">                _,v = <span class="built_in">debug</span>.getupvalue(func,i)</div><div class="line">                <span class="keyword">return</span> <span class="string">"upvalue"</span>,temp,v </div><div class="line">            <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> isenv <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">"noenv"</span> <span class="keyword">end</span></div><div class="line"></div><div class="line">        <span class="keyword">local</span> _,_,env = getsetvalue(<span class="string">"_ENV"</span>,val,level,<span class="keyword">true</span>)</div><div class="line">        <span class="keyword">if</span> env <span class="keyword">then</span> </div><div class="line">            <span class="keyword">local</span> value = env[name]</div><div class="line">            env[name] = val</div><div class="line">            <span class="keyword">return</span> <span class="string">"global"</span>,value,env[name]</div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="keyword">return</span> <span class="string">"no env"</span> </div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">local</span> a = <span class="number">11</span></div><div class="line">    b = <span class="number">12</span></div><div class="line">    <span class="built_in">print</span>(getsetvalue(<span class="string">"a"</span>,<span class="number">14</span>))</div><div class="line">    <span class="built_in">print</span>(getsetvalue(<span class="string">"b"</span>,<span class="string">"nzk"</span>))</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">do</span> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getvarvalue</span><span class="params">(name,level,isenv,co)</span></span></div><div class="line">        <span class="keyword">local</span> value </div><div class="line">        <span class="keyword">local</span> found = <span class="keyword">false</span></div><div class="line">        level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> co <span class="keyword">then</span></div><div class="line">            level = level - <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> i = <span class="number">1</span>,<span class="built_in">math</span>.huge <span class="keyword">do</span> </div><div class="line">                <span class="keyword">local</span> n,v = <span class="built_in">debug</span>.getlocal(co,level,i)</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></div><div class="line">                <span class="keyword">if</span> n == name <span class="keyword">then</span></div><div class="line">                    value = v</div><div class="line">                    found = <span class="keyword">true</span></div><div class="line">                <span class="keyword">end</span></div><div class="line">            <span class="keyword">end</span></div><div class="line">            <span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">"local"</span>, value <span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">local</span> func = <span class="built_in">debug</span>.getinfo(co,level,<span class="string">"f"</span>).func</div><div class="line">            <span class="keyword">for</span> i = <span class="number">1</span>,<span class="built_in">math</span>.huge <span class="keyword">do</span></div><div class="line">                <span class="keyword">local</span> n,v = <span class="built_in">debug</span>.getupvalue(func,i)</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></div><div class="line">                <span class="keyword">if</span> n == name <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">"upvalue"</span> ,v <span class="keyword">end</span></div><div class="line">            <span class="keyword">end</span></div><div class="line">            </div><div class="line">            <span class="keyword">if</span> isenv <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">"noenv"</span> <span class="keyword">end</span></div><div class="line"></div><div class="line">            <span class="keyword">local</span> _,env = getvarvalue(<span class="string">"_ENV"</span>,level,<span class="keyword">true</span>,co)</div><div class="line">            <span class="keyword">if</span> env <span class="keyword">then</span> </div><div class="line">                <span class="keyword">return</span> <span class="string">"global"</span>,env[name]</div><div class="line">            <span class="keyword">else</span> </div><div class="line">                <span class="keyword">return</span> <span class="string">"no env"</span> </div><div class="line">            <span class="keyword">end</span></div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="keyword">for</span> i = <span class="number">1</span>,<span class="built_in">math</span>.huge <span class="keyword">do</span> </div><div class="line">                <span class="keyword">local</span> n,v = <span class="built_in">debug</span>.getlocal(level,i)</div><div class="line">                <span class="comment">--print("---",n,v,isenv,"---")</span></div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></div><div class="line">                <span class="keyword">if</span> n == name <span class="keyword">then</span></div><div class="line">                    value = v</div><div class="line">                    found = <span class="keyword">true</span></div><div class="line">                <span class="keyword">end</span></div><div class="line">            <span class="keyword">end</span></div><div class="line">            <span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">"local"</span>, value <span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">local</span> func = <span class="built_in">debug</span>.getinfo(level,<span class="string">"f"</span>).func</div><div class="line">            <span class="built_in">print</span>(func)</div><div class="line">            <span class="keyword">for</span> i = <span class="number">1</span>,<span class="built_in">math</span>.huge <span class="keyword">do</span></div><div class="line">                <span class="keyword">local</span> n,v = <span class="built_in">debug</span>.getupvalue(func,i)</div><div class="line">                <span class="comment">--print("---",n,v,isenv,"---")</span></div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></div><div class="line">                <span class="keyword">if</span> n == name <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">"upvalue"</span> ,v <span class="keyword">end</span></div><div class="line">            <span class="keyword">end</span></div><div class="line">            </div><div class="line">            <span class="keyword">if</span> isenv <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">"noenv"</span> <span class="keyword">end</span></div><div class="line"></div><div class="line">            <span class="keyword">local</span> _,env = getvarvalue(<span class="string">"_ENV"</span>,level,<span class="keyword">true</span>)</div><div class="line">            <span class="keyword">if</span> env <span class="keyword">then</span> </div><div class="line">                <span class="keyword">return</span> <span class="string">"global"</span>,env[name]</div><div class="line">            <span class="keyword">else</span> </div><div class="line">                <span class="keyword">return</span> <span class="string">"no env"</span> </div><div class="line">            <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span>    </div><div class="line">    co = <span class="built_in">coroutine</span>.create(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">local</span> x = <span class="number">10</span> fuck = <span class="string">"fuck you you little dummy"</span> <span class="built_in">coroutine</span>.yield() <span class="built_in">error</span>(<span class="string">"some error"</span>) <span class="keyword">end</span>)</div><div class="line">    <span class="built_in">coroutine</span>.resume(co)</div><div class="line">    <span class="built_in">print</span>(getvarvalue(<span class="string">"x"</span>,<span class="keyword">nil</span>,<span class="keyword">nil</span>,co))</div><div class="line">    <span class="built_in">print</span>(getvarvalue(<span class="string">"fuck"</span>,<span class="keyword">nil</span>,<span class="keyword">nil</span>,co))</div><div class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">nowwhat</span><span class="params">(a)</span></span> <span class="keyword">return</span> a + <span class="number">1</span> <span class="keyword">end</span></div><div class="line">    a = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></div><div class="line">        <span class="keyword">local</span> t = <span class="number">1</span> </div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span> </div><div class="line">            <span class="keyword">local</span> e = <span class="number">11</span> </div><div class="line">            <span class="built_in">print</span>(getvarvalue(<span class="string">"t"</span>))</div><div class="line">            <span class="keyword">return</span> t + <span class="number">1</span> </div><div class="line">        <span class="keyword">end</span> </div><div class="line">    <span class="keyword">end</span></div><div class="line">    f = a()</div><div class="line">    f()</div><div class="line">    <span class="comment">--debug.debug()</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><h4 id="获取当前环境中可见变量的getvarvalue"><a href="#获取当前环境中可见变量的getvarvalue" class="headerlink" title="获取当前环境中可见变量的getvarvalue"></a>获取当前环境中可见变量的getvarvalue</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">package</span>.path = <span class="built_in">package</span>.path .. <span class="string">";./?.lua"</span></div><div class="line"><span class="keyword">local</span> inspect = <span class="built_in">require</span>(<span class="string">"inspect"</span>)</div><div class="line"></div><div class="line"><span class="keyword">do</span> </div><div class="line">    a = <span class="number">1</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getvarvalue</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">local</span> level = <span class="number">2</span></div><div class="line">        <span class="keyword">local</span> valtab = &#123;&#125;</div><div class="line">        valtab.loc = &#123;&#125;</div><div class="line">        valtab.upv = &#123;&#125;</div><div class="line">        valtab.gal = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i = <span class="number">1</span>,<span class="built_in">math</span>.huge <span class="keyword">do</span> </div><div class="line">            <span class="keyword">local</span> n,v = <span class="built_in">debug</span>.getlocal(level,i)</div><div class="line">            <span class="comment">--print("---",n,v,isenv,"---")</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></div><div class="line">            valtab.loc[#valtab.loc+<span class="number">1</span>] = &#123;&#125;</div><div class="line">            valtab.loc[#valtab.loc].n = n</div><div class="line">            valtab.loc[#valtab.loc].v = v</div><div class="line">        <span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">local</span> func = <span class="built_in">debug</span>.getinfo(level,<span class="string">"f"</span>).func</div><div class="line">        <span class="keyword">local</span> funcn = <span class="built_in">debug</span>.getinfo(level,<span class="string">"n"</span>).name</div><div class="line">        <span class="built_in">print</span>(funcn)</div><div class="line">        <span class="keyword">for</span> i = <span class="number">1</span>,<span class="built_in">math</span>.huge <span class="keyword">do</span></div><div class="line">            <span class="keyword">local</span> n,v = <span class="built_in">debug</span>.getupvalue(func,i)</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> n ~= <span class="string">"_ENV"</span> <span class="keyword">then</span></div><div class="line">            <span class="comment">--print("---",n,v,isenv,"---")</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></div><div class="line">            valtab.upv[#valtab.upv+<span class="number">1</span>] = &#123;&#125;</div><div class="line">            valtab.upv[#valtab.upv].n = n</div><div class="line">            valtab.upv[#valtab.upv].v = v</div><div class="line">            <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">        </div><div class="line">        <span class="comment">--[[local ENV = _ENV</span></div><div class="line">        for i,v in pairs(ENV) do </div><div class="line">            valtab.gal[#valtab.gal+1] = &#123;&#125;</div><div class="line">            valtab.gal[#valtab.gal].n = i</div><div class="line">            valtab.gal[#valtab.gal].v = v</div><div class="line">        end</div><div class="line">        --]]</div><div class="line">        <span class="keyword">return</span> valtab</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">local</span> t = <span class="number">11</span></div><div class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">it</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">local</span> u = <span class="number">111</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">aa</span><span class="params">()</span></span></div><div class="line">            u = u + <span class="number">1</span></div><div class="line">            a = a + <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> u &gt;= <span class="number">120</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">end</span></div><div class="line">            <span class="keyword">return</span> getvarvalue()</div><div class="line">        <span class="keyword">end</span></div><div class="line">        <span class="keyword">return</span> aa</div><div class="line">    <span class="keyword">end</span> </div><div class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">qq</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">local</span> u = <span class="number">111</span></div><div class="line">        t = t + <span class="number">1</span></div><div class="line">        <span class="keyword">local</span> ans = getvarvalue()</div><div class="line">        <span class="keyword">return</span> ans</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> it() <span class="keyword">do</span> </div><div class="line">        <span class="comment">--print(inspect(u))</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    ans = qq()</div><div class="line">    f = it()</div><div class="line">    <span class="built_in">print</span>(inspect(ans))</div><div class="line">    <span class="comment">--ans = f()</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>后面还有关于接口调用一类的，不过…下篇见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一下关于lua的笔记&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="lua" scheme="http://oodtoodt.github.io/categories/lua/"/>
    
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="lua" scheme="http://oodtoodt.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua笔记整理(1)</title>
    <link href="http://oodtoodt.github.io/2020/01/13/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86(1)/"/>
    <id>http://oodtoodt.github.io/2020/01/13/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/lua%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86(1)/</id>
    <published>2020-01-13T02:54:01.000Z</published>
    <updated>2020-01-13T07:53:08.324Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下关于lua的笔记</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h3><h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><p>type返回的是string<br>p就是 <em> 2^n,e就是 </em> 10^n<br>基本类型是值传递，只有表是引用传递 草我人傻了<br>字符串是常量（？)，且字符串无法迭代 草我人傻了</p><p>我有一种寻最优解的习惯，是c的坏习惯，在脚本中其实不用那么在意的。【【都tm脚本了还那么在意效率干啥</p><p>非常神秘的卡在读\n上<br>为什么遇到\n要后退两格才能正确处理?是\r\n的问题吗？搞了将近一个小时没搞明白</p><h3 id="day2，3（string）"><a href="#day2，3（string）" class="headerlink" title="day2，3（string）"></a>day2，3（string）</h3><h4 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h4><p>这个函数式编程很神奇<br>但是我数学不咋地，没看懂这个画蛾眉月的过程：先画圆，求一个增量平移，然后求一个差集，就是月亮了，最后从-1,1映射到n,m文件里<br>过程好理解，扔进公式里就真不懂了233</p><p>这个前置模式我是真没看懂<br>我唯一能够想到的解释就是在两个%f[char-set]之间的匹配是严格的</p><p>这个嵌套递归格式转换器有东西</p><p>string.find可以有第三个返回值，但是必须加括号匹配（即返回的其实是捕获、其他的应该同理。<br>真想要那个找到的字符串不如直接match<br>[]自主字符集，()捕获</p><p>注意都是常量嗯</p><p>对于”\0\1”，这是两个字符，不需要单独的\判断处理。对于”\”可以<br>所以对于书里那个”\\(.)”的匹配深表怀疑，不知道怎么回事。<br>it seems that code and decode have no use<br>有没有都一样 可能以前的时候可以当两个字符获取？现在就一个了。<br>（注，最后一段是我代码写错了产生了误解，不用看）<br>指对于\\(.)这种带斜杠转义（比如后面跟引号）的字符串进行匹配时先code再decode可以进行预处理以方便转义引号。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> kk = <span class="string">[[follows a typical string:"This is \"great\"!".]]</span></div><div class="line">kk = <span class="built_in">string</span>.gsub(kk,<span class="string">'".-"'</span>,<span class="built_in">string</span>.upper)<span class="comment">--是问题的</span></div></pre></td></tr></table></figure></p><p>[]中逻辑是或，指集合里面任意皆可，()的匹配就是完全匹配</p><h4 id="预置的字符分类"><a href="#预置的字符分类" class="headerlink" title="预置的字符分类"></a>预置的字符分类</h4><ul><li>.  –&gt;  任意字符 &nbsp;</li><li>%a –&gt;  字母 &nbsp;</li><li>%c –&gt;  控制字符 &nbsp;</li><li>%d –&gt;  数字 &nbsp;</li><li>%g –&gt;  除空格外的可打印字符 &nbsp;</li><li>%l –&gt;  小写字母 &nbsp;</li><li>%p –&gt;  标点符号 &nbsp;</li><li>%s –&gt;  空白字符 &nbsp;</li><li>%u –&gt;  大写字母 &nbsp;</li><li>%w –&gt;  字母和数字! &nbsp;</li><li>%x –&gt;  十六进制数字 &nbsp;</li></ul><hr><ul><li>+ –&gt; 一次或多次</li><li>* –&gt; 零次或多次</li><li>- –&gt; 零次或多次（最小匹配）</li><li>? –&gt; 零次或一次</li></ul><hr><h4 id="f的蜜汁使用"><a href="#f的蜜汁使用" class="headerlink" title="%f的蜜汁使用"></a>%f的蜜汁使用</h4><p>前置模式%f，我的理解就是匹配前一个字符在[char-set]外，后一个字符在[char-set]内的中间空位（前置）。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> s = <span class="string">"the anthem is the theme aathe what   tx  the  "</span></div><div class="line"><span class="built_in">print</span>((<span class="built_in">string</span>.gsub(s,<span class="string">"%f[%w]the%f[%W]"</span>,<span class="string">"one"</span>)))</div><div class="line"><span class="comment">--one anthem is one theme aathe what   tx  one</span></div></pre></td></tr></table></figure></p><h4 id="split分割字符串-string-pattern"><a href="#split分割字符串-string-pattern" class="headerlink" title="split分割字符串(string,pattern)"></a>split分割字符串(string,pattern)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">split</span><span class="params">(str,par)</span></span></div><div class="line">    <span class="keyword">local</span> a = &#123;&#125;</div><div class="line">   <span class="comment">--[[</span></div><div class="line">       for s in string.gmatch(str,".-%f["..par.."]") do--(.-%f[ ])</div><div class="line">       table.insert(a,s)</div><div class="line">    end</div><div class="line">    ]]</div><div class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">string</span>.gmatch(str,<span class="string">"[^"</span>..par..<span class="string">"]+"</span>) <span class="keyword">do</span><span class="comment">--[^ ]$</span></div><div class="line">        <span class="built_in">table</span>.insert(a,s)</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></div><div class="line">        <span class="built_in">print</span>(i,v)</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><h4 id="transliterate-string-table-将表按a-b修正字符串"><a href="#transliterate-string-table-将表按a-b修正字符串" class="headerlink" title="transliterate(string,table)将表按a = b修正字符串"></a>transliterate(string,table)将表按a = b修正字符串</h4><p>牵扯到转义字符，注意使用。<br>就跟lua的转义符是反斜杠一样，%是转义字符，注意他们。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">transliterate</span><span class="params">(str,tab)</span></span></div><div class="line">    <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></div><div class="line">        a = <span class="built_in">string</span>.gsub(a,<span class="string">"(%W)"</span>,<span class="string">"%%%1"</span>)</div><div class="line">        b = <span class="built_in">string</span>.gsub(b,<span class="string">"%%"</span>,<span class="string">"%%%%"</span>)</div><div class="line">        <span class="built_in">print</span>(a,b)</div><div class="line">        <span class="keyword">if</span>(b == <span class="keyword">false</span>) <span class="keyword">then</span> </div><div class="line">            str = <span class="built_in">string</span>.gsub(str,a,<span class="string">""</span>)</div><div class="line">        <span class="keyword">else</span></div><div class="line">            str = <span class="built_in">string</span>.gsub(str,a,b)</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="built_in">print</span>(str)</div><div class="line"><span class="keyword">end</span></div><div class="line">transliterate(<span class="string">"hello world fuck you !!!!"</span>,&#123;[<span class="string">"o"</span>] = <span class="string">"%1"</span>,[<span class="string">"!"</span>] = <span class="string">"h"</span>,[<span class="string">" "</span>] = <span class="number">101</span>&#125;)</div><div class="line"><span class="comment">--hell%1101w%1rld101fuck101y%1u101hhhh</span></div><div class="line">transliterate(<span class="string">"hello world fuck you !!!!"</span>,&#123;[<span class="string">"o"</span>] = <span class="string">"1"</span>,[<span class="string">"l"</span>] = <span class="string">"h"</span>&#125;)</div><div class="line"><span class="comment">--hehh1 w1rhd fuck y1u !!!!</span></div></pre></td></tr></table></figure></p><h3 id="day4（load和序列化）"><a href="#day4（load和序列化）" class="headerlink" title="day4（load和序列化）"></a>day4（load和序列化）</h3><p>其实day3悄咪咪写了个dijkstra，但是实在是太丑陋了所以…只是无限加深了一个印象：table是引用，普通值都是拷贝。<br>另外呢，我的dijkstra也写得蛮有问题，照抄都不会的（捂脸），太菜了</p><h4 id="笔记-2"><a href="#笔记-2" class="headerlink" title="笔记"></a>笔记</h4><p>就单纯的这个序列化而言，简单的键是没有问题的，但是如果键是table，那么可能要重新设计整个函数，尤其是递归的逻辑我还是不太搞得清楚</p><p>然而$表[表] = 表$的构造器很反直觉啊，完全不知道是要怎么</p><p>学会了f5默认文件2333 是json哒</p><p>然后大概把这个东西写出来了，最后那题真不想写了。带循环的这套逻辑，回头补吧。</p><p>写了个stringrep_n 的load，对load感到困惑。<br>成了，经过几个小时的实验，证明了一件事:不要在load里面写出function-end，不会认的。或者说，load会自动添加一个function-end的壳子，而且是必然添加。<br>写到这里劳资终于明白了为什么套一层不会出结果了，因为这样就成了闭包的非匿名形式，没有最后的return，这个函数就只能是个自闭的函数。<br>我佛了。<br>不过还好，弄得清清楚楚明明白白也是好事。</p><h4 id="很怪的serialize"><a href="#很怪的serialize" class="headerlink" title="很怪的serialize"></a>很怪的serialize</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="keyword">local</span> num = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">serialize</span><span class="params">(o,flag)</span></span></div><div class="line">        <span class="keyword">local</span> t = <span class="built_in">type</span>(o)</div><div class="line">        <span class="keyword">local</span> temp</div><div class="line">        flag = flag <span class="keyword">or</span> <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> t == <span class="string">"number"</span> <span class="keyword">or</span> t == <span class="string">"string"</span> <span class="keyword">or</span> t == <span class="string">"boolean"</span> <span class="keyword">or</span> t == <span class="string">"nil"</span> <span class="keyword">then</span></div><div class="line">            <span class="keyword">return</span> <span class="built_in">string</span>.format(<span class="string">"%q"</span>,o)</div><div class="line">        <span class="keyword">elseif</span> t == <span class="string">"table"</span> <span class="keyword">then</span></div><div class="line">            num = num + <span class="number">1</span></div><div class="line">            temp = <span class="built_in">string</span>.rep(<span class="string">" "</span>,num*<span class="number">4</span>)</div><div class="line">            <span class="keyword">if</span> flag == <span class="number">0</span> <span class="keyword">then</span> <span class="built_in">io</span>.write(<span class="string">"&#123;\n"</span>)</div><div class="line">            <span class="keyword">elseif</span> flag == <span class="number">1</span> <span class="keyword">then</span> </div><div class="line">              <span class="comment">--  num = num + 1</span></div><div class="line">                <span class="comment">--temp = string.rep(" ",num*4)</span></div><div class="line">                <span class="keyword">local</span> te = <span class="built_in">string</span>.rep(<span class="string">" "</span>,num*<span class="number">4</span><span class="number">-8</span>)<span class="comment">--?</span></div><div class="line">                <span class="built_in">io</span>.write(<span class="string">""</span> ..te.. <span class="string">"&#123;\n"</span>)</div><div class="line">            <span class="keyword">end</span></div><div class="line">            <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(o) <span class="keyword">do</span></div><div class="line">                <span class="keyword">if</span> <span class="built_in">type</span>(k) == <span class="string">"table"</span> <span class="keyword">then</span> </div><div class="line">                    <span class="built_in">io</span>.write(temp..<span class="string">" "</span>)</div><div class="line">                    serialize(k,<span class="number">1</span>)</div><div class="line">                    <span class="built_in">io</span>.write(<span class="string">" = "</span>)</div><div class="line">                    <span class="comment">--num = num - 1</span></div><div class="line">                <span class="keyword">elseif</span> <span class="built_in">type</span>(k) == <span class="string">"string"</span> <span class="keyword">then</span> </div><div class="line">                    <span class="built_in">io</span>.write(temp..<span class="string">" "</span>,<span class="built_in">string</span>.format(<span class="string">" [%s] = "</span>,serialize(k)))</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="built_in">io</span>.write(temp..<span class="string">" "</span>, k, <span class="string">" = "</span>)</div><div class="line">                <span class="keyword">end</span></div><div class="line">                <span class="built_in">io</span>.write(serialize(v))</div><div class="line"></div><div class="line">                <span class="built_in">io</span>.write(<span class="string">",\n"</span>)</div><div class="line">            <span class="keyword">end</span></div><div class="line">            num = num<span class="number">-1</span></div><div class="line">            temp = <span class="built_in">string</span>.rep(<span class="string">" "</span>,num*<span class="number">4</span>)</div><div class="line">            <span class="keyword">if</span> temp ~= <span class="string">""</span> <span class="keyword">then</span> temp = temp..<span class="string">" "</span> <span class="keyword">end</span></div><div class="line">            <span class="built_in">io</span>.write(temp..<span class="string">"&#125;"</span>)</div><div class="line">            </div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">error</span>(<span class="string">"cannot serialize a "</span>..<span class="built_in">type</span>(o))</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    <span class="keyword">local</span> uu = &#123;&#125;</div><div class="line">    <span class="keyword">local</span> u = &#123;c = <span class="string">"?"</span>,d = <span class="string">"e"</span>&#125;</div><div class="line">    uu[u] = &#123;a = <span class="string">"1"</span>,b = <span class="string">"2"</span>&#125;</div><div class="line">    <span class="comment">--serialize(&#123;a = 12, b = "Lua", key = 'another "one"', uu&#125;)</span></div><div class="line"></div><div class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(&#123;a=<span class="number">12</span>&#125;))</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><h4 id="stringrep-n的正确版本"><a href="#stringrep-n的正确版本" class="headerlink" title="stringrep_n的正确版本"></a>stringrep_n的正确版本</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">stringrep_n</span><span class="params">(n)</span></span> </div><div class="line">        <span class="keyword">local</span> x = <span class="string">""</span>;</div><div class="line">        <span class="keyword">local</span> u = <span class="string">""</span></div><div class="line">        u = u..<span class="string">"local x = \"\";\n\tlocal s = ...;\n\t"</span></div><div class="line">        <span class="keyword">while</span> n ~= <span class="number">0</span> <span class="keyword">do</span></div><div class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">then</span> </div><div class="line">                <span class="comment">--x = x .. s;</span></div><div class="line">                u = u .. <span class="string">"x = x .. s;\n\t"</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="comment">--s = s .. s;</span></div><div class="line">            <span class="keyword">end</span></div><div class="line">            n = n // <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></div><div class="line">            u = u .. <span class="string">"s = s .. s;\n\t"</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">        u = u..<span class="string">"return x;\n\t"</span></div><div class="line">        <span class="keyword">return</span> u;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="built_in">print</span>(stringrep_n(<span class="number">7</span>))</div><div class="line">    <span class="keyword">local</span> stringrep_7 = <span class="built_in">load</span>(stringrep_n(<span class="number">7</span>))</div><div class="line">    <span class="keyword">local</span> s = stringrep_7(<span class="string">"fku\n"</span>)</div><div class="line">    <span class="built_in">print</span>(s)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">--例子就看这个好了</span></div><div class="line"><span class="comment">--load的捕捉是靠...的</span></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="keyword">local</span> a = <span class="string">"function Add(a,b) return a+b end return Add(...)"</span></div><div class="line">    <span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">load</span>(a))</div><div class="line">    <span class="keyword">local</span> F = <span class="function"><span class="keyword">function</span> <span class="params">(aa,bb)</span></span> <span class="keyword">return</span> aa+bb <span class="keyword">end</span></div><div class="line">    <span class="built_in">print</span>(F(<span class="number">1</span>,<span class="number">1</span>))</div><div class="line">    <span class="built_in">print</span>(f(<span class="number">2</span>,<span class="number">3</span>))</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><h3 id="day5（迭代器）"><a href="#day5（迭代器）" class="headerlink" title="day5（迭代器）"></a>day5（迭代器）</h3><h4 id="笔记-3"><a href="#笔记-3" class="headerlink" title="笔记"></a>笔记</h4><p>看起来，这个for无状态循环迭代非常严格，至少应当把控制变量当成一个upvalue而且必须作为返回值否则可能获取不到新值<br>无状态迭代器：<br>function (s)<br>    return next,s,nil–调用next(s,nil)，nil是控制变量初值，s是不可变值<br>end</p><p>真正的迭代器：就是写个大函数，参数用函数</p><h4 id="无状态迭代器"><a href="#无状态迭代器" class="headerlink" title="无状态迭代器"></a>无状态迭代器</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fromto</span><span class="params">(endtable,now)</span></span></div><div class="line">        <span class="keyword">local</span> step_len = endtable.step_len</div><div class="line">        <span class="keyword">local</span> Endpos = endtable.en</div><div class="line">        <span class="keyword">if</span> now &gt;= Endpos <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></div><div class="line">        now = now + step_len</div><div class="line">        <span class="keyword">return</span> now</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fromto</span><span class="params">(star,endpos,step_len)</span></span></div><div class="line">        <span class="keyword">local</span> endtable = &#123;&#125;</div><div class="line">        endtable.en = endpos</div><div class="line">        endtable.step_len = step_len</div><div class="line">        <span class="keyword">return</span> Fromto,endtable,star-step_len</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">local</span> n = <span class="number">-20</span>;<span class="keyword">local</span> m = <span class="number">0</span>;<span class="keyword">local</span> step_len = <span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fromto(n,m,step_len) <span class="keyword">do</span> </div><div class="line">        <span class="built_in">print</span>(i)</div><div class="line">        <span class="comment">--print(Q[i])</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><h4 id="遍历指定集合的所有子集"><a href="#遍历指定集合的所有子集" class="headerlink" title="遍历指定集合的所有子集"></a>遍历指定集合的所有子集</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">substr</span><span class="params">(str)</span></span></div><div class="line">        <span class="keyword">local</span> s = &#123;&#125;</div><div class="line">        <span class="keyword">local</span> i = <span class="number">1</span></div><div class="line">        <span class="keyword">local</span> j = <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">            j = j + <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> j &gt; #str <span class="keyword">then</span></div><div class="line">                j = i+<span class="number">1</span></div><div class="line">                i = i + <span class="number">1</span></div><div class="line">            <span class="keyword">end</span></div><div class="line">            <span class="keyword">if</span> j &gt; #str <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">end</span></div><div class="line">            <span class="keyword">return</span> <span class="built_in">string</span>.sub(str,i,j)</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="keyword">local</span> s = <span class="string">"nzk"</span></div><div class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> substr(s) <span class="keyword">do</span></div><div class="line">        <span class="built_in">print</span>(v)</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>有点长了，我们下篇见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一下关于lua的笔记&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="lua" scheme="http://oodtoodt.github.io/categories/lua/"/>
    
    
      <category term="company" scheme="http://oodtoodt.github.io/tags/company/"/>
    
      <category term="lua" scheme="http://oodtoodt.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>手撕／算法</title>
    <link href="http://oodtoodt.github.io/2019/10/09/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://oodtoodt.github.io/2019/10/09/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/%E6%89%8B%E6%92%95%EF%BC%8F%E7%AE%97%E6%B3%95/</id>
    <published>2019-10-09T06:12:16.000Z</published>
    <updated>2019-10-14T03:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><del>请不要放太多精力在这。如果放，就看那些板子的东西而不是看思路的东西。</del></p><p>请仔细看！</p><a id="more"></a><h4 id="大数据问题"><a href="#大数据问题" class="headerlink" title="大数据问题"></a>大数据问题</h4><p>1、分治 一半非最优，但总是可行。包括归并<br>2、哈希 粗暴且有效，就是耗内存，一种用法是哈希后分到不同机器<br>3、bit 布隆过滤器就是bit的扩展<br>4、堆 topk问题的解决方案</p><p>另外考虑：<br>trie<br>bitmap<br>并查集<br>MapReduce<br>倒排索引</p><h4 id="LRU缓存模拟"><a href="#LRU缓存模拟" class="headerlink" title="LRU缓存模拟"></a>LRU缓存模拟</h4><p>抄个LRU的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> CacheNode &#123;</div><div class="line">  <span class="keyword">int</span> key;</div><div class="line">  <span class="keyword">int</span> value;</div><div class="line">  CacheNode *pre, *next;</div><div class="line">  CacheNode(<span class="keyword">int</span> k, <span class="keyword">int</span> v) : key(k), value(v), pre(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> LRUCache&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">int</span> size;                     <span class="comment">// Maximum of cachelist size.</span></div><div class="line">  CacheNode *head, *tail;</div><div class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, CacheNode *&gt; mp;          <span class="comment">// Use hashmap to store</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LRUCache(<span class="keyword">int</span> capacity)</div><div class="line">  &#123;</div><div class="line">    size = capacity;</div><div class="line">    head = <span class="literal">NULL</span>;</div><div class="line">    tail = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, CacheNode *&gt;::iterator it = mp.find(key);</div><div class="line">    <span class="keyword">if</span> (it != mp.end())</div><div class="line">    &#123;</div><div class="line">      CacheNode *node = it -&gt; second;</div><div class="line">      remove(node);</div><div class="line">      setHead(node);</div><div class="line">      <span class="keyword">return</span> node -&gt; value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, CacheNode *&gt;::iterator it = mp.find(key);</div><div class="line">    <span class="keyword">if</span> (it != mp.end())</div><div class="line">    &#123;</div><div class="line">      CacheNode *node = it -&gt; second;</div><div class="line">      node -&gt; value = value;</div><div class="line">      remove(node);</div><div class="line">      setHead(node);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      CacheNode *newNode = <span class="keyword">new</span> CacheNode(key, value);</div><div class="line">      <span class="keyword">if</span> (mp.size() &gt;= size)</div><div class="line">      &#123;</div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, CacheNode *&gt;::iterator iter = mp.find(tail -&gt; key);</div><div class="line">      remove(tail);</div><div class="line">mp.erase(iter);</div><div class="line">      &#125;</div><div class="line">      setHead(newNode);</div><div class="line">      mp[key] = newNode;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(CacheNode *node)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (node -&gt; pre != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">      node -&gt; pre -&gt; next = node -&gt; next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      head = node -&gt; next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (node -&gt; next != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">      node -&gt; next -&gt; pre = node -&gt; pre;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      tail = node -&gt; pre;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setHead</span><span class="params">(CacheNode *node)</span></span></div><div class="line">  &#123;</div><div class="line">    node -&gt; next = head;</div><div class="line">    node -&gt; pre = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">      head -&gt; pre = node;</div><div class="line">    &#125;</div><div class="line">    head = node;</div><div class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">      tail = head;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="快排代码"><a href="#快排代码" class="headerlink" title="快排代码"></a>快排代码</h4><p>先是partition专属</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = l, j = r + <span class="number">1</span>;</div><div class="line">    T v = nums[l];</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (nums[++i] &lt; v) &amp;&amp; i != r) ;</div><div class="line">        <span class="keyword">while</span> (v &lt; nums[--j]) &amp;&amp; j != l) ;</div><div class="line">        <span class="keyword">if</span> (i &gt;= j)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        swap(nums, i, j);</div><div class="line">    &#125;</div><div class="line">    swap(nums, l, j);</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">select</span><span class="params">(T[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (h &gt; l) &#123;</div><div class="line">        <span class="keyword">int</span> j = partition(nums, l, r);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (j == k) &#123;</div><div class="line">            <span class="keyword">return</span> nums[k];</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) &#123;</div><div class="line">            r = j - <span class="number">1</span>;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            l = j + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nums[k];</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (r &lt;= l)</div><div class="line"><span class="keyword">return</span>;</div><div class="line"><span class="keyword">int</span> j = partition(nums, l, h);</div><div class="line">sort(nums, l, j - <span class="number">1</span>);</div><div class="line">sort(nums, j + <span class="number">1</span>, h);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="堆排代码"><a href="#堆排代码" class="headerlink" title="堆排代码"></a>堆排代码</h4><p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。<br>复杂度O(N)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Heap&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">T[] heap;</div><div class="line"><span class="keyword">int</span> N = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> heap[i]&lt;heap[j];</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        T t = heap[i];</div><div class="line">        heap[i] = heap[j];</div><div class="line">        heap[j] = t;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</div><div class="line">            swap(k / <span class="number">2</span>, k);</div><div class="line">            k = k / <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</div><div class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</div><div class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>))</div><div class="line">                j++;</div><div class="line">            <span class="keyword">if</span> (!less(k, j))</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            swap(k, j);</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable v)</span> </span>&#123;</div><div class="line">        heap[++N] = v;</div><div class="line">        swim(N);</div><div class="line">    &#125;</div><div class="line"><span class="function">T <span class="title">delMax</span><span class="params">()</span> </span>&#123;</div><div class="line">        T max = heap[<span class="number">1</span>];</div><div class="line">        swap(<span class="number">1</span>, N--);</div><div class="line">        heap[N + <span class="number">1</span>] = null;</div><div class="line">        sink(<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> N = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</div><div class="line">            sink(nums, k, N);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</div><div class="line">            swap(nums, <span class="number">1</span>, N--);</div><div class="line">            sink(nums, <span class="number">1</span>, N);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prekmp</span><span class="params">(<span class="keyword">char</span> x[],<span class="keyword">int</span> m,<span class="keyword">int</span> kmpnext[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    j = kmpnext[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">    i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; m)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="number">-1</span> != j &amp;&amp; x[i] != x[j]) j = kmpnext[j];</div><div class="line">        <span class="keyword">if</span>(x[++i] == x[++j]) kmpnext[i] = kmpnext[j];</div><div class="line">        <span class="keyword">else</span> kmpnext[i] = j;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> kmpnext[<span class="number">10010</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp_count</span><span class="params">(<span class="keyword">char</span> x[],<span class="keyword">int</span> m,<span class="keyword">char</span> y[],<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;<span class="comment">//x是模式串，y是主串。</span></div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    prekmp(x,m,kmpnext);</div><div class="line">    i = j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; n)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="number">-1</span> != j &amp;&amp; y[i] != x[j]) j = kmpnext[j];</div><div class="line">        i++;j++;</div><div class="line">        <span class="keyword">if</span>(j &gt;= m)</div><div class="line">        &#123;</div><div class="line">            ans++;</div><div class="line">            j = kmpnext[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="manacher"><a href="#manacher" class="headerlink" title="manacher"></a>manacher</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">110010</span>;</div><div class="line"><span class="keyword">char</span> Ma[Maxn*<span class="number">2</span>];</div><div class="line"><span class="keyword">int</span> Mp[Maxn*<span class="number">2</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</div><div class="line">    Ma[l++] = <span class="string">'$'</span>;</div><div class="line">    Ma[l++] = <span class="string">'#'</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">    &#123;</div><div class="line">        Ma[l++] = s[i];</div><div class="line">        Ma[l++] = <span class="string">'#'</span>;</div><div class="line">    &#125;</div><div class="line">    Ma[l] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>,id = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)</div><div class="line">    &#123;</div><div class="line">        Mp[i] = mx &gt; i ? min(Mp[<span class="number">2</span>*id-i],mx-i) : <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(Ma[i+Mp[i]] == Ma[i-Mp[i]]) Mp[i] ++;</div><div class="line">        <span class="keyword">if</span>(i+Mp[i] &gt; mx)</div><div class="line">        &#123;</div><div class="line">            mx = i + Mp[i];</div><div class="line">            id = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="输入一堆三角形，相连的三角形形成一个岛，求有几个岛"><a href="#输入一堆三角形，相连的三角形形成一个岛，求有几个岛" class="headerlink" title="输入一堆三角形，相连的三角形形成一个岛，求有几个岛"></a>输入一堆三角形，相连的三角形形成一个岛，求有几个岛</h4><p>不会</p><h4 id="用两个栈实现一个队列"><a href="#用两个栈实现一个队列" class="headerlink" title="用两个栈实现一个队列"></a>用两个栈实现一个队列</h4><p>就是全弹的那种。</p><h4 id="给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道-号表示，两球碰撞之后会消失，求所有碰撞时间。"><a href="#给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道-号表示，两球碰撞之后会消失，求所有碰撞时间。" class="headerlink" title="给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道 -号表示，两球碰撞之后会消失，求所有碰撞时间。"></a>给你一个x轴，上面分布着许多小球。小球位置p［i］小球速度v［i］，速度方向也知道 -号表示，两球碰撞之后会消失，求所有碰撞时间。</h4><p>这什么东西？很明显N^2必定可以，这个思想在于只求时间而不在意碰撞的地点。那么如何优化？不会<br>用map来存<time,序号>，来维护动态的最小值。每次用首的time碰撞，序号和序号右边的值消除，右边的右边更新左值，序号的左边更新右值，map里新加入新的一对值。<br>写到这意识到还需要维护某个值左边和右边的值是谁，不过这个蛮好维护的。<br>猜的 具体是不是另说。</time,序号></p><h4 id="一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车"><a href="#一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车" class="headerlink" title="一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车"></a>一条数轴上有很多小车，已知小车的速度，方向，初始位置，问如何求得最早相遇的两个车</h4><p>规律在于必定是相邻的两车相遇，不论速度方向。<br>所以求一遍所有相邻的差就行了</p><h4 id="一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标"><a href="#一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标" class="headerlink" title="一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标"></a>一个无序的数组，如何在下标a和b之间找到值为k的那个数在数组里的下标</h4><p>要求O(1)</p><h4 id="带括号的字符串压缩"><a href="#带括号的字符串压缩" class="headerlink" title="带括号的字符串压缩"></a>带括号的字符串压缩</h4><p>就是3(C2(AB)) = CABABCABABCABAB</p><p>重点还是在括号匹配上。首先记录数字和字符串，维护一个栈用来存放每个括号内的信息，遇到左括号就把当前位置扔进栈里，右括号出栈。当数字后面接的是字母时直接字母倍算，括号则标志后等待出栈之后处理，维护两个字符串，一个维护结果串，一个维护要被倍算的串。注意倍算后栈的位置也要进行变化。</p><h4 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h4><p>1）如果遇到操作数，我们就直接将其输出。</p><p>2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。</p><p>3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。注意，左括号只弹出并不输出。</p><p>4）如果遇到任何其他的操作符，如（“+”， “*”，“（”）等，从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止。弹出完这些元素后，才将遇到的操作符压入到栈中。有一点需要注意，只有在遇到” ) “的情况下我们才弹出” ( “，其他情况我们都不会弹出” ( “。</p><p>5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。 </p><p>如：a+b <em> c+d<br>a输出，+进栈，b输出， </em> 进栈，c输出，读到+，因为栈顶 <em> 优先级高，所以弹出 </em> 并输出，同理下一元素+与+一样所以弹出并输出，然后再读到+压入栈中，d输出，栈不空弹出输出。</p><h4 id="来一个死锁！"><a href="#来一个死锁！" class="headerlink" title="来一个死锁！"></a>来一个死锁！</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">mutex;   <span class="comment">//代表一个全局互斥对象</span></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">A</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    mutex.lock();</div><div class="line">    <span class="comment">//这里操作共享数据</span></div><div class="line">    B();  <span class="comment">//这里调用B方法</span></div><div class="line">    mutex.unlock();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">B</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    mutex.lock();</div><div class="line">    <span class="comment">//这里操作共享数据</span></div><div class="line">    mutex.unlock();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//此时会由于在A、B方法中相互等待unlock而导致死锁。</span></div><div class="line"></div><div class="line">mutex;   <span class="comment">//代表一个全局互斥对象</span></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">A</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    mutex.lock();</div><div class="line">    <span class="comment">//这里操作共享数据</span></div><div class="line">    <span class="keyword">if</span>(.....)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    mutex.unlock();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">      <span class="comment">//由于在if的执行体内直接retun，而没有调用unlock，导致另一个线程再调用A方法就出现死锁。</span></div></pre></td></tr></table></figure><h4 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h4><p>注意是数据流，所以要动态维护。这里维护一个最大堆一个最小堆，奇数次向最小堆，偶数次向最大堆</p><p>为了保证大顶堆比小顶堆都小（试想两个金字塔，交汇即中位数），插入小顶堆时候先放进大顶堆然后拿出里面最大的给小顶堆。</p><p>这里可以用mutiset操作</p><h4 id="二叉树中两点间路径的最大长度"><a href="#二叉树中两点间路径的最大长度" class="headerlink" title="二叉树中两点间路径的最大长度"></a>二叉树中两点间路径的最大长度</h4><p>要么带根就是左右之和，要么不带，那就是左或者右里面带或者不带的最大值，递归即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDist</span><span class="params">(Tree root)</span> </span>&#123; </div><div class="line"><span class="comment">//如果树是空的，则返回 0 </span></div><div class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) </div><div class="line"><span class="keyword">return</span> <span class="number">0</span>; </div><div class="line"><span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>) &#123; </div><div class="line">root-&gt;lm = maxDist(root-&gt;left) + <span class="number">1</span>; </div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>) root-&gt;rm = maxDist(root-&gt;right) + <span class="number">1</span>; </div><div class="line"><span class="comment">//如果以该节点为根的子树中有最大的距离，那就更新最大距离 </span></div><div class="line"><span class="keyword">int</span> sum = root-&gt;rm + root-&gt;lm; </div><div class="line"><span class="keyword">if</span>(sum &gt; max) &#123; </div><div class="line">max = sum;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> root-&gt;rm &gt; root-&gt;lm ? root-&gt;rm : root-&gt;lm; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="二叉树中最大路径和"><a href="#二叉树中最大路径和" class="headerlink" title="二叉树中最大路径和"></a>二叉树中最大路径和</h4><p>其实首先想到的肯定还是lca，感觉上lca也是对的。不过没写。</p><p>然后我有一个印象就是先求离根最远的一个点，然后从这个点开始跑所有的点，求出来的理应最优</p><p>但是我当时在leetcode搓了几个小时没搓出来，让我对这个思路产生了怀疑。可能是里面的负边权有着很大的影响。举个例子，求这个「最远的」点，势必要跑一遍dfs，如果边权全为负，那么跑出来的结果注定是根本身。根本来说只要这条带根的路径是负的，就求不出那个最远的点。</p><p>解法：递归</p><p>转自leetcode：</p><p>二叉树abc，a是根结点（递归中的root），bc是左右子结点（代表其递归后的最优解）。<br>最大的路径，可能的路径情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  a</div><div class="line"> / \</div><div class="line">b   c</div></pre></td></tr></table></figure><p>b + a + c。<br>b + a + a的父结点。<br>a + c + a的父结点。<br>其中情况 1 ，表示如果不联络父结点的情况，或本身是根结点的情况。<br>这种情况是没法递归的，但是结果有可能是全局最大路径和。<br>情况 2 和 3 ，递归时计算 a + b 和 a + c ，选择一个更优的方案返回，也就是上面说的递归后的最优解啦。</p><p>另外结点有可能是负值，最大和肯定就要想办法舍弃负值（max(0, x)）。<br>但是上面3种情况，无论哪种，a作为联络点，都不能够舍弃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;val)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> left = maxPathSum(root-&gt;left, val);</div><div class="line"><span class="keyword">int</span> right = maxPathSum(root-&gt;right, val);</div><div class="line"><span class="keyword">int</span> lmr = root-&gt;val + max(<span class="number">0</span>, left) + max(<span class="number">0</span>, right);</div><div class="line"><span class="keyword">int</span> ret = root-&gt;val + max(<span class="number">0</span>, max(left, right));</div><div class="line">val = max(val, max(lmr, ret));</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> val = INT_MIN;</div><div class="line">maxPathSum(root, val);</div><div class="line"><span class="keyword">return</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="二叉树转双向链表"><a href="#二叉树转双向链表" class="headerlink" title="二叉树转双向链表"></a>二叉树转双向链表</h4><p>不管转什么链表吧，核心就是看展开的链表跟二叉树啥关系：是前序中序之类的。那么根据这个序我们也可以写出相应的展开，以中序为例：</p><blockquote><p>思路：采用中序遍历的方法，visit函数需要完成的功能为：<br>1、当前节点的左子节点指向上一次访问的节点；<br>2、将上一次访问节点的右子节点指向当前节点；<br>3、最后更新上一次访问节点为当前节点。<br>在第二步时需要判断上一次访问节点是不是为NULL，如果是，则第二步改为链表的头结点指向当前节点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(BSTnode * pCurrent)</span></span></div><div class="line">&#123;</div><div class="line">pCurrent-&gt;left = pList;<span class="comment">//*当前节点的左子节点指向上一次访问的节点；*//</span></div><div class="line"><span class="keyword">if</span> (pList != <span class="literal">NULL</span>)</div><div class="line">pList-&gt;right = pCurrent;<span class="comment">//将上一次访问节点的右子节点指向当前节点//</span></div><div class="line"><span class="keyword">else</span> </div><div class="line">pHead = pCurrent;</div><div class="line">pList = pCurrent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BSTnode* root)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">inorder(root-&gt;left);</div><div class="line">visit(root);</div><div class="line">inorder(root-&gt;right);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当然，前序和后序如果要in-place的话需要倒过来用另一个遍历法</p><p>栈也是可以考虑的一种解法。</p><h4 id="lca"><a href="#lca" class="headerlink" title="lca"></a>lca</h4><p>LCA（Lowest Common Ancestors），即最近公共祖先<br>在一棵树上，两个节点的深度最浅的公共祖先就是LCA （自己可以是自己的祖先）</p><p>Tarjan算法的基本思路：<br>1.任选一个点为根节点，从根节点开始。<br>2.遍历该点u所有子节点v，并标记这些子节点v已被访问过。<br>3.若是v还有子节点，返回2，否则下一步。<br>4.合并v到u上。<br>5.寻找与当前点u有询问关系的点v。<br>6.若是v已经被访问过了，则可以确认u和v的最近公共祖先为v被合并到的父亲节点a。</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>1.多次询问两点距离<br>dist[u,v]=dist[1,u]+dist[1,v]-2*dist[1,lca(u,v)]</p><p>2.树上差分（好像不如熟练剖分？）<br>1、修改路径上的结点值<br>2、查询单个结点权值<br>3、查询一个结点子树的权值和<br>对于操作1，显然用树上差分，用val[i]表示结点i的差分数组值，则i结点的真正改变值为以i为子树的所有结点的val数组和，如要修改(x,y)路径上的所有结点值+z，则val[x]+=z，val[y]+=z，val[lca(x,y)]-=z，val[fa[lca(x,y)]-=z；类似区间上的差分操作，对于结点fa[lca(x,y)]（表示x,y的最近公共祖先的父节点）以上的结点的子树的val和都是不变的，只有[x,y]路径上的结点的子树val和加上了z,不在该路径上的都没变。</p><p>操作2，单点权值=差分数组前缀和+原本值，树状数组即可实现</p><p>操作3，结点i的子树的权值和与结点深度有关，维护关于结点深度 * 修改值的树状数组</p><h5 id="树上倍增"><a href="#树上倍增" class="headerlink" title="树上倍增"></a>树上倍增</h5><p>倍增，是根据已经得到了的信息，将考虑的范围扩大，从而加速操作的一种思想<br>使用了倍增思想的算法有<br>归并排序<br>快速幂<br>基于ST表的RMQ算法<br>树上倍增找LCA等<br>FFT、后缀数组等高级算法</p><p>不用想了虽然这个思路非常吊但是都可以剖分</p><p>不过说实话lca最好的写法真就是倍增。<br>用dfs记录每个点的深度，求LCA时先调至统一深度，再一起向上跳<br>其实树上倍增运用的就是这个思想！只不过时间复杂度降至了飞快的O(log2n)<br>对于两个节点u和v，我们先把u和v调至同一深度<br>若此时u=v、，那么原来两点的LCA即为当前点<br>如果depth[u]=depth[v]但u≠v，就说明LCA(u,v)在更浅的地方<br>我们同时把u和v向上跳2^k步，直到u=v<br>明显这种方法肯定能求出LCA，因为u和v一定会相遇<br>倍增比那种脑残方法优的是，脑残方法一步一步向上跳，倍增一次跳2^k步！<br>如何把u和v调至同一深度？<br>其实是一样的，先把较深的那个点调浅就行了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Edge&#123;</div><div class="line">    <span class="keyword">int</span> to,next,w;</div><div class="line">&#125;edge[maxx*<span class="number">2</span>];</div><div class="line"><span class="keyword">int</span> head[maxx],tot;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</div><div class="line">    edge[tot].to = v;</div><div class="line">    edge[tot].next = head[u];</div><div class="line">    edge[tot].w = w;</div><div class="line">    head[u] = tot++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    tot = <span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEG = <span class="number">20</span>;</div><div class="line"><span class="keyword">int</span> fa[maxx][DEG];</div><div class="line"><span class="keyword">int</span> dis[maxx][DEG];</div><div class="line"><span class="keyword">int</span> deg[maxx];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</div><div class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</div><div class="line">    deg[root] = <span class="number">0</span>;</div><div class="line">    fa[root][<span class="number">0</span>] = root;</div><div class="line">    dis[root][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    que.push(root);</div><div class="line">    <span class="keyword">while</span>(!que.empty())&#123;</div><div class="line">        <span class="keyword">int</span> tmp = que.front();</div><div class="line">        que.pop();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; DEG; i++) &#123;</div><div class="line">            fa[tmp][i] = fa[fa[tmp][i<span class="number">-1</span>]][i<span class="number">-1</span>];</div><div class="line">            dis[tmp][i] = dis[tmp][i<span class="number">-1</span>] + dis[fa[tmp][i<span class="number">-1</span>]][i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[tmp]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</div><div class="line">            <span class="keyword">int</span> v = edge[i].to;</div><div class="line">            <span class="keyword">if</span>(v == fa[tmp][<span class="number">0</span>]) <span class="keyword">continue</span>;</div><div class="line">            deg[v] = deg[tmp] + <span class="number">1</span>;</div><div class="line">            fa[v][<span class="number">0</span>] = tmp;</div><div class="line">            dis[v][<span class="number">0</span>] = edge[i].w;</div><div class="line">            que.push(v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(deg[u] &gt; deg[v]) swap(u,v);</div><div class="line">    <span class="keyword">int</span> hu = deg[u],hv = deg[v];</div><div class="line">    <span class="keyword">int</span> tu = u,tv = v;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> det = hv - hu, i = <span class="number">0</span>; det ; det&gt;&gt;=<span class="number">1</span>, i++)&#123;</div><div class="line">        <span class="keyword">if</span>(det &amp; <span class="number">1</span>) &#123;</div><div class="line">            ans += dis[tv][i];</div><div class="line">            tv = fa[tv][i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(tu == tv) <span class="keyword">return</span> tu;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = DEG<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</div><div class="line">        <span class="keyword">if</span>(fa[tu][i] == fa[tv][i])<span class="keyword">continue</span>;</div><div class="line">        ans += dis[tv][i];</div><div class="line">        ans += dis[tu][i];</div><div class="line">        tu = fa[tu][i];</div><div class="line">        tv = fa[tv][i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(tu != tv)&#123;</div><div class="line">        ans += dis[tu][<span class="number">0</span>];</div><div class="line">        ans += dis[tv][<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fa[tu][<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">bool</span> flag[maxx];</div></pre></td></tr></table></figure></p><h4 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h4><p>静态树全都可以剖</p><h4 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h4><p>动态树<br>例如添、删树边操作等<br>LCT≈splay+树剖<br>核心思想就是借鉴树剖的 轻重边 等概念，用比线段树灵活的splay来维护一棵树（森林）</p><h4 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h4><p>64匹马，有8个赛道，问几次比赛能决出1234名</p><p>首先分成8组A1-H8每组分出排名，然后第一们跑一圈就知道1是谁，按1排个序，离1最近的两个就是第二名，左上的三角就是34名可能的位置</p><p>注意到两个赛很蠢，所以里面可以放一些，但是8个是有限制的，如果5个就能立出23名。8个只能出了2后立出34</p><p>情况会变得非常复杂，可以不考虑</p><h4 id="滑雪问题"><a href="#滑雪问题" class="headerlink" title="滑雪问题"></a>滑雪问题</h4><p>本质就是一个dp，没啥</p><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><h5 id="区间最大子段和"><a href="#区间最大子段和" class="headerlink" title="区间最大子段和"></a>区间最大子段和</h5><p>对于每一个每个区间，保存一个Node，记录这个区间的sum(总和)，maxsum(最大子段和)，lmax(最大前缀和)，rmax(最大后缀和)，有了这四个标记，就可以随意转移，为所欲为了。。。<br>这里我们把核心代码拉出来讲一讲</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ans.sum = lo.sum + ro.sum;<span class="comment">//sum直接相加</span></div><div class="line">ans.maxsum = max(max(lo.maxsum, ro.maxsum), lo.rmax + ro.lmax);<span class="comment">//左右两半的最大子段和，合并起来的最大子段和</span></div><div class="line">ans.lmax = max(lo.lmax, lo.sum + ro.lmax);<span class="comment">//左边的最大前缀和，左边整段+右边最大前缀</span></div><div class="line">ans.rmax = max(ro.rmax, ro.sum + lo.rmax);<span class="comment">//右边的最大后缀和，右边整段+左边最大后缀</span></div></pre></td></tr></table></figure><p>给出一个一维的数列，怎么找出连续的，小于等于w个的数，它们的和最大。这个问题可以用线段树O(nlogn)地解决，在将一个数a放到x这个位置的同时，放一个相反数-a在x+w的位置，然后求出整个区间的最大和就是答案。注意，应该先插入-a，再插入a。</p><h5 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h5><p>我居然看懂并且理解了。</p><p>就是按一个坐标排序之后，给每个矩形上面给一个+权值，下面给一个-权值，遍历这个排序之后的线，维护离散化后的下边值，可以用线段树优化（区间加，区间减）。如果只是求矩形面积而言很简单。</p><p>简而言之，就是将每个矩阵拆成两条平行的线段（以平行于y轴的线段为例，记录它的x轴坐标，以及它在y轴上所代表的区间），按x轴排序后再一路扫过去（线段与线段之间即为若干个可求解的矩形，依次计算即可），同时，再利用线段树维护y轴上的区间（算是优化吧）。</p><p>面积并<br>　　扫描线的那部分就不讲了，主要讲讲线段树<br>　　对于y轴上的一段区间，需要记录<br>　　　　len:区间内被覆盖的长度<br>　　　　cnt:整个区间被覆盖的次数<br>　　由于所有修改之后，cnt的值必定为0，对于区间的修改，可以不考虑下放标记。则：</p><ol><li>cnt＞０　　　len＝区间长度，否则转2</li><li>为叶子节点 　 len＝0 　　　，否则转3</li><li>不为叶子节点　 len＝左右孩子len之和</li></ol><p>周长并：暴力两次算了，复杂度没区别<br>线段的长度即：这次和上次线段长度差点绝对值</p><p>不过变形真的还蛮难理解的。</p><p>首先扫描点（矩阵范围内点的最多个数）：</p><p>对于每个点(x, y)，我们维护一个右上方的矩阵【(x, y) -&gt; (x+w, y+h)】<br>对于每个点(x, y)，你另外添加一个点(x+w, y)。从左到右扫描：遇到(x, y)，区间[y, y+h]加1，遇到(x+w, y)，区间[y, y+h]减1。<br>区间更新 用线段树维护。对于每次更新求 区间最大值即可。</p><p>覆盖k次的面积：令人窒息的pushup根本看不懂。努力一小时放弃。反正就是「由于每次查询都是整个区间的覆盖次数，即只看线段树根结点的信息，因此结点的懒标记不用下放，只需要通过左右儿子以及当前结点的懒标记来更新当前结点的信息。」</p><p>虽然是个板子题但是理解上有些困难，放了放了。</p><h4 id="依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？"><a href="#依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？" class="headerlink" title="依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？"></a>依次关闭1、2、3…倍数的灯泡，如果关的就打开，问最后到100时，有多少灯是开的？</h4><p>本质是求一个数的因数个数。为奇数则开。因数成对出现，除非平方数的根。所以求1-100中的完全平方数即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;请不要放太多精力在这。如果放，就看那些板子的东西而不是看思路的东西。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;请仔细看！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="面试" scheme="http://oodtoodt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面经-从零开始（</title>
    <link href="http://oodtoodt.github.io/2019/09/24/%E9%9D%A2%E7%BB%8F-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88/%E9%9D%A2%E7%BB%8F-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88/"/>
    <id>http://oodtoodt.github.io/2019/09/24/%E9%9D%A2%E7%BB%8F-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88/%E9%9D%A2%E7%BB%8F-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88/</id>
    <published>2019-09-24T13:06:49.000Z</published>
    <updated>2019-10-12T08:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>我可能就是所谓的鼠目寸光、井底之蛙吧</p><hr><a id="more"></a><h2 id="58"><a href="#58" class="headerlink" title="58"></a>58</h2><p>直接去世</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>强行问了问项目，本来就没什么，问计算器实现，怎么处理表达式，然后问了点算法，图上的最短路和迷宫的最短路，问一些点怎么都扩起来。有些紧张，没把东西表达好。<br>然后就是令人窒息的计网和操作系统，问完了我基本上就死亡了</p><h4 id="怎么把一些点括起来"><a href="#怎么把一些点括起来" class="headerlink" title="怎么把一些点括起来"></a>怎么把一些点括起来</h4><p>凸包呗。凸包可想象为一条刚好包著所有点的橡皮圈。用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边型，它能包含点集中所有的点。<br>Graham扫描法<br>就用个栈，不断判断栈顶的两个点连的线与下一个点在左右，右说明栈顶不是凸包的点，左继续进栈<br>判断c是否在直线ab的两侧（一个大矩阵）[[x1,x2,x3],[y1,y2,y3],[1,1,1]]<br>若上式为正，在左侧，为负在右侧，0则在直线上</p><h4 id="为什么数据库选择b-b树而不是红黑树"><a href="#为什么数据库选择b-b树而不是红黑树" class="headerlink" title="为什么数据库选择b+/b树而不是红黑树"></a>为什么数据库选择b+/b树而不是红黑树</h4><p>B树查找平均<br>B树高度小 磁盘io小（树的深度过大会造成磁盘IO频繁读写）【存储在内存中才会使用的数据结构】<br>局部性原理<br>B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来</p><h4 id="tcp如何保证传输有序"><a href="#tcp如何保证传输有序" class="headerlink" title="tcp如何保证传输有序"></a>tcp如何保证传输有序</h4><p>TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等<br>其实就是如果来了乱序的就排个序</p><h4 id="c-在openfile的时候，文件指针指的是什么"><a href="#c-在openfile的时候，文件指针指的是什么" class="headerlink" title="c++在openfile的时候，文件指针指的是什么"></a>c++在openfile的时候，文件指针指的是什么</h4><p>文件指针指向的是一个结构体的地址。<br>在上述结构体中，有个叫_fileno的核心成员，该成员就是由open()获得的文件描述符（它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。打开文件时系统向进程返回的一个文件描述符）<br>标准IO函数fopen()本质上也是对系统IO的封装</p><h4 id="多线程有了解吗"><a href="#多线程有了解吗" class="headerlink" title="多线程有了解吗"></a>多线程有了解吗</h4><p>不了解。<br>见另一篇。</p><h4 id="数组为什么比链表快"><a href="#数组为什么比链表快" class="headerlink" title="数组为什么比链表快"></a>数组为什么比链表快</h4><p>首先数组是连续的，CPU缓存会把一片连续的内存空间读入， 因为数组结构是连续的内存地址，所以数组全部或者部分元素被连续存在CPU缓存里面， 平均读取每个元素的时间只要3个CPU时钟周期。 而链表的节点是分散在堆空间里面的</p><h2 id="盛趣"><a href="#盛趣" class="headerlink" title="盛趣"></a>盛趣</h2><p>盛趣就很神秘了。且不谈为什么只有一面+hr面，我一面的时候基本上都在附和，在被动的接受和被引导，莫名其妙的就进了人生第一次hr面，也许是自己是比较早的，占了一个先机？不过机会不大。<br>哦，一面的问题也很神秘。</p><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>就特别神秘。<br>数组的复杂度？vector的复杂度？</p><h4 id="vector有一个容量，每次超过了都会翻倍容量复制一遍对吧，那么我当前有N个数和一个空的vector，你要复制多少次呢"><a href="#vector有一个容量，每次超过了都会翻倍容量复制一遍对吧，那么我当前有N个数和一个空的vector，你要复制多少次呢" class="headerlink" title="vector有一个容量，每次超过了都会翻倍容量复制一遍对吧，那么我当前有N个数和一个空的vector，你要复制多少次呢"></a>vector有一个容量，每次超过了都会翻倍容量复制一遍对吧，那么我当前有N个数和一个空的vector，你要复制多少次呢</h4><p>正着推了一个2^n-1，给了些提示，后来看我思路实在不对，就问你猜一个，盲猜2n，就明着来了。说每次其实都是由上一次的一半构成，那么你这么一算n/2+n/4…+n/2^n那么其实=2^n-1/2^n=1对吧</p><h4 id="一个非常神秘的点集问题"><a href="#一个非常神秘的点集问题" class="headerlink" title="一个非常神秘的点集问题"></a>一个非常神秘的点集问题</h4><h5 id="给你一些一维的点，如何求-a-b-闭集上的点有哪些-有序怎么做-无序怎么做"><a href="#给你一些一维的点，如何求-a-b-闭集上的点有哪些-有序怎么做-无序怎么做" class="headerlink" title="给你一些一维的点，如何求[a,b)闭集上的点有哪些 有序怎么做 无序怎么做"></a>给你一些一维的点，如何求[a,b)闭集上的点有哪些 有序怎么做 无序怎么做</h5><p>我当时直接说的二分，其实大概是直接找就行的吧</p><h5 id="如果变成二维呢"><a href="#如果变成二维呢" class="headerlink" title="如果变成二维呢"></a>如果变成二维呢</h5><p>先说按这个正方形左下角建一个坐标系然后挨个点查，然后提示下又滚回刚才二分的操作。</p><h5 id="那么这是一个近似的解对吧，我们如何优化这些近似，或者说有O-1-的算法吗"><a href="#那么这是一个近似的解对吧，我们如何优化这些近似，或者说有O-1-的算法吗" class="headerlink" title="那么这是一个近似的解对吧，我们如何优化这些近似，或者说有O(1)的算法吗"></a>那么这是一个近似的解对吧，我们如何优化这些近似，或者说有O(1)的算法吗</h5><p>这里的O(1)很可能是指我二分的logn而言的，其实大概一个是O(n)一个是O(nlogn)？可惜我当时听了之后直接人都傻了。<br>直接遍历点刨除某些点就行？<br>不懂——到现在都觉得特别迷。</p><h4 id="迭代器失效的本质是什么"><a href="#迭代器失效的本质是什么" class="headerlink" title="迭代器失效的本质是什么"></a>迭代器失效的本质是什么</h4><p>当时答，erase就会失效。面试官非常婉转的告诉我，如果有一个指针，new了一个对象，然后delete掉了，那么会不会失效？会的。为什么还需要迭代器来模仿一个本来就存在的事件？（意思就是你说的是对的，但是是p话）</p><p>向容器中添加或者删除元素的操作可能使指向容器的指针、引用、迭代器失效。一个失效的指针、引用、迭代器将不再表示任何元素。</p><p>在向容器添加元素后，如果储存空间未重新分配，指向插入位置之前的元素的迭代器、指针、引用有效，但指向插入位置之后的将会失效。<br>在从容器删除元素之后，指向被删元素之前元素的迭代器、引用、指针仍有效。尾后迭代器也就失效。<br>所以对容器进行操作之后，对迭代器需要更新。</p><h5 id="或者这个问题是-迭代器的本质是什么"><a href="#或者这个问题是-迭代器的本质是什么" class="headerlink" title="或者这个问题是 迭代器的本质是什么"></a>或者这个问题是 迭代器的本质是什么</h5><p>把标志控制的循环和计数控制的循环统一为一种控制，即迭代器控制，每一次迭代操作中对迭代器的修改就等价于修改标志或计数器<br>容器迭代器：类似于数据库中的游标（cursor）,屏蔽了底层存储空间的不连续性，在上层使容器元素维持一种“逻辑连续”的假象。</p><h4 id="有序数组，分析一下快排的复杂度？"><a href="#有序数组，分析一下快排的复杂度？" class="headerlink" title="有序数组，分析一下快排的复杂度？"></a>有序数组，分析一下快排的复杂度？</h4><p>一通操作啥都没分析出来，当时对partition真的是思路不清了，就应和着下去了。（越说越觉得凉）<br>N^2，因为变成了一条链，深度是N而不是logN了。</p><h5 id="如何变快？就如何优化掉这个N？"><a href="#如何变快？就如何优化掉这个N？" class="headerlink" title="如何变快？就如何优化掉这个N？"></a>如何变快？就如何优化掉这个N？</h5><p>小数组切成插入排序（我只记得这个了<br>随机化快排（从中间开始）<br>三数取中（类似中位数的思想）<br>三向切分（针对大量重复元素数组而言）<br>优化递归（并不是重点）</p><h4 id="TopK怎么解？"><a href="#TopK怎么解？" class="headerlink" title="TopK怎么解？"></a>TopK怎么解？</h4><p>堆 更好的呢？ partition</p><h5 id="那么这个partition的复杂度怎么样？"><a href="#那么这个partition的复杂度怎么样？" class="headerlink" title="那么这个partition的复杂度怎么样？"></a>那么这个partition的复杂度怎么样？</h5><p>首先了解partition的原理<br>取 a[l] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。<br>假设每次都会是二分，则是n/2+n/4+n/8+…不超过2n和vector那个一样。</p><h4 id="蚂蚁对爬问题"><a href="#蚂蚁对爬问题" class="headerlink" title="蚂蚁对爬问题"></a>蚂蚁对爬问题</h4><h5 id="撞到就回头，最后掉下去，问你都掉下去，要撞多少次？"><a href="#撞到就回头，最后掉下去，问你都掉下去，要撞多少次？" class="headerlink" title="撞到就回头，最后掉下去，问你都掉下去，要撞多少次？"></a>撞到就回头，最后掉下去，问你都掉下去，要撞多少次？</h5><p>答不出，苦思</p><h5 id="各种提示，问题最开始要先想什么？"><a href="#各种提示，问题最开始要先想什么？" class="headerlink" title="各种提示，问题最开始要先想什么？"></a>各种提示，问题最开始要先想什么？</h5><p>答简化问题，化成小问题<br>实则是先从最简单的情况想一想，找一找规律</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>对爬问题的关键在于分析出撞到和没撞实际上是一样的。想到了就是海阔天空。但是我当时却是在面试官的引导下找规律推出来的….<br>哎</p><h3 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h3><p>瞎聊。不过表达上还是有很多东西没表达出来。我还是更适合酝酿酝酿，事后尤其是自己本来就蛮有发言权／蛮有话说的那种话题我能想到不少可以说的，可惜当时没讲。<br>然后就是我太紧张，声音都变了，而且越说越嗡鸣。<br>重点大概还是你有什么经历，投了什么岗位，更在乎什么，加班的看法，对矛盾的处理之类的吧。</p><h2 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h2><p>同样有些神秘的体验。<br>先把我们聚集到一个小会议室里，以为要群面结果是各自写个二分的代码，分别去寻各自的面试官。<br>面试官都在各自的房间里，房间十分敞亮，外面是开阔的视野，正值3点的天明媚而有些刺眼。与面试官面对面相坐，那桌子是完全透明的，我没有仔细的观察他的房间，就投入了各种解决不出的问题之中。<br>四个问题就答出一个，第一个支支吾吾瞎jb扯，后面两个透露出对操作系统的不熟、对面向对象编程的不熟等等。<br>面试官还不错，就是我有点紧张。<br>hr面就那样，瞎聊。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><h4 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h4><p>迷宫问题有啥，不就是bfs吗？</p><h5 id="进阶优化"><a href="#进阶优化" class="headerlink" title="进阶优化"></a>进阶优化</h5><p>如果这个地图很大，有什么办法对bfs优化吗？其实58问过，我当时没放在心上还以为答得不错。</p><pre><code>双向bfsA * 算法（以及迭代加深的ida * ）</code></pre><p>A <em> 算法的关键在于启发函数，启发函数的优劣直接影响A </em> 算法的效率。          f(n)=g(n)+h(n);<br>一般的（简单的），我们选用曼哈顿距离作为启发函数。</p><h5 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h5><p>如果当前的地图非常巨大，但是可以允许预处理的操作，要怎么做？</p><blockquote><p>影响计算寻路路径的不是时间，而是计算路径所需的上百个单元格所占的空间。寻路是需要内存来运行寻路算法，还需要额外内存来存储寻到的路径。运行寻路算法（A*,开集或闭集）所需的临时空间经常会比存储这些寻到的路径所需的空间更大。通过在同一时间内只进行一条路径计算来限制游戏中的计算量，可以将你需要的临时空间降到最少。</p></blockquote><pre><code>所以普遍的折中做法是服务器端只做近距离的寻路，或通过导航站点缩短A * 的范围。更优的算法：B * 算法</code></pre><p>Bstart 算法原理： 一般寻路的方向 上、下、左、右<br>1、根据开始和结束2个点确定移动的方向<br>2、每走一步都需要确定一下方向<br>3、如果中途遇到有障碍物，根据当前位置和终点的位置，确定移动方向，变成2条线路<br>4、这2 条线交替向终点方向移动<br>5、如果中途又碰见障碍物了，继续分2个线，此时四条线交替移动<br>6、最先到终点的就是最终的路线；</p><p>几个比较模糊的思路：</p><pre><code>缩点</code></pre><p>1）预处理：将地图按N <em> N大小划分区块，其中N为阻挡格数。找出每个区块与周围四个区块在边界上的互通点，然后在区块内使用Normal A </em> 对找出的点做连通性测试并将结果保存下来；</p><p>2）层次A <em> ：如果我们将预处理步骤中的区块作为Normal A </em> 算法中搜索的一个阻挡格，那么4096 <em> 4096大小的地图，当N=32时的搜索域将会降到128 </em> 128。在客户端执行寻路请求时，寻路线程使用预处理得到的数据，在区块一级做一次A <em> 找出路径经过的区块互通点，再在每个区块内使用Normal A </em> 得到互通点之间的路径，最终得到完整路径。</p><pre><code>优化A * </code></pre><p>JPS，事先处理出不能经过的（障碍）四周的点，联通成图后不断A * </p><p>如此我们甚至可以步入更古怪的世界：路经压缩</p><p>总之更多的就不多再提了，已经蛮深的了，先这样吧（</p><h4 id="一个类扫描线问题…"><a href="#一个类扫描线问题…" class="headerlink" title="一个类扫描线问题…"></a>一个类扫描线问题…</h4><p>给出多个玩家上线时间和下线时间（固定），他只能在这个区间里做任务，问，现在要查询某一个时刻有哪些玩家可以做任务，你来设计一下<br>说下我的设计，我就上线一个map，下线一个map，然后靠map会排序的特性瞎搞nlogn</p><h5 id="如果当前的这个时间无比精确，你有更好的想法嘛"><a href="#如果当前的这个时间无比精确，你有更好的想法嘛" class="headerlink" title="如果当前的这个时间无比精确，你有更好的想法嘛"></a>如果当前的这个时间无比精确，你有更好的想法嘛</h5><h5 id="如果我这个时间非常长，几天几周，你有更好的办法吗"><a href="#如果我这个时间非常长，几天几周，你有更好的办法吗" class="headerlink" title="如果我这个时间非常长，几天几周，你有更好的办法吗"></a>如果我这个时间非常长，几天几周，你有更好的办法吗</h5><p>感觉面试官变来变去其实是想说不让用扫描时间的方式（不让用map的方式hhh）<br>这个我没怎么好好想就被面试官跳过去问下一个问题了。。。</p><h4 id="cache的实现"><a href="#cache的实现" class="headerlink" title="cache的实现"></a>cache的实现</h4><p>只需要写需要什么函数就可以了。（那需要什么呢？）</p><p>cache是什么？是缓存。缓存是干什么用的？是用来使得重复访问不会每次都重查，那么这东西像什么？页面置换</p><p>LRU什么的搞一下啊。好歹有个这个思想吧。没有。知识并没有在这里串联起来。哭了。</p><h4 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h4><p>首先了解智能指针是什么，在非常清晰的理解了之后才好写出代码。</p><p>首先要实现引用计数类，然后实现指针类<br>放在一个里应该也可以</p><p>就是构造的时候初始化1，拷贝就++，赋值的时候左边–，右边++，析构的时候—，特判0时候删除域</p><h5 id="各种函数"><a href="#各种函数" class="headerlink" title="各种函数"></a>各种函数</h5><p>当时脑子一壶就不记得拷贝构造函数怎么写了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> temp&#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="comment">//数据成员</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="comment">//成员函数</span></div><div class="line">    temp(T *p)&#123;&#125;</div><div class="line">    temp(<span class="keyword">const</span> temp &amp;other)&#123;&#125;<span class="comment">//拷贝构造</span></div><div class="line">    temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> temp &amp;rhs)&#123;&#125;<span class="comment">//重载运算符</span></div><div class="line">    </div><div class="line">    temp(temp &amp;&amp;t)&#123;&#125;<span class="comment">//移动构造函数</span></div><div class="line">    temp &amp;<span class="keyword">operator</span>=(temp &amp;&amp;test)<span class="comment">//移动赋值</span></div><div class="line">        </div><div class="line">    T &amp;<span class="keyword">operator</span>*()&#123;&#125;<span class="comment">//解引用重载</span></div><div class="line">    </div><div class="line">    ~temp()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="hr面-1"><a href="#hr面-1" class="headerlink" title="hr面"></a>hr面</h3><p>印象比较深刻的就是会问你对游戏行业的理解，结果我说了我对游戏这个时长的理解，总有些答非所问。<br>我提问也是问的游戏行业的理解，人家就答的很在点子上。<br>别的基本上没啥，薪资啊，地点啊，处理矛盾啊，项目经验啊，未来规划啊，投过什么公司啊，之前的一些经历啊，就还有个比较扎心的如果把你安排到初级开发工程师你会怎么样的问题……</p><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>直接去世呢<br>面试官人特好。无论从哪个方面来说都特好。<br>只是就我个人而言面试官说准备的不够充分，还指出了种种不足，我觉得都说的蛮对，以致于我最后没什么问题可问。</p><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><p>「你精通c++啊，那么来问几个问题」</p><h4 id="说一下static的作用"><a href="#说一下static的作用" class="headerlink" title="说一下static的作用"></a>说一下static的作用</h4><p>全局静态变量在声明他的文件之外是不可见的<br>但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。<br>那么这个函数只可在本cpp内使用<br>对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。</p><h5 id="刷刷刷"><a href="#刷刷刷" class="headerlink" title="刷刷刷"></a>刷刷刷</h5><p>写下一个没看懂也没记住的东西，问这是什么。不知道。<br>大概印象里应该是写了个函数指针？不过怎么跟static扯上关系的呢。</p><h5 id="嗯，那我这个东西要怎么赋值呢"><a href="#嗯，那我这个东西要怎么赋值呢" class="headerlink" title="嗯，那我这个东西要怎么赋值呢"></a>嗯，那我这个东西要怎么赋值呢</h5><p>画画画。一个静态类成员。</p><p>瞎答，死！</p><h4 id="那换一个，说下const的作用"><a href="#那换一个，说下const的作用" class="headerlink" title="那换一个，说下const的作用"></a>那换一个，说下const的作用</h4><p>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>char <em> const p p指针不可更改<br>const char </em> p p内容不可更改<br>char const * p p内容不可更改<br>只修饰左边的，<br>（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；  （最后 () const{}这种)<br>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</p><p>差不多其实就行了，这个好像没啥</p><h4 id="实现一个智能指针"><a href="#实现一个智能指针" class="headerlink" title="实现一个智能指针"></a>实现一个智能指针</h4><p>只写一下几个函数的实现就行了</p><p>思路理清楚：</p><p>构造为1，拷贝构造++，赋值的时候左边–，右边++，析构的时候—，特判0时候删除域</p><p>我tm再重复一遍，拷贝构造++。我要被蠢死了。当时脑子里是浆糊吗。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">shared_ptr</span> </div><div class="line">&#123;</div><div class="line">T* m_ptr;</div><div class="line"><span class="keyword">size_t</span>* ref_count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line"><span class="built_in">shared_ptr</span>(T* ptr = <span class="literal">nullptr</span>);</div><div class="line">~<span class="built_in">shared_ptr</span>();</div><div class="line"></div><div class="line"><span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; other);</div><div class="line"><span class="built_in">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; other);</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> GetCount();</div><div class="line"></div><div class="line">T&amp; <span class="keyword">operator</span>*();</div><div class="line">T* <span class="keyword">operator</span>-&gt;();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;T&gt;::<span class="built_in">shared_ptr</span>(T ptr)</div><div class="line">:m_ptr(<span class="keyword">new</span> T(ptr)),ref_count(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>))</div><div class="line">    &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;T&gt;::~<span class="built_in">shared_ptr</span>()</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (--(*ref_count) == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">delete</span> m_ptr;</div><div class="line"><span class="keyword">delete</span> ref_count;</div><div class="line">m_ptr = <span class="literal">nullptr</span>;</div><div class="line">ref_count = <span class="literal">nullptr</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引用为0，调用析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;T&gt;::<span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; s_point)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s_point)</div><div class="line">&#123;</div><div class="line"><span class="keyword">this</span>-&gt;m_ptr = s_point.m_ptr;</div><div class="line"><span class="keyword">this</span>-&gt;ref_count = s_point.ref_count;</div><div class="line">++(*<span class="keyword">this</span>-&gt;ref_count);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;T&gt;&amp; <span class="built_in">shared_ptr</span>&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; s_point)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(m_ptr == s_point.m_ptr)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (--(*ref_count) == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">delete</span> m_ptr;</div><div class="line"><span class="keyword">delete</span> ref_count;</div><div class="line">m_ptr = <span class="literal">nullptr</span>;</div><div class="line">ref_count = <span class="literal">nullptr</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引用为0，调用析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">m_ptr = s_point.m_ptr;</div><div class="line">ref_count = s_point.ref_count;</div><div class="line">++(*ref_count);</div><div class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">size_t</span> <span class="built_in">shared_ptr</span>&lt;T&gt;::GetCount()</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> *ref_count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> T&amp; <span class="built_in">shared_ptr</span>&lt;T&gt;::<span class="keyword">operator</span>*()</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_ptr)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> *m_ptr;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> T* <span class="built_in">shared_ptr</span>&lt;T&gt;::<span class="keyword">operator</span>-&gt;()</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_ptr)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> m_ptr;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="list-vector-map-unordered-map"><a href="#list-vector-map-unordered-map" class="headerlink" title="list,vector,map,unordered_map"></a>list,vector,map,unordered_map</h4><h5 id="底层实现？"><a href="#底层实现？" class="headerlink" title="底层实现？"></a>底层实现？</h5><p>双向环状链表 ，数组，红黑树，哈希表（拉链法的）</p><h5 id="添加元素会发生什么？（都是怎么操作的？）"><a href="#添加元素会发生什么？（都是怎么操作的？）" class="headerlink" title="添加元素会发生什么？（都是怎么操作的？）"></a>添加元素会发生什么？（都是怎么操作的？）</h5><p>对于序列式容器（vector、deque、list），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。使用erase方法后，返回的是下一个有效的iterator。</p><p>往某个位置插入一个元素，则这个位置之后的元素都要后移，因此后面的迭代器都会失效；如果引起内存的重新配置，所有的迭代器都将失效。</p><p>对于关联容器（map，set），删除当前的iterator，仅仅会使当前的iterator失效</p><p>插入一个元素，并不会对其他的节点造成影响</p><h5 id="那么迭代器会怎样变化？"><a href="#那么迭代器会怎样变化？" class="headerlink" title="那么迭代器会怎样变化？"></a>那么迭代器会怎样变化？</h5><h4 id="你说你了解内存，那么我"><a href="#你说你了解内存，那么我" class="headerlink" title="你说你了解内存，那么我"></a>你说你了解内存，那么我</h4><p>画画画。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个东西放在栈区还是堆区？</p><p>一般的STL内存管理器allocator都是用内存池来管理内存的，所以某个容器申请内存或释放内存都只是影响到内存池的剩余内存量，而不是真的把内存归还给系统。这样做一是为了避免内存碎片，二是提高了内存申请和释放的效率——不用每次都在系统内存里寻找一番。<br>真的让容器把不用的内存归还给系统的话，只能自己写一个allocator，并在容器的模板参数里使用它，而且STL的标准容器确实都留了这个接口。<br>不过要意识到这样做给程序性能和系统内存带来的影响。</p><h5 id="你来实现一个申请栈区的函数"><a href="#你来实现一个申请栈区的函数" class="headerlink" title="你来实现一个申请栈区的函数"></a>你来实现一个申请栈区的函数</h5><p>画画画。比如说我现在有一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch[<span class="number">1024</span>*<span class="number">1024</span>];</div></pre></td></tr></table></figure><p>来，在这里申请内存。</p><p>不会。</p><h5 id="new指定存储位置（placement-new"><a href="#new指定存储位置（placement-new" class="headerlink" title="new指定存储位置（placement new)"></a>new指定存储位置（placement new)</h5><p>一般来说，使用new申请空间时，是从系统的“堆”（heap）中分配空间。申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这就是所谓的“定位放置new”（placement new）操作。<br>定位放置new操作的语法形式不同于普通的new操作。例如，一般都用如下语句A <em>  p=new A;申请空间，而定位放置new操作则使用如下语句A </em>  p=new (ptr)A;申请空间，其中ptr就是程序员指定的内存首地址。考察如下程序。  </p><h4 id="如果我当前有一个整机存的下的数据"><a href="#如果我当前有一个整机存的下的数据" class="headerlink" title="如果我当前有一个整机存的下的数据"></a>如果我当前有一个整机存的下的数据</h4><p>用什么存比较好？</p><h5 id="为啥不使用B-树？"><a href="#为啥不使用B-树？" class="headerlink" title="为啥不使用B+树？"></a>为啥不使用B+树？</h5><p>嗯B+树更优秀一些。</p><p>啊不行，我写不下去了。</p><h4 id="来写个后序遍历非递归的形式"><a href="#来写个后序遍历非递归的形式" class="headerlink" title="来写个后序遍历非递归的形式"></a>来写个后序遍历非递归的形式</h4><h4 id="来个树上最远两点距离"><a href="#来个树上最远两点距离" class="headerlink" title="来个树上最远两点距离"></a>来个树上最远两点距离</h4><h4 id="现在有个人爬山，你来建个模"><a href="#现在有个人爬山，你来建个模" class="headerlink" title="现在有个人爬山，你来建个模"></a>现在有个人爬山，你来建个模</h4><p>他从早上9点到晚上9点，从山脚爬到了山顶<br>睡了一觉。<br>又从早上9点到晚上9点，从山顶下到了山脚。<br>问，不确定速度的情况下，会不会在某一个时刻，站在同一个台阶上。<br>你来建个模</p><p>？？？</p><h5 id="不可教也"><a href="#不可教也" class="headerlink" title="不可教也"></a>不可教也</h5><p>这里面几个变量？<br>我们可不可以用这些变量画二维图来观察关系？<br>那么时间一定是一维了，剩下的呢？画画画，x轴时间<br>y轴地点。好。那么你来画上山下山两条曲线。随便画。<br>那么？<br>有交点，说明什么？</p><p>问题的本质其实是相遇问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我可能就是所谓的鼠目寸光、井底之蛙吧&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
    
      <category term="面试" scheme="http://oodtoodt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题相关</title>
    <link href="http://oodtoodt.github.io/2019/09/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%B8%E5%85%B3/"/>
    <id>http://oodtoodt.github.io/2019/09/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%B8%E5%85%B3/</id>
    <published>2019-09-20T01:46:58.000Z</published>
    <updated>2019-10-13T16:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>惨，是真的惨。</p><hr><a id="more"></a><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="c-的"><a href="#c-的" class="headerlink" title="c++的"></a>c++的</h3><h4 id="memmove注意事项？"><a href="#memmove注意事项？" class="headerlink" title="memmove注意事项？"></a>memmove注意事项？</h4><p>内存重叠（dst&lt;=src || (char <em> )dst &gt;= (char </em> )src + count)<br>内存对齐(为了提高存取效率和一定的移植性)</p><h5 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h5><p>它的功能是从src的开始位置拷贝n个字节的数据到dest。如果dest存在数据，将会被覆盖。memcpy函数的返回值是dest的指针。</p><h4 id="c-的内存管理"><a href="#c-的内存管理" class="headerlink" title="c++的内存管理"></a>c++的内存管理</h4><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。<br>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。<br>数据段：存储程序中已初始化的全局变量和静态变量<br>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。<br>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。<br>映射区:存储动态链接库以及调用mmap函数进行的文件映射<br>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p><h5 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h5><p>大多数情况下，STL默认的allocator就已经足够了。这个allocator是一个由两级分配器构成的内存管理器，当申请的内存大小大于128byte时，就启动第一级分配器通过malloc直接向系统的堆空间分配，如果申请的内存大小小于128byte时，就启动第二级分配器，从一个预先分配好的内存池中取一块内存交付给用户，这个内存池由16个不同大小（8的倍数，8~128byte）的空闲列表组成，allocator会根据申请内存的大小（将这个大小round up成8的倍数）从对应的空闲块列表取表头块给用户。</p><p>注意这并不适合一个通用的内存分配。因为它要求在释放一个内存块时，必须提供这个内存块的大小，以便确定回收到哪个free list中</p><p>我们知道，引入相对的复杂的空间配置器，主要源自两点：</p><ol><li>频繁使用malloc，free开辟释放小块内存带来的性能效率的低下</li><li>内存碎片问题，导致不连续内存不可用的浪费</li></ol><p>引入两层配置器帮我们解决以上的问题，但是也带来一些问题：</p><p>内碎片的问题，自由链表所挂区块都是8的整数倍，因此当我们需要非8倍数的区块，往往会导致浪费，比如我只要1字节的大小，但是自由链表最低分配8块，也就是浪费了7字节，我以为这也就是通常的以空间换时间的做法，这一点在计算机科学中很常见。<br>我们发现似乎没有释放自由链表所挂区块的函数？确实是的，由于配置器的所有方法，成员都是静态的，那么他们就是存放在静态区。释放时机就是程序结束，这样子会导致自由链表一直占用内存，自己进程可以用，其他进程却用不了。</p><h5 id="为什么free不需要知道大小？"><a href="#为什么free不需要知道大小？" class="headerlink" title="为什么free不需要知道大小？"></a>为什么free不需要知道大小？</h5><p>有先存一个结构体为它的大小</p><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。<br>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。<br>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p><h5 id="malloc和new的区别？"><a href="#malloc和new的区别？" class="headerlink" title="malloc和new的区别？"></a>malloc和new的区别？</h5><ol><li>申请的内存所在位置。malloc是堆，new是从free store</li><li>返回类型。malloc返回void * ，new是类型安全的。失败时malloc返回NULL，new失败抛出异常</li><li>调用构造/析构函数</li><li>指定内存大小</li><li>专门提供对数组的处理</li><li>可以重载</li><li>直观的内存（malloc）</li></ol><h5 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h5><p>一般来说，使用new申请空间时，是从系统的“堆”（heap）中分配空间。申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这就是所谓的“定位放置new”（placement new）操作。<br>定位放置new操作的语法形式不同于普通的new操作。例如，一般都用如下语句A <em>  p=new A;申请空间，而定位放置new操作则使用如下语句A </em>  p=new (ptr)A;申请空间，其中ptr就是程序员指定的内存首地址。考察如下程序。 </p><h5 id="new-delete-malloc-free是否可以混用"><a href="#new-delete-malloc-free是否可以混用" class="headerlink" title="new,delete,malloc,free是否可以混用"></a>new,delete,malloc,free是否可以混用</h5><p>当申请的空间是内置类型时，delete和free可以混用<br>当申请的空间是自定义类型时，</p><ul><li>1&gt;若没有析构函数，delete和malloc可以混用，有[]和没有[]都相同</li><li>2&gt;若申请的空间有析构函数时，malloc申请的空间可以用delete和free释放，但是用delete释放时不能加[]</li><li>3&gt;若申请的空间有析构函数时，new申请的空间不能用free释放，可以用delete释放，但是释放时必须加上[]</li></ul><h5 id="delete-p-和delete-p"><a href="#delete-p-和delete-p" class="headerlink" title="delete []p 和delete p"></a>delete []p 和delete p</h5><p>delete ptr 代表释放ptr指向内存，并且只能用来释放内存。<br>delete[] ptr 代表释放ptr指向的内存，并且逐个调用对象的析构函数。</p><h4 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h4><p>引用即别名，指针是新的变量<br>级数：从理论上来说，对于指针没有级数限制，但是引用只有一级。<br>内存分配：程序为指针变量分配区域，而不为引用分配内存区域。因为引用生命时必须初始化，从而指向一个已经存在的对象，引用不能为空值<br>编译：反正就是指针可以指向别的值，引用不能</p><h4 id="定义和声明的区别"><a href="#定义和声明的区别" class="headerlink" title="定义和声明的区别"></a>定义和声明的区别</h4><p>声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p><h4 id="二维字符串的初始化"><a href="#二维字符串的初始化" class="headerlink" title="二维字符串的初始化"></a>二维字符串的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *p[<span class="number">30</span>] =  &#123;<span class="string">"ab"</span>,<span class="string">"cd"</span>,<span class="string">"ed"</span>&#125;;</div></pre></td></tr></table></figure><h4 id="int-fp-void-10"><a href="#int-fp-void-10" class="headerlink" title="int  (  (  fp)(void  ))[10]"></a>int <em> ( </em> ( <em> fp)(void </em> ))[10]</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int (*(*fp)(void *))[10]; //这个类型用typedef分解出来</div><div class="line"></div><div class="line">// 第一步：此指针是一个指向函数T1的指针</div><div class="line">typedef int (*T1(void *))[10];</div><div class="line">T1 *fp;</div><div class="line"></div><div class="line">// 第二步：T1 是一个函数，返回值是T2，参数为(void *)</div><div class="line">typedef int (*T2)[10];</div><div class="line">typedef T2 T1(void *);</div><div class="line">T1 *fp;</div><div class="line"></div><div class="line">// 第三步：T2是个指针，该指针指向T3类型</div><div class="line">typedef int T3[10];</div><div class="line">typedef T3 *T2;</div><div class="line">typedef T2 T1(void *);</div><div class="line">T1 *fp;</div></pre></td></tr></table></figure><h5 id="指针函数-函数指针"><a href="#指针函数-函数指针" class="headerlink" title="指针函数 函数指针"></a>指针函数 函数指针</h5><p><strong>指针函数：</strong> 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。<br>注意到指针函数返回的指针可能指向空值，需用static声明</p><p><strong>函数指针</strong> 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">//函数指针的定义</span></div><div class="line"><span class="comment">//int (*p)();       //函数指针的另一种定义方式，不过不建议使用</span></div><div class="line"><span class="comment">//int (*p)(int a, int b);   //也可以使用这种方式定义函数指针</span></div><div class="line">p = max;    <span class="comment">//函数指针初始化</span></div><div class="line"><span class="keyword">int</span> ret = p(<span class="number">10</span>, <span class="number">15</span>);    <span class="comment">//函数指针的调用</span></div></pre></td></tr></table></figure><h5 id="typedef-void-pfun-void"><a href="#typedef-void-pfun-void" class="headerlink" title="typedef  void ( * pfun)(void);"></a>typedef  void ( * pfun)(void);</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span>  <span class="keyword">unsigned</span> <span class="keyword">int</span>  UINT32;<span class="comment">// UINT32 类型是unsigned int</span></div><div class="line">UINT32 sum;<span class="comment">// 定义一个变量：int sum;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  arr[<span class="number">3</span>];<span class="comment">// arr 类型是 int[3];（存放int型数据的数组）</span></div><div class="line">arr a;<span class="comment">// 定义一个数组：int a[3];</span></div><div class="line"></div><div class="line">同理：</div><div class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">void</span> <span class="params">(*pfun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// pfun 类型是 void(*)(void)</span></div><div class="line">pfun main;      <span class="comment">// 定义一个函数：void (*main)(void);</span></div></pre></td></tr></table></figure><p>其中静态不静态的区别只在类中，静态不需要对象来访问变量（函数）</p><h5 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h5><p>举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方</p><p><strong>回调函数</strong>：</p><p>回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。<br>回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。</p><p>上面这个简单的demo就是一个比较典型的回调函数的例子。在这个程序中，回调函数<code>callback</code>无需关心<code>func_sum</code>是怎么实现的，只需要去调用即可。<br>这样的好处就是，如果以后对求和函数有优化，比如新写了个<code>func_sum2</code>函数的实现，我们只需要在调用回调函数的地方将函数指针指向<code>func_sum2</code>即可，而无需去修改<code>callback</code>函数内部</p><h4 id="Extern-C"><a href="#Extern-C" class="headerlink" title="Extern C*"></a>Extern C*</h4><p>extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。<br>被extern “C”修饰的函数或者变量是按照C语言方式编译和链接的，所以可以用一句话来概括extern “C”的真实目的：实现C++与C的混合编程。</p><h4 id="struct和class的区别？"><a href="#struct和class的区别？" class="headerlink" title="struct和class的区别？"></a>struct和class的区别？</h4><p>c++中：<br>1.struct可以包括成员函数<br>2.struct可以实现继承<br>3.struct可以实现多态</p><p>1.默认的继承访问权。class默认的是private,strcut默认的是public。（优先取决于取决于子类而不是基类）</p><p>两者最大的区别就在于思想上，c语言编程单位是函数，语句是程序的基本单元。而C++语言的编程单位是类。从c到c++的设计有过程设计为中心向以数据组织为中心转移。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h5 id="fibonacci"><a href="#fibonacci" class="headerlink" title="fibonacci"></a>fibonacci</h5><p>return f(n-1) + f(n-2)<br>这里的复杂度是O(2^n)！一直误会了这个复杂度。因为每一个都会向下递归，那么直接考虑成一颗二叉树，其实应该是O(2^n/2)的感觉，左边偏满越向右越不满。<br>优化就是尾递归只一层或者直接循环</p><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><h5 id="虚函数定义"><a href="#虚函数定义" class="headerlink" title="虚函数定义"></a>虚函数定义</h5><p>虚函数则是加了virtual修饰词的类的成员函数。<br>虚函数通过继承方式来体现出多态作用，它必须是基类的非静态成员函数，其访问权限可以是protected或public<br>虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数</p><h5 id="虚函数的代价"><a href="#虚函数的代价" class="headerlink" title="虚函数的代价"></a>虚函数的代价</h5><p>1）带有虚函数的每个类会产生一个虚函数表，用来存储虚成员函数的指针<br>2）带有虚函数的每个类都会有一个指向虚函数表的指针<br>3）不再是内联函数，因为内联函数可以在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到达采用哪种函数，所以虚函数不是内敛函数</p><h5 id="虚函数和纯虚函数的区别？"><a href="#虚函数和纯虚函数的区别？" class="headerlink" title="虚函数和纯虚函数的区别？"></a>虚函数和纯虚函数的区别？</h5><p>1）纯虚函数只有定义，没有实现，虚函数既有定义，又有实现<br>2）含有纯虚函数的类不能定义对象，含有虚函数的类可以定义对象</p><h5 id="不能虚函数的函数？"><a href="#不能虚函数的函数？" class="headerlink" title="不能虚函数的函数？"></a>不能虚函数的函数？</h5><p>常见的不能声明为虚函数的有：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数。<br>构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数<br>父类虚析构函数就是为了避免内存泄漏，防止子类内存得不到释放造成内存泄漏</p><h5 id="虚表指针存在对象的哪个位置"><a href="#虚表指针存在对象的哪个位置" class="headerlink" title="虚表指针存在对象的哪个位置"></a>虚表指针存在对象的哪个位置</h5><p>存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表<br>一般而言，虚函数表vtable存放在可执行文件的只读数据段</p><h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><p>（1）当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；<br>（2）这个方法必须在派生类(derived class)中被实现；</p><h5 id="含虚函数的sizeof"><a href="#含虚函数的sizeof" class="headerlink" title="含虚函数的sizeof"></a>含虚函数的sizeof</h5><p>其实考察的还是虚表指针。<br>//是虚函数里面的指针个数（其实只有一个指向开头，毕竟指针） * 指针大小<br>如果是单继承，则派生类只含有一个虚函数表（虚表指针）<br>如果是多继承，则在派生类中，有每个基类函数的虚表指针<br>虚继承中，派生类会保存一个指向虚基类的指针，而且如果虚基类包含虚函数，则还会保存虚基类中的虚表指针。（虚继承就是菱形继承）</p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。<br>内存泄漏的分类：</p><ol><li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li><li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li><li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。<br>有效解决内存泄漏可以使用智能指针。因为智能指针可以自动删除分配的内存。智能指针和普通指针类似，只是不需要手动释放指针，而是通过智能指针自己管理内存的释放</li></ol><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。</p><p>weak_ptr 用来协助shared_ptr</p><p>unique_ptr 唯一的ptr</p><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的。<br>所以一个好的原则是，能使用初始化列表的时候尽量使用初始化列表.</p><h5 id="必须使用初始化列表的场合"><a href="#必须使用初始化列表的场合" class="headerlink" title="必须使用初始化列表的场合"></a>必须使用初始化列表的场合</h5><p>1.常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面<br>2.引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</p><ol><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化</li></ol><p>另外：成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的</p><h4 id="使用拷贝构造函数／构造函数／赋值函数"><a href="#使用拷贝构造函数／构造函数／赋值函数" class="headerlink" title="使用拷贝构造函数／构造函数／赋值函数"></a>使用拷贝构造函数／构造函数／赋值函数</h4><p>如果临时变量是第一次出现，那么调用的只能是拷贝构造函数，反之如果变量已经存在，那么调用的就是赋值函数。<br>如果你认真思考一下构造函数的结构，其实也能明白的吧</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>1、迭代器<br>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p><p>由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p><p>2、迭代器和指针的区别</p><p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、 * 、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p><p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用 * 取值后的值而不能直接输出其自身。</p><p>3、迭代器产生原因</p><p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p><h4 id="使用this指针的场合"><a href="#使用this指针的场合" class="headerlink" title="使用this指针的场合"></a>使用this指针的场合</h4><p>你不怎么会用呢。<br>C++ 规定，在非静态成员函数内部可以直接使用 this 关键字，this 就代表指向该函数所作用的对象的指针<br>注意哦，是 指针</p><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>inline 是一种”用于实现的关键字”，而不是一种”用于声明的关键字”<br>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。<br>只有当函数非常短小的时候它才能得到我们想要的效果</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>全局静态变量在声明他的文件之外是不可见的<br>但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。<br>那么这个函数只可在本cpp内使用<br>对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。</p><h5 id="static的赋值问题"><a href="#static的赋值问题" class="headerlink" title="static的赋值问题"></a>static的赋值问题</h5><p>首先分开赋值和初始化。</p><p>注意带有类内初始值设定项的成员必须为常量<br>即static静态成员变量的初始化赋值应该在类的外部。<br>非静态的类数据成员不能在其类的外部定义</p><p>绕来绕去，总之就是类外！</p><p>该静态数据成员只能被定义一次，而且要被同类的所有对象共享。各个对象都拥有类中每一个普通数据成员的副本，但静态数据成员只有一个实例存在，与定义了多少类对象无关。<br>静态数据成员的用途之一是统计有多少个对象实际存在。<br>静态数据成员不能在类中初始化，实际上类定义只是在描述对象的蓝图，在其中指定初值是不允许的。也不能在够造函数中初始化该成员，因为静态数据成员为类的各个对象共享，那么每次创建一个类的对象则静态数据成员都要被重新初始化。</p><h4 id="const作用"><a href="#const作用" class="headerlink" title="const作用"></a>const作用</h4><p>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>char <em> const p p不可更改<br>const char </em> p 内容不可更改<br>char const * p 内容不可更改<br>（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；  （最后 () const{}这种)<br>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</p><h4 id="模版类编程"><a href="#模版类编程" class="headerlink" title="模版类编程"></a>模版类编程</h4><p>template<typename t="">与template<class t="">一般情况下这两个通用，但有一个特例，就是当 T 是一个类，而这个类又有子类(假设名为 innerClass) 时，应该用 template<typename>:</typename></class></typename></p><p>注意，类中函数可以不怎么在意<br>但是类外要写就要<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; s_point);</div><div class="line"></div><div class="line">A&lt;T&gt;&amp; A&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; s_point)</div><div class="line"></div><div class="line">~BS();</div><div class="line">BS&lt;T&gt;::~BS()</div></pre></td></tr></table></figure></p><p>注意到A<t>::其实是一定要插进来的。</t></p><h4 id="编译的过程"><a href="#编译的过程" class="headerlink" title="编译的过程"></a>编译的过程</h4><p>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。<br>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件<br>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件<br>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</p><h4 id="析构函数特点"><a href="#析构函数特点" class="headerlink" title="析构函数特点"></a>析构函数特点</h4><p>没有参数<br>没有重载<br>权限控制无效<br>不能手动调用<br>没有返回类型</p><h4 id="内联和宏的区别"><a href="#内联和宏的区别" class="headerlink" title="内联和宏的区别"></a>内联和宏的区别</h4><p>内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候内联函数像宏一样展开，所以取消了函数的参数压栈，减少了调用的开销。可以像调用函数一样调用内联函数，而不必担心会产生处理宏的一些问题。</p><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h4><p>explicit和构造函数一起使用，explicit指明构造函数只能显式使用，目的是为了防止不必要的隐式调用类型转换构造函数。</p><h4 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h4><p>(1)restrict是用来优化的;<br>(2)restrict只能修饰指针，restrict修饰的指针是能够访问所指区域的唯一入口，限制多个指针指向同一地址。</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。</p><p>如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。</p><h4 id="c-11特性"><a href="#c-11特性" class="headerlink" title="c++11特性"></a>c++11特性</h4><p>auto类型推导<br>范围for循环<br>lambda函数<br>Lambda表达式:简化了匿名委托的使用，让你让代码更加简洁，优雅。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 隐式返回类型</span></div><div class="line">[] (<span class="keyword">int</span>&amp; x) &#123; ++x;  &#125; <span class="comment">// 没有 return 语句 -&gt; Lambda 函数的返回类型是 'void'</span></div><div class="line">[] () &#123; ++global_x;  &#125; <span class="comment">// 没有参数，仅访问某个全局变量</span></div><div class="line">[] &#123; ++global_x; &#125; <span class="comment">// 与上一个相同，省略了 (操作符重载函数参数)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">1.</span>空:Lambda表达式不使用在同一块语句的变量，例如:[]</div><div class="line"><span class="number">2.</span>=:在块语句内的局部变量都以值传递的方式传递给Lambda,例如:[=]</div><div class="line"><span class="number">3.</span>&amp;:块语句内的局部变量以引用方式传递给Lambda,例如:[&amp;]</div><div class="line"><span class="number">4.</span>指定某个变量传递,例如:[a],[&amp;a]</div><div class="line"></div><div class="line"><span class="comment">//可以像下面这样显示指定返回类型：</span></div><div class="line">[] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z; &#125;</div><div class="line"></div><div class="line"><span class="comment">//Lambda 函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包. 闭包被定义在 Lambda 表达式声明中的方括号 [] 内。这个机制允许这些变量被按值或按引用捕获</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> f_check_map = [&amp;_map, &amp;bMapFlag]()&#123;&#125;</div><div class="line"></div><div class="line">sort(intervals.begin(), intervals.end(), [](Interval &amp;a, Interval &amp;b) &#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</div></pre></td></tr></table></figure><h5 id="override-和-final-关键字"><a href="#override-和-final-关键字" class="headerlink" title="override 和 final 关键字"></a>override 和 final 关键字</h5><p>在成员函数声明或定义中，<code>override</code> 确保该函数为虚函数并覆盖某个基类中的虚函数。若此非真则程序非良构（生成编译错误）。<br>当在虚函数声明或定义中使用时，<code>final</code>确保函数为虚并指定其不可被派生类覆盖。若这么做则程序非良构（生成编译时错误）。</p><h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><p>见下吧。</p><h4 id="移动语意和移动构造函数说一下"><a href="#移动语意和移动构造函数说一下" class="headerlink" title="移动语意和移动构造函数说一下"></a>移动语意和移动构造函数说一下</h4><p>首先说个没关系的，右值引用指向将要被销毁的对象。<br>可以用move来左值转换成右值，右值也行。注意赋值之后原先的值无法被访问（被销毁）。</p><p>再来个没关系的，如果浅拷贝a到b，销毁了a之后b就是野东西了。这是深浅拷贝到问题。</p><p>通俗一点的解释就是，拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。<br>正常的说，移动构造函数完成了内存移动，斩断了原对象和堆存的关系，并确保A-B后不再使用A，即便销毁了也没有问题的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    A(A &amp;&amp;tempa) <span class="keyword">noexcept</span> :m_pb(tempa.m_pb)&#123;</div><div class="line">        tempa.m_pb = <span class="literal">nullptr</span>;<span class="comment">//noexcept通知标准库这个移动构造函数不抛出任何异常</span></div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    B *m_pb;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么赋值同理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; src)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;src) <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">delete</span> m_pb;</div><div class="line">    m_pb = <span class="keyword">new</span> B(*(src.m_pb));</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;<span class="comment">//拷贝</span></div><div class="line">A &amp;<span class="keyword">operator</span>=(A&amp;&amp; src)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;src) <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">delete</span> m_pb;</div><div class="line">    m_pb = src.m_pb;<span class="comment">//直接拿过来用</span></div><div class="line">    src.m_pb = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;<span class="comment">//移动赋值</span></div></pre></td></tr></table></figure><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用:<br>C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，右值是由两个概念构成，将亡值和纯右值。纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等，而将亡值通常是指具有转移语义的对象，比如返回右值引用T&amp;&amp;的函数返回值等。<br>C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：<br>T &amp;&amp; a=ReturnRvale();<br>假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。<br>基于右值引用可以实现转移语义和完美转发新特性。</p><p>完美转发就是函数参数里有&amp;&amp;，那么会自动分辨出左值右值，尤其可以辨认出常量左值和左值引用。至于右值引用，其实就已经是个左值了…<br>注意要用模版函数去转发。</p><h4 id="四种cast强转"><a href="#四种cast强转" class="headerlink" title="四种cast强转"></a>四种cast强转</h4><p>1、const_cast<br>用于将const变量转为非const<br>2、static_cast<br>用于各种隐式转换，比如非const转const，void * 转指针等, static<em>cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；<br>3、dynamic </em> cast<br>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。<br>向上转换：指的是子类向基类的转换<br>向下转换：指的是基类向子类的转换<br>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。<br>4、reinterpret_cast<br>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；<br>5、为什么不使用C的强制转换？<br>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p><h4 id="c和c"><a href="#c和c" class="headerlink" title="c和c++"></a>c和c++</h4><p>设计思想上：<br>C++是面向对象的语言，而C是面向过程的结构化编程语言<br>语法上：<br>C++具有封装、继承和多态三种特性<br>C++相比C，增加多许多类型安全的功能，比如强制类型转换、<br>C++支持范式编程，比如模板类、函数模板等</p><p>C语言面向过程，重点在于算法和数据结构。。C程序的设计首先考虑的是如 何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控 制）。<br>C++语言是面向对象语言，首先考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的 问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 它在C的基础上添加了面向对象、模板等现在程序设计语言的特性。拓展了面向对象设计的内容，如类、继承、虚函数、模板和容器类等等，使之更加符合现代程序设计的需要。</p><p>解释对编译：Java是一种解释性语言，意味着其在执行时会被“翻译”为二进制形式，也就是java跑得时候必须有人（jvm）去解释它<br>内存安全：Java是一种内存安全型语言<br>指针<br>重载<br>多继承</p><h4 id="c-各种特性"><a href="#c-各种特性" class="headerlink" title="c++各种特性"></a>c++各种特性</h4><p>1.多态<br>静态（模版、重载），动态（重写）<br>2.封装</p><p>3.继承<br>单一、多重、菱形等等</p><h5 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h5><p>一个接口，多种方法<br>动态多态：    是指在程序运行时才能确定函数和实现的链接（虚函数）<br>静态多态：  是在编译期就把函数链接起来，此时即可确定调用哪个函数或模板，静态多态是由模板和重载实现的<br>overload是重载：允许同名函数的表现，参数列表／类型不同<br>override是重写：虚函数允许子类重写</p><h5 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h5><p>封装就是将抽象得到的数据和行为相结合，形成一个有机的整体</p><h5 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h5><p>继承就是新类从已有类那里得到已有的特性。 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，</p><p>子类继承基类后，可以创建子类对象来调用基类函数，变量等</p><h4 id="析构函数默认不为虚？"><a href="#析构函数默认不为虚？" class="headerlink" title="析构函数默认不为虚？"></a>析构函数默认不为虚？</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">pid_t fork(void);</div></pre></td></tr></table></figure></p><p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p><p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p><h4 id="树的父节点表示法"><a href="#树的父节点表示法" class="headerlink" title="树的父节点表示法"></a>树的父节点表示法</h4><p>树中除了根节点之外，每个节点都有且仅有一个父节点，为了记录树中节点与节点之间的父子关系，可以为每个节点增加一个parent域，用以记录该节点的父节点。</p><h4 id="I-O复用（的三种方法）（其实是socket的知识）"><a href="#I-O复用（的三种方法）（其实是socket的知识）" class="headerlink" title="I/O复用（的三种方法）（其实是socket的知识）"></a>I/O复用（的三种方法）（其实是socket的知识）</h4><p>select、poll、epoll这三组I/O复用系统调用都能同时监听多个文件描述符，他们都通过timeout参数指定要等待的时间。直到事件就绪时返回，返回值就是就绪的文件描述符的数量。</p><h5 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h5><p>该函数运行进程指示内核等待多个事件中的任何一个发生，并只有一个或多个事件发生或经历一段指定的时间后才唤醒它。</p><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构。</p><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p>epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p><p>1、select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>2、select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h3 id="算法结构的"><a href="#算法结构的" class="headerlink" title="算法结构的"></a>算法结构的</h3><h4 id="红黑树和平衡二叉树的区别？"><a href="#红黑树和平衡二叉树的区别？" class="headerlink" title="红黑树和平衡二叉树的区别？"></a>红黑树和平衡二叉树的区别？</h4><p>红黑树旋转次数变少，在插入删除多的情况下优于AVL<br>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p><h4 id="b树"><a href="#b树" class="headerlink" title="b树"></a>b树</h4><h4 id="插入查找都是logn的非树结构？"><a href="#插入查找都是logn的非树结构？" class="headerlink" title="插入查找都是logn的非树结构？"></a>插入查找都是logn的非树结构？</h4><p>跳表</p><h4 id="排队（消息队列）"><a href="#排队（消息队列）" class="headerlink" title="排队（消息队列）"></a>排队（消息队列）</h4><p>就一种思想，生产者消费者+队列</p><h4 id="混合的适合插入查询的数据结构"><a href="#混合的适合插入查询的数据结构" class="headerlink" title="混合的适合插入查询的数据结构"></a>混合的适合插入查询的数据结构</h4><p>数组+链表</p><h4 id="查询效率均等的数据结构"><a href="#查询效率均等的数据结构" class="headerlink" title="查询效率均等的数据结构"></a>查询效率均等的数据结构</h4><p>B+Tree 深度一致。</p><h4 id="索引是什么作用"><a href="#索引是什么作用" class="headerlink" title="索引是什么作用"></a>索引是什么作用</h4><p>加快查找速度，一般用b+树实现<br>与红黑树相比，有更少的查找次数、更好的磁盘预读性<br>1.b+tree索引，用于查找、排序、分组<br>2.哈希索引，无法排序分组，只能精确查找，不能部分、范围。<br>3.全文索引，倒排索引实现</p><p>大大减少了服务器需要扫描的数据行数<br>帮助服务器避免排序分组、避免创建临时表<br>随机io变为顺序io</p><h4 id="哈希三种检测冲突"><a href="#哈希三种检测冲突" class="headerlink" title="哈希三种检测冲突"></a>哈希三种检测冲突</h4><p>1.拉链法：拉链法使用链表来存储 hash 值相同的键，从而解决冲突。查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找。<br>2.再散列：线性探测（当冲突发生时，向前探测一个空位来存储冲突的键），二次探测、伪随机探测<br>3.再哈希：就继续hash直到不冲突<br>4.公共溢出区：建立一个公共溢出区域，把hash冲突的元素都放在该溢出区里。查找时，如果发现hash表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。</p><h4 id="树的父节点表示法-1"><a href="#树的父节点表示法-1" class="headerlink" title="树的父节点表示法"></a>树的父节点表示法</h4><p>树中除了根节点之外，每个节点都有且仅有一个父节点，为了记录树中节点与节点之间的父子关系，可以为每个节点增加一个parent域，用以记录该节点的父节点。</p><h4 id="池化思想"><a href="#池化思想" class="headerlink" title="池化思想"></a>池化思想</h4><h3 id="操作系统的"><a href="#操作系统的" class="headerlink" title="操作系统的"></a>操作系统的</h3><h4 id="线程／进程"><a href="#线程／进程" class="headerlink" title="线程／进程"></a>线程／进程</h4><h5 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h5><p>线程是进程里的一个执行单元<br>线程调度分配的基本单位／进程是拥有资源的基本单位<br>不同进程可以并发／同进程的多个线程可以并发<br>进程拥有资源／线程访问进程的自由<br>创建撤销进程时，分配回收资源／线程则很少</p><h5 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h5><p>进程间通信的方式：<br>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p><p>1.管道：<br>管道主要包括无名管道和命名管道:<strong>管道可用于具有亲缘关系的父子进程间的通信</strong>，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信<br>1.1 普通管道PIPE：<br>1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端<br>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）<br>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。<br>1.2 命名管道FIFO：<br>1)FIFO可以在无关的进程之间交换数据<br>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><ol><li>系统IPC（进程间通信）：<br>2.1 消息队列<br>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；<br>特点：<br>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。<br>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。<br>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。<br>2.2 信号量semaphore<br>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。<br>特点：<br>1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。<br>2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。<br>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减意正整数。<br>4)支持信号量组。<br>2.3 信号signal<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>2.4 共享内存（Shared Memory）<br>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等<br>特点：<br>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取<br>2)因为多个进程可以同时操作，所以需要进行同步<br>3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li><li>套接字SOCKET：<br>socket也是一种进程间通信机制，与其他通信机制不同的是，<strong>它可用于不同主机之间的进程通信。</strong></li></ol><h5 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h5><p>  线程间通信的方式:（也是线程间同步的方式）<br>  临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；<br>  互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问<br>  信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作<br>  事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p><p>需要注意的是，临界区是效率最高的，因为基本不需要其他的开销，二内核对象涉及到用户态和内核态的切换，开销较大，另外，关键段、互斥量具有[线程所有权]的概念，因此只可以用于线程之间互斥，而不能用到同步中。只有互斥量能完美解决进程意外终止所造成的“遗弃问题”。</p><h5 id="扯些线程"><a href="#扯些线程" class="headerlink" title="扯些线程"></a>扯些线程</h5><p>线程通信主要作用为线程同步<br>多线程就是一个进程里有多个线程<br>但是多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。</p><p>基于进程的多任务处理是程序的并发执行。<br>基于线程的多任务处理是同一程序的片段的并发执行。</p><p>c++11有线程库</p><p>互斥是一种特殊的同步</p><h5 id="线／进程的基本概念"><a href="#线／进程的基本概念" class="headerlink" title="线／进程的基本概念"></a>线／进程的基本概念</h5><p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p><p>线程，有时称为轻量级进程，是CPU调度和分派的基本单位；它由线程ID、程序计数器、寄存器集合和堆栈组成。它与属于同一进程的其他线程共享其代码段、数据段和其他操作系统资源（如打开文件和信号）。</p><p>线程有四种状态：新生状态、可运行状态、被阻塞状态、死亡状态</p><h5 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a>多线程同步和互斥有几种实现方法，都是什么？</h5><p>见上通信</p><h5 id="多进程同步"><a href="#多进程同步" class="headerlink" title="多进程同步"></a>多进程同步</h5><p>信号量<br>互斥锁<br>管程</p><p>好了这问题就这样吧，乱七八糟的也说不清楚。</p><h5 id="互斥和同步"><a href="#互斥和同步" class="headerlink" title="互斥和同步"></a>互斥和同步</h5><p>所谓同步，表示有先有后，比较正式的解释是“线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。”所谓互斥，比较正式的说明是“线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。”表示不能同时访问，也是个顺序问题，所以互斥是一种特殊的同步操作。</p><p>举个例子，设有一个全局变量global，为了保证线程安全，我们规定只有当主线程修改了global之后下一个子线程才能访问global，这就需要同步主线程与子线程，可用关键段实现。当一个子线程访问global的时候另一个线程不能访问global，那么就需要互斥。</p><h5 id="多线程中栈与堆是公有的还是私有的"><a href="#多线程中栈与堆是公有的还是私有的" class="headerlink" title="多线程中栈与堆是公有的还是私有的"></a>多线程中栈与堆是公有的还是私有的</h5><p>栈私有, 堆公有</p><h5 id="以下多线程对int型变量x的操作，哪几个需要进行同步："><a href="#以下多线程对int型变量x的操作，哪几个需要进行同步：" class="headerlink" title="以下多线程对int型变量x的操作，哪几个需要进行同步："></a>以下多线程对int型变量x的操作，哪几个需要进行同步：</h5><p>　　　　A. x=y;      B. x++;    C. ++x;    D. x=1;</p><p>答案是ＡＢＣ，显然，y的写入与x读y要同步，x++和++x都要知道x之前的值，所以也要同步。</p><h5 id="在Windows编程中互斥量与临界区比较类似，请分析一下二者的主要区别。"><a href="#在Windows编程中互斥量与临界区比较类似，请分析一下二者的主要区别。" class="headerlink" title="在Windows编程中互斥量与临界区比较类似，请分析一下二者的主要区别。"></a>在Windows编程中互斥量与临界区比较类似，请分析一下二者的主要区别。</h5><p>　　  1）互斥量是内核对象，所以它比临界区更加耗费资源，但是它可以命名，因此可以被其它进程访问</p><p>　　  2）从目的是来说，临界区是通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>    互斥量是为协调共同对一个共享资源的单独访问而设计的。 </p><h5 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h5><p>当多个线程并发访问同一个资源对象时，可能会出现线程不安全的问题，比如现有100个高铁座位,现在有请三个窗口(A,B,C)同时售票.，此时使用多线程技术来实现这个案例.<br>。。。<br>为什么编号为84的座位号被3个窗口售出了？<br>当A窗口打印84座位号，还没打印完的时候，其他两个线程就也进入到了84号座位票的分配操作中，所以导致线程安全问题。<br>要解决上述多线程并发访问多一个资源的安全性问题，就必须得保证打印座位号和座位号总数减1操作,必须同步完成.即是说，A线程进入操作的时候,B和C线程只能在外等着,A操作结束,A和B和C才有机会进入代码去执行.</p><p>解决多线程并发访问资源的安全问题，有三种方式：<br>方式1:同步代码块<br>方式2:同步方法<br>方式3:锁机制(Lock)</p><h5 id="协程的作用"><a href="#协程的作用" class="headerlink" title="协程的作用"></a>协程的作用</h5><blockquote><p>没有啥复杂的东西，考虑清楚需求，就可以很自然的衍生出这些解决方案。<br>一开始大家想要同一时间执行那么三五个程序，大家能一块跑一跑。特别是UI什么的，别一上计算量比较大的玩意就跟死机一样。于是就有了并发，从程序员的角度可以看成是多个独立的逻辑流。内部可以是多cpu并行，也可以是单cpu时间分片，能快速的切换逻辑流，看起来像是大家一块跑的就行。<br>但是一块跑就有问题了。我计算到一半，刚把多次方程解到最后一步，你突然插进来，我的中间状态咋办，我用来储存的内存被你覆盖了咋办？所以跑在一个cpu里面的并发都需要处理上下文切换的问题。进程就是这样抽象出来个一个概念，搭配虚拟内存、进程表之类的东西，用来管理独立的程序运行、切换。<br>后来一电脑上有了好几个cpu，好咧，大家都别闲着，一人跑一进程。就是所谓的并行。<br>因为程序的使用涉及大量的计算机资源配置，把这活随意的交给用户程序，非常容易让整个系统分分钟被搞跪，资源分配也很难做到相对的公平。所以核心的操作需要陷入内核(kernel)，切换到操作系统，让老大帮你来做。<br>有的时候碰着I/O访问，阻塞了后面所有的计算。空着也是空着，老大就直接把CPU切换到其他进程，让人家先用着。当然除了I\O阻塞，还有时钟阻塞等等。一开始大家都这样弄，后来发现不成，太慢了。为啥呀，一切换进程得反复进入内核，置换掉一大堆状态。进程数一高，大部分系统资源就被进程切换给吃掉了。后来搞出线程的概念，大致意思就是，这个地方阻塞了，但我还有其他地方的逻辑流可以计算，这些逻辑流是共享一个地址空间的，不用特别麻烦的切换页表、刷新TLB，只要把寄存器刷新一遍就行，能比切换进程开销少点。<br>如果连时钟阻塞、 线程切换这些功能我们都不需要了，自己在进程里面写一个逻辑流调度的东西。那么我们即可以利用到并发优势，又可以避免反复系统调用，还有进程切换造成的开销，分分钟给你上几千个逻辑流不费力。这就是用户态线程。<br>从上面可以看到，实现一个用户态线程有两个必须要处理的问题：一是碰着阻塞式I\O会导致整个进程被挂起；二是由于缺乏时钟阻塞，进程需要自己拥有调度线程的能力。如果一种实现使得每个线程需要自己通过调用某个方法，主动交出控制权。那么我们就称这种用户态线程是协作式的，即是协程。<br>本质上协程就是用户空间下的线程。</p></blockquote><h4 id="cpu调度进程方式"><a href="#cpu调度进程方式" class="headerlink" title="cpu调度进程方式"></a>cpu调度进程方式</h4><p>即按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程，如果没有就绪进程，系统会安排一个系统空闲进程或idle进程。</p><p>FCFS<br>最短作业优先SJF<br>最短剩余时间优先SRTN<br>最高响应比优先算法HRRN<br>时间片轮转调度算法（Round Robin——RR）<br>优先级调度算法<br>多级反馈</p><h5 id="时间片轮转原理"><a href="#时间片轮转原理" class="headerlink" title="时间片轮转原理"></a>时间片轮转原理</h5><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程</p><h5 id="线程切换时发生了什么"><a href="#线程切换时发生了什么" class="headerlink" title="线程切换时发生了什么"></a>线程切换时发生了什么</h5><p>发生了一次上下文切换——保存上个任务状态，切换到下个任务。（信息会存在结构体里扔进等待队列）</p><h4 id="死锁及避免"><a href="#死锁及避免" class="headerlink" title="死锁及避免"></a>死锁及避免</h4><p>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。<br>占有和等待：已经得到了某个资源的进程可以再请求新的资源。<br>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。<br>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</p><p>避免：银行家算法</p><p>解除：破坏条件。<br>利用抢占恢复<br>利用回滚恢复<br>通过杀死进程恢复</p><h4 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h4><h5 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h5><ol><li>最佳OPT</li><li>最近最久未使用LRU</li><li>最近未使用NRU</li><li>先进先出FIFO</li><li>第二次机会算法</li><li>时钟</li></ol><h5 id="LRU原理"><a href="#LRU原理" class="headerlink" title="LRU原理"></a>LRU原理</h5><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。代码见手撕</p><h5 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h5><p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p><h5 id="页面抖动和驻留集"><a href="#页面抖动和驻留集" class="headerlink" title="页面抖动和驻留集"></a>页面抖动和驻留集</h5><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。<br>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p><h5 id="驻留集大小"><a href="#驻留集大小" class="headerlink" title="驻留集大小"></a>驻留集大小</h5><p>对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页。也就是说，给特定的进程分配多大的主存空间，这需要考虑以下几点：<br>分配给一个进程的存储量越小，在任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率。<br>如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高。<br>如桌页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</p><p>基于这些因素，现代操作系统通常采用三种策略：<br>固定分配局部置换。它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。<br>可变分配全局置换。这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。<br>可变分配局部置换。它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度； 反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p><h5 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h5><p>操作系统的虚拟地址空间的技术，进程调度，以及缓存磁盘文件系统中最近被使用的磁盘块等都用到了局部性原理<br>具体的来说就是我一块缓存，每次读一个数据很亏，既然转到了那我不如每次读连续的一段数据，用不用得到另说，但是符合局部性的就会很快。</p><h5 id="虚拟地址空间技术"><a href="#虚拟地址空间技术" class="headerlink" title="虚拟地址空间技术"></a>虚拟地址空间技术</h5><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 <strong>事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。</strong>还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p><p>请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p><h4 id="操作系统对内存如何管理"><a href="#操作系统对内存如何管理" class="headerlink" title="操作系统对内存如何管理"></a>操作系统对内存如何管理</h4><p>段页式<br>那么，引入分段存储管理方式的目的，则主要是为了满足用户（程序员）在编程和使用上多方面的要求<br>页提高内存利用率<br>内存中连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的大块空间，但须为之付出很大开销。<br>如果允许将一个进程直接分散地装入到许多不相邻的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式。</p><h5 id="分页与分段的区别"><a href="#分页与分段的区别" class="headerlink" title="分页与分段的区别"></a>分页与分段的区别</h5><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。<br>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>段向用户提供二维地址空间；页向用户提供的是一维地址空间<br>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</p><h4 id="阻塞与非阻塞的区别／同步与异步"><a href="#阻塞与非阻塞的区别／同步与异步" class="headerlink" title="阻塞与非阻塞的区别／同步与异步"></a>阻塞与非阻塞的区别／同步与异步</h4><p>比如我在线程A中调用了fun()函数。<br>同步/异步：针对的被调用者的状态。也就是fun函数。（也就是上面的烧水壶）<br>同步是指fun如果没有结果就不会返回，除非有结果了。<br>异步是指fun在被调用之后就立即返回了。返回结果之后再通知调用者（可以用信号、回调之类的实现）。</p><p>阻塞/非阻塞：主要是针对调用者的，是指程序在等待结果时的状态。（也就是上面的老张在等水开时的状态）<br>阻塞是指调用线程会被挂起，不做什么别的事情。在得到结果之后才会返回。<br>非阻塞是指不能立即得到结果，当前线程不会被挂起，还可以做别的事情。</p><p>老张把水壶放到火上，立等水开。（同步阻塞）<br>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</p><h4 id="lib和dll区别"><a href="#lib和dll区别" class="headerlink" title="lib和dll区别"></a>lib和dll区别</h4><p>（1）lib是编译时用到的，dll是运行时用到的。如果要完成源代码的编译，只需要lib；如果要使动态链接的程序运行起来，只需要dll。<br>（2）如果有dll文件，那么lib一般是一些索引信息，记录了dll中函数的入口和位置，dll中是函数的具体内容；如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。使用静态编译的lib文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行。<br>（3）动态链接的情况下，有两个文件：一个是LIB文件，一个是DLL文件。LIB包含被DLL导出的函数名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到DLL文件。</p><h5 id="动态静态链接库的优缺点"><a href="#动态静态链接库的优缺点" class="headerlink" title="动态静态链接库的优缺点"></a>动态静态链接库的优缺点</h5><p>1 静态链接库的优点<br> (1) 代码装载速度快，执行速度略比动态链接库快；<br> (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 </p><p>2 动态链接库的优点<br> (1) 更加节省内存并减少页面交换；<br> (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；<br> (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；<br> (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。</p><p>3 不足之处<br> (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；<br> (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。</p><h3 id="计算机网络的"><a href="#计算机网络的" class="headerlink" title="计算机网络的"></a>计算机网络的</h3><h4 id="各层作用（协助理解）"><a href="#各层作用（协助理解）" class="headerlink" title="各层作用（协助理解）"></a>各层作用（协助理解）</h4><p>数据链路层<br>是负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。 传输有地址的帧以及错误检测功能 。<br>一、流量控制<br>二、错误检测和纠正<br>在这一层，数据的单位称为 帧 （frame）</p><p>网络层<br>负责相邻计算机之间的通信。<br>一、处理来自传输层的分组发送请求<br>二、处理输入数据报<br>三、处理路径、流控、拥塞等问题<br>网络层包括：<br>IP是网络层的核心，通过路由选择将下一跳IP封装后交给接口层。IP数据报是无连接服务。 　　<br>ICMP是网络层的补充，可以回送报文。用来检测网络是否通畅。<br>ARP是正向地址解析协议，通过已知的IP，寻找对应主机的MAC地址。<br>RARP是反向地址解析协议，通过MAC地址确定IP地址。比如无盘工作站和DHCP服务。<br>在这一层，数据的单位 称 数据包 （packet）</p><p>传输层<br>网络层负责点到点（point-to-point）的传输（这里的”点”指主机或路由器）,而传输层负责端到端（end-to-end）的传输（这里的”端”指源主机和目的主机）<br>提供应用程序间的通信。其功能包括：<br>一、格式化信息流；<br>二、提供可靠传输。</p><p>四、应用层<br>向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。</p><h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p>以太网特点：传输速率高;结构简单;工作可靠<br>以太网上使用两种标准帧格式。<br>当Type字段值小于等于1500（或者十六进制的0x05DC）时，帧使用的是IEEE 802.3格式。<br>当Type字段值大于等于1536 （或者十六进制的0x0600）时，帧使用的是Ethernet II格式。<br>以太网中大多数的数据帧使用的是Ethernet II格式。</p><p>Ethernet II：<br>DMAC（Destination MAC）是目的MAC地址。DMAC字段长度为6个字节，标识帧的接收者。<br>SMAC（Source MAC）是源MAC地址。SMAC字段长度为6个字节，标识帧的发送者。<br>类型字段（Type）用于标识数据字段中包含的高层协议，该字段长度为2个字节。类型字段取值为0x0800的帧代表IP协议帧；类型字段取值为0806的帧代表ARP协议帧。<br>数据字段(Data)是网络层数据，最小长度必须为46字节以保证帧长至少为64字节，数据字段的最大长度为1500字节。<br>循环冗余校验字段（FCS）提供了一种错误检测机制。该字段长度为4个字节。</p><p>IEEE802.3<br>DMAC<br>SMAC<br>Length字段定义了Data字段包含的字节数。<br>逻辑链路控制LLC由目的服务访问点DSAP、源服务访问点SSAP和Control字段组成。<br>子网访问控制SNAP由机构代码和类型（Type）字段组成。<br>Data<br>FCS</p><p>数据链路层基于MAC地址进行帧的传输</p><h4 id="集线器、交换机、路由器的作用"><a href="#集线器、交换机、路由器的作用" class="headerlink" title="集线器、交换机、路由器的作用"></a>集线器、交换机、路由器的作用</h4><p>1.集线器：相当于一个中继器，它可以放大传输的信号，数据传输的方式是共享的，比如一个集线器连接了8个主机，当1号想向8号发送信息时，数据会在这条线路中进行广播。另外，集线器不能分割冲突域也不能分割广播域。</p><p>2.交换机：交换机相当于一个智能的多端口集线器，其运行在OSI模型的第二层即数据链路层，所以交换机通过MAC地址寻找主机，它是独享网络。数据进行端到端的传输。它可以分割冲突域但是不能分割广播域。</p><p>3.网桥：网桥是一个网络硬件协议翻译器。它能让两种不同数据链路层协议的网段进行信息的交流。它是一个聪明的中继器，在数据链路层中实现局域网的互联，运行在数据链路层上。它通过接受，存储，地址过滤和转发的方式实现互联网络之间的通信，它的缺点是没有流量监控，当数据流量太大是，就会帧丢失，另外，网桥在转发是要先进行帧缓存，因此会比中继器延迟。最后，它可以分割冲突域但是不能广播域。</p><p>4，路由器：路由器又称为网关设备（Gateway），主要作用是为数据进行分组转发，流量监控，并且为分组提供一个最优的网络传输路径，它跟交换机的区别在于路由器运行在网络层上，而交换机运行在数据链路层，所以路由器利用IP地址来寻址。另外，路由器可以分割冲突域也能分割广播域。</p><p>村里打帝国时代的联机。</p><h4 id="ARP-协议的作用，以及维护-ARP-缓存的过程"><a href="#ARP-协议的作用，以及维护-ARP-缓存的过程" class="headerlink" title="ARP 协议的作用，以及维护 ARP 缓存的过程"></a>ARP 协议的作用，以及维护 ARP 缓存的过程</h4><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><h4 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h4><p>tcp 传输控制协议<br>udp 用户数据报协议 包头只有端口号和长度校验和<br>udp 需要资源少（简单）、需要处理快（无拥塞控制可以丢包）、不需要一对一（不面向连接，一对多）<br>tcp包头：<br>端口号 序号（有序了） 确认序号（解决丢包） 状态位（维护状态） 窗口大小<br>三次握手建立连接<br>四次握手断开连接<br>可靠传输：<br>确认应答（发ack回来）、超时重传（重传去重）、滑动窗口（快重传）<br>拥塞控制：<br>慢启动-拥塞窗口、延迟应答</p><p>区别：<br>TCP 是面向连接的，UDP 是面向无连接的<br>UDP程序结构较简单<br>TCP 是面向字节流的，UDP 是基于数据报的<br>TCP 保证数据正确性，UDP 可能丢包<br>TCP 保证数据顺序，UDP 不保证</p><p>什么是面向连接：<br>在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会</p><h5 id="TCP可靠连接："><a href="#TCP可靠连接：" class="headerlink" title="TCP可靠连接："></a>TCP可靠连接：</h5><p>通过 TCP 连接传输的数据无差错。<br>TCP 报文头里面的序号能使 TCP 的数据按序到达<br>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制<br>注意ack回复是有延迟的，ack丢了无妨，后面补上可知信息。包丢了就会重复回复ack，然后快重传。<br>其中，超时重传如下：如果没收到我发出的包的ack，在一定时间后会重传。配合窗口效率最大化。TCP为了保证任何环境下都能保持较高性能的通信, 因此会动态计算这个最大超时时间，累计过一定次数就关闭连接，如果收到重复就靠靠序列号去重。<br>TCP 拥有流量控制及拥塞控制的机制</p><h5 id="三次握手，四次握手"><a href="#三次握手，四次握手" class="headerlink" title="三次握手，四次握手"></a>三次握手，四次握手</h5><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><h5 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h5><p>为什么要有Time_wait<br>1、确保有足够的时间让对方收到ACK包；（一来一去刚好是2MSL）<br>2、避免新旧连接混淆<br>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h5 id="拥塞控制的方式"><a href="#拥塞控制的方式" class="headerlink" title="拥塞控制的方式"></a>拥塞控制的方式</h5><p>慢启动：<br>从小到大逐渐增大发送端的拥塞控制窗口数值</p><p>拥塞避免算法如下：<br>（1）TCP连接初始化，将拥塞窗口设置为1<br>（2）执行慢开始算法，cwnd按指数规律增长，知道cwind=ssthress时，开始执行拥塞避免算法，cwnd按线性规律增长<br>（3）当网络发送拥塞，把ssthresh值更新为拥塞前ssthresh的一半，cwnd重新设置为1，然后再执行</p><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）<br>而不要等到自己发送数据时捎带确认。快重传算法规定发送方只要已收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待</p><h5 id="kcp"><a href="#kcp" class="headerlink" title="kcp"></a>kcp</h5><p>KCP是一个可靠的传输协议，UDP本身是不可靠的，所以需要额外信息来保证传输数据的可靠性。因此，我们需要在传输的数据上增加一个包头。用于确保数据的可靠、有序。</p><p>conv:连接号。UDP是无连接的，conv用于表示来自于哪个客户端。对连接的一种替代<br>cmd:命令字。如，IKCP_CMD_ACK确认命令，IKCP_CMD_WASK接收窗口大小询问命令，IKCP_CMD_WINS接收窗口大小告知命令，<br>frg:分片，用户数据可能会被分成多个KCP包，发送出去<br>wnd:接收窗口大小，发送方的发送窗口不能超过接收方给出的数值<br>ts:时间序列<br>sn:序列号<br>una:下一个可接收的序列号。其实就是确认号，收到sn=10的包，una为11<br>len：数据长度<br>data:用户数据</p><p>快速重传机制—无延迟ACK回复模式</p><blockquote><p>假如开启KCP的快速重传机制，并且设置了当重复的ACK个数大于resend时候，直接进行重传。 当发送端发送了1,2,3,4,5五个包，然后收到远端的ACK：1,3,4,5。当收到ACK3时，KCP知道2被跳过1次，当收到ACK4的时候，KCP知道2被跳过2次，当次数大于等于设置的resend的值的时候，不用等到超时，可直接重传2号包。这就是KCP的快速重传机制。</p></blockquote><p>KCP是选择性重传，只重传真正丢失的数据包。<br>超时重传1.5倍增长<br>流量控制同tcp<br>KCP的ACK是否延迟发送可以调节。<br>拥塞控制可以关闭</p><p>本质而言，kcp就是一arq协议。只是tcp是为流量设计的，kcp是为流速设计的。</p><h5 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h5><p>站在传输层的角度, TCP是一个一个报文传过来的. 按照序号排好序放在缓冲区中.<br>站在应用层的角度, 看到的只是一串连续的字节数据.</p><p>那么如何避免粘包问题呢?<br>归根结底就是一句话, 明确两个包之间的「边界」</p><h4 id="udp是如何进行一对多传输的"><a href="#udp是如何进行一对多传输的" class="headerlink" title="udp是如何进行一对多传输的"></a>udp是如何进行一对多传输的</h4><p>广播：一对所有，只能在子网中传播（在同一个路由器中传播），子网上的所有节点都能收到信息<br>组播：一对多，一个发送者对多个接收者<br>多播，也称为“组播”，将网络中同一业务类型主机进行了逻辑上的分组，进行数据收发的时候其数据仅仅在同一分组中进行，其他的主机没有加入此分组不能收发对应的数据。</p><h5 id="广播时socket是什么样子的"><a href="#广播时socket是什么样子的" class="headerlink" title="广播时socket是什么样子的"></a>广播时socket是什么样子的</h5><p><img src="https://img-blog.csdnimg.cn/2018103110011619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjc1MDYyMw==,size_5,color_FFFFFF,t_70" alt="网图"></p><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><h5 id="Socket是什么呢？"><a href="#Socket是什么呢？" class="headerlink" title="Socket是什么呢？"></a>Socket是什么呢？</h5><blockquote><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>Socket 的中文翻译过来就是“套接字”。套接字是什么，我们先来看看它的英文含义：插座。<br>Socket 就像一个电话插座，负责连通两端的电话，进行点对点通信，让电话可以进行通信，端口就像插座上的孔，端口不能同时被其他进程占用。而我们建立连接就像把插头插在这个插座上，创建一个 Socket 实例开始监听后，这个电话插座就时刻监听着消息的传入，谁拨通我这个“IP 地址和端口”，我就接通谁。<br>实际上，Socket 是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作抽象为几个简单的接口，供应用层调用实现进程在网络中的通信。Socket 起源于 UNIX，在 UNIX 一切皆文件的思想下，进程间通信就被冠名为文件描述符（file descriptor），Socket 是一种“打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个“文件”，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p></blockquote><p><img src="https://image-static.segmentfault.com/424/131/4241315319-5818ad16c6539_articlex" alt="img"></p><p>1）基于TCP的socket：<br>1、服务器端程序：<br>1创建一个socket，用函数socket()<br>2绑定IP地址、端口等信息到socket上，用函数bind()<br>3设置允许的最大连接数，用函数listen()<br>4接收客户端上来的连接，用函数accept()<br>5收发数据，用函数send()和recv()，或者read()和write()<br>6关闭网络连接</p><p>2、客户端程序：<br>1创建一个socket，用函数socket()<br>2设置要连接的对方的IP地址和端口等属性<br>3连接服务器，用函数connect()<br>4收发数据，用函数send()和recv()，或read()和write()<br>5关闭网络连接</p><p>2）基于UDP的socket：<br>1、服务器端流程<br>1-建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。<br>2-设置服务器地址和侦听端口，初始化要绑定的网络地址结构。<br>3-绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。<br>4-接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。<br>5-向客户端发送数据，使用sendto()函数向服务器主机发送数据。<br>6-关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</p><p>2、客户端流程<br>1-建立套接字文件描述符，socket()。<br>2-设置服务器地址和端口，struct sockaddr。<br>3-向服务器发送数据，sendto()。<br>4-接收服务器的数据，recvfrom()。<br>5-关闭套接字，close()。</p><h4 id="ip报文头"><a href="#ip报文头" class="headerlink" title="ip报文头"></a>ip报文头</h4><p>IP协议是网络层的主要协议，为上层传输层提供无连接、无状态、不可靠的服务。优点是简单高效。无状态是指各个IP报文是独立传送的，不同步传输状态的信息，所以容易发生重复和乱序的情况。不可靠是指IP协议不能保证数据报一定能被送达，可靠性主要是通过传输层的TCP协议来保证的。</p><p>4位版本，4位首部长度，8位服务类型，16位总长度<br>16位标识（每个数据报计数器+1，同计数分片拼装），3位标志（后面还有没，可否分片），13位片位移（较长的分组在分片后，某片在原分组中的相对位置）<br>8位生存时间TTL（指明数据报在网络中至多可经过多少个路由器），8位协议，16位首部校验和<br>32位源ip<br>32位目的ip</p><h5 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h5><p>通常被认为是IP层的组成部分，一般被IP层或更高层（TCP、UDP）使用。<br>ICMP报文是在IP数据报内部被传输的，即ip数据报如下<br>ip首部-icmp报文<br>报文的前4个字节都一样： 8bit类型，8bit代码，16bit检验和。</p><h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>ping程序是由Mike Muuss编写，目的是为了测试一个主机是否能到达。<br>该程序的原理就是向目的主机发送一个请求回显类型（ICMP众多类型的一个，类型是8，代码是0）的ICMP报文，并等待返回ICMP回显应答（ICMP众多类型的一个，类型是0，代码是0）。</p><h5 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h5><p>traceroute程序–可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由情况。</p><p>ping程序中也提供了查看IP记录路由选项，为啥还要再搞一个traceroute咧？主要原因还是因为IP首部选项能存储的ip数量太少了，最多9个。如果只考虑去和回的一个方向，那么最多只能存储4-5个路由，这在现在的互联网规模来看显然是不太满足的。<br>traceroute几个核心知识：利用TTL通过路由减1，直到变为1或者0时（路由不会传送TTL为0的包），路由就会发送超时类型的ICMP报文通知源端主机。利用UDP发送一般不常见的端口号给目的主机，当真正到达目的主机时，目的主机会发送一个端口不可达错误的ICMP报文（在未到达时，是路由返回的超时类型的ICMP报文，需要辨识开）。源端主机根据这个确认是否到达。TTL开始是1，逐渐递增。<br>整个就一骗子程序，疯狂骗路由ip</p><h4 id="什么是端口"><a href="#什么是端口" class="headerlink" title="什么是端口?"></a>什么是端口?</h4><blockquote><p>我们之前在初识进程中知道，单个计算机进程是用进程标示符（PID）标志的。但是在互联网的大环境下，操作系统很多，不同的操作系统有不同的进程标识符，所以仅仅用进程标示符是不足够的。<br>因此，为了让不同操作系统的计算机应用程序能够互相通信，就必须用统一的方法对进程进行标志<br>但就算使用统一的标示符进行标识，也存在问题</p><p>1.进程的创建和撤销是动态的，通信的一方几乎无法识别对方的进程<br>2.我们需要主机提供的功能来识别通信的重点，但是我们无法识别具体的进程是哪个<br>所以：运输层使用“”协议端口号“来解决这个问题，就是端口号。<br>端口号解决了传输层的分用问题</p></blockquote><p>常见端口：1.HTTP协议代理服务器常用端口号：80/8080/3128/8081/9098</p><p>2.SOCKS代理协议服务器常用端口号：1080</p><p>3.FTP（文件传输）协议代理服务器常用端口号：21</p><p>4.Telnet（远程登录）协议代理服务器常用端口号：23</p><p>5.DNS端口为53 UDP,是用来做DNS解析的</p><p>HTTP服务器，默认端口号为80/tcp（木马Executor开放此端口）</p><p>HTTPS（securely transferring web pages）服务器，默认端口号为443/tcp 443/udp</p><p>SSH（安全登录）、SCP（文件传输）、端口号重定向，默认的端口号为22/tcp</p><h4 id="DNS全过程"><a href="#DNS全过程" class="headerlink" title="DNS全过程"></a>DNS全过程</h4><p>1.检查浏览器缓存中是否缓存过该域名对应的IP地址<br>2.如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP<br>3.向本地域名解析服务系统发起域名解析的请求<br>4.向根域名解析服务器发起域名解析请求<br>5.根域名服务器返回gTLD（通用顶级域）域名解析服务器地址<br>6.向gTLD服务器发起解析请求<br>7.接受请求并返回Name Server服务器<br>8.返回IP地址给本地服务器<br>9.本地域名服务器缓存解析结果<br>10.返回给用户</p><p>多使用UDP</p><p>负载均衡<br>将流量均摊到多个服务器上</p><p>一个域名访问多个IP地址。当客户端请求解析域名时，DNS服务器查询文件中的记录按顺序返回不同的解析结果，从而将客户访问引导到不同的服务器上去，从而实现负载均衡。</p><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><blockquote><p>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。<br>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。<br>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。<br>浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p></blockquote><h5 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h5><p>HTTPS和HTTP的区别主要如下：<br>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h4 id="帧同步，状态同步的实现原理"><a href="#帧同步，状态同步的实现原理" class="headerlink" title="帧同步，状态同步的实现原理"></a>帧同步，状态同步的实现原理</h4><p>同步问题的本质是一致性的问题，在同一局多人游戏的过程中，玩家A看到玩家B的状态，应该跟玩家B自身看到自己的状态相一致。延迟是造成不一致的本质原因，假设理想情况下双方的网络时延都为0，那两者应该是同步的，但是在现实情况中，往往是不可能的，本文讨论的同步机制，就是为了解决一致性问题而产生的，对于不同的游戏类型，不同的团队技术积累，可以根据自身情况采取不同的同步机制技术方案。</p><h5 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h5><p>状态同步主要是指客户端发送游戏动作到服务器，服务器收到后对游戏行为结果进行计算，<br>然后通过广播下发游戏各种状态到客户端，客户端受到状态信息后进行UI层展示或处理。<br>这种方式类似于核心逻辑计算都在服务器端进行，客户端主要负责上传操作动作等请求数据，<br>一般回合制游戏主要采用这种方式</p><h5 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h5><p>客户端发送游戏动作到服务器，服务器广播转发所有客户端的动作（或者客户端直接通过P2P技术发送），客户端根据收到的所有游戏动作来做游戏运算和显示。这种做法等于客户端之间互相远程控制其他客户端上的游戏软件。早期的IPX网络游戏，如红色警戒、帝国时代、星际争霸，甚至大量的支持网络连线双打的游戏机模拟器，都是这种方式</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>S.O.L.I.D<br>简写    全拼    中文翻译<br>SRP    The Single Responsibility Principle    单一责任原则<br>OCP    The Open Closed Principle    开放封闭原则<br>LSP    The Liskov Substitution Principle    里氏替换原则<br>ISP    The Interface Segregation Principle    接口分离原则<br>DIP    The Dependency Inversion Principle    依赖倒置原则</p><ol><li>单一责任原则<br>修改一个类的原因应该只有一个。</li></ol><p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><ol><li>开放封闭原则<br>类应该对扩展开放，对修改关闭。</li></ol><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p><p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><ol><li>里氏替换原则<br>子类对象必须能够替换掉所有父类对象。</li></ol><p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p><p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><ol><li>接口分离原则<br>不应该强迫客户依赖于它们不用的方法。</li></ol><p>因此使用多个专门的接口比使用单一的总接口要好。</p><ol><li>依赖倒置原则<br>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>抽象不应该依赖于细节，细节应该依赖于抽象。</li></ol><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><p>任何变量都不应该持有一个指向具体类的指针或者引用；<br>任何类都不应该从具体类派生；<br>任何方法都不应该覆写它的任何基类中的已经实现的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;惨，是真的惨。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
    
      <category term="面试" scheme="http://oodtoodt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>训练专题</title>
    <link href="http://oodtoodt.github.io/2018/08/29/%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD/%E8%AE%AD%E7%BB%83%E4%B8%93%E9%A2%98/"/>
    <id>http://oodtoodt.github.io/2018/08/29/%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD/%E8%AE%AD%E7%BB%83%E4%B8%93%E9%A2%98/</id>
    <published>2018-08-29T08:47:45.000Z</published>
    <updated>2018-09-10T09:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新区域赛的题。。大概会更新的吧。咕咕咕</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><em>2018-09-05 Wed 00:14 </em>更新到第22次训练</p><hr><h1 id="暑期训练"><a href="#暑期训练" class="headerlink" title="暑期训练"></a>暑期训练</h1><h2 id="第一次训练。"><a href="#第一次训练。" class="headerlink" title="第一次训练。"></a>第一次训练。</h2><p>emmm 08年的题感觉还是比较容易的。</p><p>我还没拿到题琦神就已经看出A题是水题了，裸的上升子序列。</p><p>在lyy手写板子的时候我看出i题是个水题，求抛物线最大值的b/2a….之后顺利切掉。</p><p>然后lyy去切了b题的fb，大体意思求1w个小于1w的数中，四四gcd为1的数量。lyy直接莫比乌斯反演。这题我以后可以补一下。（凉了）</p><p>e题就是求凸多边形的面积，虽然题意极其zz，但是毕竟是简单板子，lyy大佬10m敲好。</p><p>然后一开始以为f题是裸的并查集，结果发现有一个并查集的去除一个点的操作，结果被暴力o(n)给水过去了。。令人窒息。正解应该可以o(1)的，没卡。大体就是不动那个被去除的点，而是用离散化的那种方式把他指向新的点。</p><p>h题看都没看，就被琦神切了。</p><p>看了很久的c，总觉得别人都过了我们没过哪里不对。征得琦神的认可后照着二分图板子抄了一会，发现结束了=。=明明才做了三个半小时！</p><p>回去补c，b题可以回头看，h，d和g了解一下就行了。大佬带飞啊，没什么压力。</p><p>写完了发现不是二分图最大匹配啊。有问题。</p><p>然后搜了一下发现是模板题啊。</p><hr><h3 id="2-sat"><a href="#2-sat" class="headerlink" title="2 - sat"></a>2 - sat</h3><p>sat是逻辑学术测验！（口胡）<br>是Satisfiability问题，通俗地说就是是否可以有满足所有条件的方案？2-sat即为最多含有两个元素的集合。<br>可以用o(nm)的染色法，求出字典序最小的解。下面是o(m)求任意解的解法。<br>算法过程如下：<br>tarjan缩点，反向存边，拓扑排序，构造方案。<br>缩点很好理解：一个强连通分量里的点被选中一个就相当于全部被选中<br>反向存边，其实也算好理解，</p><blockquote><p>若图中存在边&lt; i, j &gt;，则表示若选了i必须选j。可以发现，上面的9种限制关系中，后7种二元限制关系都可以用连边实现，比如NOT(A[x] AND A[y])需要连两条边&lt; x, y’ &gt;和&lt; y, x’ &gt;，A[x] OR A[y]需要连两条边&lt; x’, y &gt;和&lt; y’, x&gt;。而前两种一元关系，对于A[x]（即x必选），可以通过连边&lt; x’, x &gt;来实现，而NOT A[x]（即x不能选），可以通过连边&lt; x, x’&gt;来实现。</p><blockquote><p>简单的说，有这么几种情况：ab不能同时取；不能同时不取；要么都取要么都不取；a和a’必取a。</p></blockquote></blockquote><p>下面几道例题。（其实只有一道，另外后面还有一道）</p><hr><h5 id="poj3905"><a href="#poj3905" class="headerlink" title="poj3905"></a>poj3905</h5><p>我们做的那道题。意思是有一些人在选举，这些选民在某些人选上或没选上的时候会高兴，给出每个人要求的二元组，问有没有满足所有这些人的情况？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> a[maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2500010</span>;</div><div class="line"><span class="keyword">struct</span> Edge &#123;</div><div class="line">    <span class="keyword">int</span> to,next;</div><div class="line">&#125;edge[MAXM];</div><div class="line"><span class="keyword">int</span> head[MAXN],tot;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">    edge[tot].to = v;</div><div class="line">    edge[tot].next = head[u];</div><div class="line">    head[u] = tot++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> Low[MAXN],DFN[MAXN],Stack[MAXN],Belong[MAXN];<span class="comment">//belong:1~scc</span></div><div class="line"><span class="keyword">int</span> Index,top;</div><div class="line"><span class="keyword">int</span> scc;</div><div class="line"><span class="keyword">bool</span> Instack[MAXN];</div><div class="line"><span class="keyword">int</span> num[MAXN];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    tot = <span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">    </div><div class="line">    <span class="built_in">memset</span>(DFN,<span class="number">0</span>,<span class="keyword">sizeof</span>(DFN));</div><div class="line">    <span class="built_in">memset</span>(Instack,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Instack));</div><div class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</div><div class="line">    <span class="built_in">memset</span>(Belong,<span class="number">0</span>,<span class="keyword">sizeof</span>(Belong));</div><div class="line">    Index = scc = top = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> v;</div><div class="line">    Low[u] = DFN[u] = ++Index;</div><div class="line">    Stack[top++] = u;</div><div class="line">    Instack[u] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</div><div class="line">    &#123;</div><div class="line">        v = edge[i].to;</div><div class="line">        <span class="keyword">if</span>(!DFN[v])&#123;</div><div class="line">            Tarjan(v);</div><div class="line">            <span class="keyword">if</span>(Low[u] &gt; Low[v]) Low[u] = Low[v];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Instack[v] &amp;&amp; Low[u] &gt; DFN[v])</div><div class="line">        Low[u] = DFN[v];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(Low[u] == DFN[u])</div><div class="line">    &#123;</div><div class="line">        scc++;</div><div class="line">        <span class="keyword">do</span>&#123;</div><div class="line">            v = Stack[--top];</div><div class="line">            Instack[v] =<span class="literal">false</span>;</div><div class="line">            Belong[v] = scc;</div><div class="line">            num[scc]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(v != u);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">solvable</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n*<span class="number">2</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!DFN[i]) Tarjan(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</div><div class="line">        <span class="keyword">if</span>(Belong[i] == Belong[i+n])</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1,q2;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/_集训2/sp_1/c.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    freopen(<span class="string">"c.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</div><div class="line">    &#123;</div><div class="line">        init();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> a,b;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</div><div class="line">            <span class="keyword">int</span> aa = <span class="built_in">abs</span>(a),bb = <span class="built_in">abs</span>(b);</div><div class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                addedge(aa+n,bb);</div><div class="line">                addedge(bb+n,aa);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>)&#123;</div><div class="line">                addedge(aa,bb+n);</div><div class="line">                addedge(bb,aa+n);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                addedge(bb,aa);</div><div class="line">                addedge(aa+n,bb+n);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                addedge(bb+n,aa+n);</div><div class="line">                addedge(aa,bb);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ans = solvable();</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="第二次训练。"><a href="#第二次训练。" class="headerlink" title="第二次训练。"></a>第二次训练。</h2><p>我tm，写了好久的丢了。</p><p>这次训练只有我和琦神。</p><p>琦神先切了G题，中间遇到了一点小问题，被顺利解决。<br>题意是给出一定数量的火柴棍，要求用尽所有火柴棍问能摆出的最大和最小数字分别是多少。主要是最小数字。起初我以为在后面必然是0或8，后来发现10的情况就是22，那么后面应该也会有这种情况。<br>琦神用第一位特判，后面的分情况直接暴力出来了。<br>挺考验代码和思维能力的，我后来写了下，基本上就是琦神那样的代码了。</p><p>然后我做了C题。C题意思是有一些猫狗爱好者，如果是猫爱好者必然会讨厌狗。猫爱好者会想留下一只猫并且想扔掉一只狗（给出对应序号），狗爱好者同理。起初我们当然会想到昨天做的2-sat问题，显然这里有一些关联但是并不大，因为不满足「有满足所有条件的解」以及「存在逻辑关系，如不选a就要选b」这样的，所以不是2-sat问题。<br>用猫狗建图会陷入误区之中，因为猫和狗是没有关系的，或者说有过于复杂的关系（对于每个爱好者来说都会向不同的猫狗间连线）<br>应该用爱好者建图。这时关系很显然，有冲突者连线，则猫爱好者和狗爱好者会在二分图两边，这时求最大独立集（任意两个顶点不相连的集合）即是答案。</p><p>B题意思是有一些证明，可以通过成环或者证明之间相互包含（相互证明）来验证其正确性，问给出一些证明关系，应该加入多少证明使得所有证明成立。<br>把证明视作点，证明关系视作边，则容易看出是问加入多少条边使得图强连通。<br>稍微讨论了一下，琦神就发现答案必然是缩点后出度为0的点，后来稍稍思考了一下，答案是出度和入度为0的点中数量最大的那一个。正确性显然，如果强连通则强连通内所有点入度出度均不为0。<br>但是还是wa了两发，发现存在一个点的情况自身就是强连通（自己为真），但是因为入度出度均0答案会出1，特判后还是wa，我去写D题，琦神很快找到问题所在：强连通缩成一个块后没有入度出度，相当于一个点的情况，特判后就过了。<br>tarjan我写的很少，这个题我还是要写一下的。</p><p>D题是扩展欧几里得问题。<br>有这样一个式子<br>$$<br>x<em>i = (a · x</em>{i−1} + b)\ mod\ 10001<br>$$<br>给出x1,x3,x5…x_2T-1，要求x2,x4….x_2T。<br>根据式子可以得出：<br>$ x_3 + 10001k= a^2 x_1 + (a+1)b $<br>$ x_3 - a^2 x_1 = -10001k + (a+1)b $<br>左右调换即是扩展欧几里得的形式。<br>写的时候没有注意ll，一直在爆。而且忘记了系数不能为负。<br>注意求的时候只需要求一个整数解而没有求其所有整数解。对于这个题来说，b = b0 + 10001k，而更新b的时候是b = b0 - 10001/d….又因为整数，所以其实求出来的b = b0 - 10001 * k 模一下就是b = b0。</p><p>I题计算几何模板题……？被琦神随便就过了。。<br>回头去看一下吧。</p><p>J题怼了好久，有点没把握好时间复杂度。<br>问题意思就是给你一串数，问有几种循环出现的情况，是否有冲突。<br>举例来说：3441321234，就只有一种循环方式，第一个44出现的时候就说明必然中间分开，1重复出现的时候必然就是这一段的循环。<br>起初没理解题意，在琦神的帮助下大概了解了。<br>通过每个重复出现点给出的信息（44就是说只有一种，如果434就有两种可能，可以排除另外的两个可能）——来依次缩小整个答案的范围。<br>代码很简单，就求每个数上一个出现位置(l)和这个出现位置(r)，然后可以直接映射（也可以不映射）% n到0～n-1区间中，把0-l,r-n或者r-l之间的元素更新为不可以的起始点。</p><blockquote><p>复杂度十分奇怪。可以发现在整个更新过程中似乎只访问了(n-区间长)的个数，算起来的话复杂度应该是区间个数 <em> (n-区间长) = n </em> 区间个数 - 区间个数 <em> 区间长，sum _ 区间个数 </em> 区间长度 = n，大概一看的话好像是n^2的复杂度啊，怎么都感觉很迷。</p></blockquote><p>假装o(n)好了。<br>这个题还有o(n)（确切）的解法，是滑动窗口（尺取法！）。可以放到对应的专题里做。<br>这里就不展开讲了。</p><p>A题二叉树 E题动归 F经典floodfill搜索 K不知道是啥。</p><hr><h2 id="第三次训练。"><a href="#第三次训练。" class="headerlink" title="第三次训练。"></a>第三次训练。</h2><p>可以说是lyy单打了。我毫无作为，甚至拖了后腿。</p><p>B题交互式问题，看了很久眼看着别人都过了自己不会，扔给lyy去写了。</p><p>G题阅读题，拼一些块，使得满足条件。只有横过来和竖着两种形态。我连wa2两发。</p><p>H题暴力贪心</p><p>I题模拟</p><p>J题暴力。。。问给出一些文字，能否通过一种一一映射，使得映射过的文字元音和辅音相隔？就枚举26^5*26^2然后优化。</p><p>回去补题，这次被老板叫去安排后续计划了，没什么时间补了，补个交互式问题好了。</p><h3 id="交互式问题："><a href="#交互式问题：" class="headerlink" title="交互式问题："></a>交互式问题：</h3><p>大概就是你先给出一个输出，系统会告诉你正确与否这样。也就是说，正确与否取决于你的输出，这时候你的输出变成了输入….</p><p>上题。</p><p>cf680c</p><p>你去猜[2,100]中的一个数是不是质数。每次你可以给出一个数，系统会给你这个数是不是现在正在猜的这个数的因子。</p><p>比如系统这个数是30，那么你猜2，5，15，都会回答yes，而17则会回答no。</p><p>要求在20条询问内得到结果。</p><p>因为要20条询问，那么可以先缩一次范围，用2、3、5、7试一下是否是因子，如果没有就是素数，如果有大于2个就不是，如果是1个接着枚举19次质数是否还是因子，最大能得到大于100的质因子只有两个的这种数。质因子大于两个的一定被两个的情况包含（都不是质数），如果这样的判断之后依旧全no，那么一定是质数。</p><p>注意尽量不要排除某种情况，比如试过2357之后依然还要试2357就只能用4、9、25、49这样代替，其余同理。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    /*</div><div class="line">      ID: oodt</div><div class="line">      PROG:</div><div class="line">      LANG:C++</div><div class="line">    */</div><div class="line">    #include&lt;iostream&gt;</div><div class="line">    #include&lt;algorithm&gt;</div><div class="line">    #include&lt;cstdio&gt;</div><div class="line">    #include&lt;cmath&gt;</div><div class="line">    #include&lt;string&gt;</div><div class="line">    #include&lt;cstring&gt;</div><div class="line">    #include&lt;map&gt;</div><div class="line">    #include&lt;vector&gt;</div><div class="line">    #include&lt;queue&gt;</div><div class="line">    #include&lt;stack&gt;</div><div class="line">    #include&lt;set&gt;</div><div class="line">    </div><div class="line">    using namespace std;</div><div class="line">    </div><div class="line">    const int maxx=10005;</div><div class="line">    int n,m,k;</div><div class="line">    int a[maxx];</div><div class="line">    int ans = 0,cnt = 0,pos = 0;</div><div class="line">    int l = 0,r = 0;</div><div class="line">    int vis[105];</div><div class="line">    string ss;</div><div class="line">    </div><div class="line">    const int MAXN=10000;</div><div class="line">    int prime[MAXN+1];</div><div class="line">    void getPrime()</div><div class="line">    &#123;</div><div class="line">        memset(prime,0,sizeof (prime));</div><div class="line">        for(int i=2;i&lt;=MAXN;i++)</div><div class="line">        &#123;</div><div class="line">            if(!prime[i] )prime[++prime[0]]= i;</div><div class="line">            for(int j=1;j&lt;=prime[0]&amp;&amp;prime[j]&lt;=MAXN/i;j++) &#123;</div><div class="line">                prime[prime[j]*i]=1;</div><div class="line">                if(i%prime[j]==0) break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int tryf(int d)</div><div class="line">    &#123;</div><div class="line">        cout&lt;&lt;d&lt;&lt;endl;</div><div class="line">        fflush(stdout);</div><div class="line">        cin&gt;&gt;ss;</div><div class="line">        return ss[0] == 'y';</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int main()</div><div class="line">    &#123;</div><div class="line">    #ifdef LOCAL</div><div class="line">    //    freopen("","r",stdin);</div><div class="line">    #endif</div><div class="line">        getPrime();</div><div class="line">        int t = 0;</div><div class="line">        int fk = 0;</div><div class="line">        for(int i = 1; i &lt;= 4; i++)</div><div class="line">        &#123;</div><div class="line">            if(tryf(prime[i])) &#123;</div><div class="line">                vis[i] = 1;</div><div class="line">                t++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(t &gt; 1)</div><div class="line">        &#123;</div><div class="line">            printf("composite\n");</div><div class="line">            fflush(stdout);</div><div class="line">        &#125;</div><div class="line">        else if(t == 0)&#123;</div><div class="line">            printf("prime\n");</div><div class="line">            fflush(stdout);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            for(int j = 1; j &lt;= 4; j++)</div><div class="line">            if(vis[j])</div><div class="line">            for(int i = 1; i &lt;= 19; i++)&#123;</div><div class="line">                if(prime[i]*prime[j] &gt;= 100) break;</div><div class="line">                if(tryf(prime[i]*prime[j]))&#123;</div><div class="line">                    printf("composite\n");</div><div class="line">                    fflush(stdout);</div><div class="line">                    fk = 1;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if(!fk)&#123;</div><div class="line">                printf("prime\n");</div><div class="line">                fflush(stdout);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### gym 100286B</div><div class="line"></div><div class="line">一个瞎子在迷宫里走，你给出走的方向，系统告诉你是墙还是空白。要求把迷宫的空白全部走一遍，并且迷宫大小n * m(0&lt;n,m&lt;31)这样。</div><div class="line"></div><div class="line">基本上就是dfs，然后每次注意继续走直到访问过所有空白块。注意每次dfs之后要返回原位置为了跑别的方向的dfs。</div><div class="line"></div><div class="line">只要数组稍微开的大一点就行。</div><div class="line"></div><div class="line">    /*</div><div class="line">      ID: oodt</div><div class="line">      PROG:</div><div class="line">      LANG:C++</div><div class="line">    */</div><div class="line">    #include&lt;iostream&gt;</div><div class="line">    #include&lt;algorithm&gt;</div><div class="line">    #include&lt;cstdio&gt;</div><div class="line">    #include&lt;cmath&gt;</div><div class="line">    #include&lt;string&gt;</div><div class="line">    #include&lt;cstring&gt;</div><div class="line">    #include&lt;map&gt;</div><div class="line">    #include&lt;vector&gt;</div><div class="line">    #include&lt;queue&gt;</div><div class="line">    #include&lt;stack&gt;</div><div class="line">    #include&lt;set&gt;</div><div class="line">    </div><div class="line">    using namespace std;</div><div class="line">    </div><div class="line">    const int maxx=100;</div><div class="line">    int n,m,k;</div><div class="line">    int a[maxx];</div><div class="line">    int ans = 0,cnt = 0,pos = 0;</div><div class="line">    int l = 0,r = 0;</div><div class="line">    </div><div class="line">    int dx[4] = &#123;0,-1,0,1&#125;;</div><div class="line">    int dy[4] = &#123;1,0,-1,0&#125;;</div><div class="line">    string s[4] = &#123;"NORTH","EAST","SOUTH","WEST"&#125;;</div><div class="line">    int vis[maxx][maxx];</div><div class="line">    string ss;</div><div class="line">    </div><div class="line">    int move(int d)</div><div class="line">    &#123;</div><div class="line">        cout&lt;&lt;s[d]&lt;&lt;endl;</div><div class="line">        fflush(stdout);</div><div class="line">        cin&gt;&gt;ss;</div><div class="line">        return ss[0] == 'E';</div><div class="line">    &#125;</div><div class="line">    void dfs(int x,int y)</div><div class="line">    &#123;</div><div class="line">        vis[x][y] = 1;</div><div class="line">        for(int i = 0 ; i &lt; 4; i++)</div><div class="line">        &#123;</div><div class="line">            int nx = x + dx[i];</div><div class="line">            int ny = y + dy[i];</div><div class="line">            if(!vis[nx][ny] &amp;&amp; move(i) )&#123;</div><div class="line">                dfs(nx,ny);</div><div class="line">                move((i+2)%4);</div><div class="line">            &#125;</div><div class="line">            else vis[nx][ny] = 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    int main()</div><div class="line">    &#123;</div><div class="line">    #ifdef LOCAL</div><div class="line">    //    freopen("","r",stdin);</div><div class="line">    #endif</div><div class="line">        int x = 50,y = 50;</div><div class="line">        dfs(x,y);</div><div class="line">        printf("DONE\n");</div><div class="line">        fflush(stdout);</div><div class="line">        return 0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h4 id="Gym-101021A"><a href="#Gym-101021A" class="headerlink" title="Gym 101021A"></a>Gym 101021A</h4><p>猜1-1000000内的数。其实这个应该做入门题。直接二分，判断就用交互就行了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> a[maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"><span class="keyword">char</span> s[maxx];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> mid)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mid);</div><div class="line">    fflush(<span class="built_in">stdout</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</div><div class="line">    <span class="keyword">return</span> s[<span class="number">0</span>] == <span class="string">'&gt;'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">erfen</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> mid;</div><div class="line">    <span class="keyword">while</span>(l&lt;=r)</div><div class="line">    &#123;</div><div class="line">        mid = (l + r) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(ok(mid))</div><div class="line">        &#123;</div><div class="line">            l = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            r = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    l--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line"><span class="comment">//    freopen("/Users/ecooodt/Desktop/c++ and acm/special--专题/9-strange/interactive/gym101021a.txt","r",stdin);</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    l = <span class="number">1</span>,r = <span class="number">1000000</span>;</div><div class="line">    erfen();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"! %d\n"</span>,l);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="cf680c"><a href="#cf680c" class="headerlink" title="cf680c"></a>cf680c</h4><p>给你一个2-100的数字,让你查询不超过20次判断是素数还是合数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> a[maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> vis[<span class="number">105</span>];</div><div class="line"><span class="built_in">string</span> ss;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10000</span>;</div><div class="line"><span class="keyword">int</span> prime[MAXN+<span class="number">1</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="keyword">sizeof</span> (prime));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!prime[i] )prime[++prime[<span class="number">0</span>]]= i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;prime[j]&lt;=MAXN/i;j++) &#123;</div><div class="line">            prime[prime[j]*i]=<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tryf</span><span class="params">(<span class="keyword">int</span> d)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    fflush(<span class="built_in">stdout</span>);</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;ss;</div><div class="line">    <span class="keyword">return</span> ss[<span class="number">0</span>] == <span class="string">'y'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line"><span class="comment">//    freopen("","r",stdin);</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    getPrime();</div><div class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> fk = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(tryf(prime[i])) &#123;</div><div class="line">            vis[i] = <span class="number">1</span>;</div><div class="line">            t++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(t &gt; <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"composite\n"</span>);</div><div class="line">        fflush(<span class="built_in">stdout</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"prime\n"</span>);</div><div class="line">        fflush(<span class="built_in">stdout</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++)</div><div class="line">        <span class="keyword">if</span>(vis[j])</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(prime[i]*prime[j] &gt;= <span class="number">100</span>) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">if</span>(tryf(prime[i]*prime[j]))&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"composite\n"</span>);</div><div class="line">                fflush(<span class="built_in">stdout</span>);</div><div class="line">                fk = <span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!fk)&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"prime\n"</span>);</div><div class="line">            fflush(<span class="built_in">stdout</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="第四次训练。"><a href="#第四次训练。" class="headerlink" title="第四次训练。"></a>第四次训练。</h2><p>琦神中途去宣讲（？还是啥，开组会）了，后面我们基本在摸。</p><p>这次。数学专场吧。</p><p>A题，计算$S<em>n = \sum^n</em>{k=1}[\frac{(3k+6)!+1}{3k+7}-[\frac{(3k+6)!}{3k+7}]]$</p><p>琦神：观察可得规律，当p为素数时才满足Sn+1。<br>我后来百度了一下，这叫威尔逊定理。即：当且仅当p为素数的时候，(p-1)! = -1 (mod p)，所以只有3k+7是素数的时候，才有1的结果。<br>那就直接筛1000000以下素数跑3k+7的sum就行了。</p><p>B题，给出一些城市的高度，给出每次海平面上升到的高度，问有多少个连通块还没有被淹没<br>我看了很久以为tm的有什么数据结构能跑logn的更新和查询。</p><p>C题扩欧，非常经典。</p><p>D题</p><p>E题</p><p>F题矩阵</p><p>G题水题。但是搞了个后缀非常诱人（通过后缀数组求原串hhh）实际上就是通过原串的顺序看每个位置和他后一个位置的每个后面那个原串中比较，随便乱搞就行。</p><p>H题</p><p>I题扩欧。</p><blockquote><p>给出一个树的形状，现在为这棵树标号，保证根节点的标号值比子节点的标号值大，问有多少种标号树。<br>解题思路：和排队的思路一致的是uva11174,最后问题只和树德结构有直接关系，f(root)=(s(root)−1)!/(s(1)∗s(2)∗⋯∗s(n))</p></blockquote><p>首先我们来看uva11174。<br>题意：村里有n个人，给出父亲与儿子的关系，问有多少种方式可以把他们拍成一列，使得没人会排在其父亲的前面。</p><blockquote><p>换个模型，先将森林变成一棵树，这样就直观多了，对于一个节点，他的子节点排列时没有任何要求，而子排列中会有限制，将这些限制先提取出来，就可以将所有的视为相同的。然后就是有重复元素的全排列问题。</p><p>设f(i)是以节点i为根的子树的排法，即节点i有儿子c1,c2,c3…cj共j棵子树。如果分别先给各个子树内部排序，那么毫无疑问共有f(c1) <em> f(c2) </em> f(c3) … * f(cj)种情况。</p><p>设s[i]为树根为i的子树包含的节点数。然后把每棵子树的所有节点看成同一元素，根据有重复元素的全排列方式共有s(i-1)!／(s(c1)! <em> s(c2)! </em> … * s(ck)!)</p></blockquote><p>J题kd-tree裸题</p><hr><h2 id="第五次训练。"><a href="#第五次训练。" class="headerlink" title="第五次训练。"></a>第五次训练。</h2><p>有点惨，只出了4题。</p><p>A题题意很简单，对任意一对查询，在一个图里找到一条最大边最小的路。</p><p>琦神开的。首先为了保证取的最大边最小，跑一遍最小生成树。</p><p>琦神：「跑出树形之后就很简单了，树一定有根，那么就把两个点都向根部跑，如果相遇了就直接取最大值」大体就是这样了。往最小生成树里加根的代码我还真不怎么会。。学习一波。不过要用prim，用kruskal的话跑出来的pre数组不一定是树上的。</p><p>贴下琦神代码吧，这题虽然放在区域赛是水题但我自己的话真不一定能写出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">int</span> mini[MAXN],ret=<span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> v[MAXN],i,j,k;</div><div class="line">       <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">              mini[i]=inf,v[i]=<span class="number">0</span>,pre[i]=<span class="number">-1</span>;</div><div class="line">       <span class="keyword">for</span> (mini[j=<span class="number">0</span>]=<span class="number">0</span>;j&lt;n;j++)&#123;</div><div class="line">              <span class="keyword">for</span> (k=<span class="number">-1</span>,i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">                    <span class="keyword">if</span> (!v[i]&amp;&amp;(k==<span class="number">-1</span>||mini[i]&lt;mini[k]))</div><div class="line">                            k=i;</div><div class="line">              <span class="keyword">for</span> (v[k]=<span class="number">1</span>,ret+=mini[k],i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">                     <span class="keyword">if</span> (!v[i]&amp;&amp;mat[k][i]&lt;mini[i])</div><div class="line">                            mini[i]=mat[pre[i]=k][i];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">query[x]=max(<span class="number">1</span>,query[x]);</div><div class="line">            <span class="keyword">while</span>(pre[x]!=<span class="number">-1</span>)</div><div class="line">            &#123;</div><div class="line">                query[pre[x]]=max(query[x],mat[x][pre[x]]);</div><div class="line">                x=pre[x];</div><div class="line">                <span class="comment">//printf("%d %d %d\n",x,pre[x],mat[x][pre[x]]);</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(query[y]!=<span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query[y]);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(pre[y]!=<span class="number">-1</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(query[pre[y]]!=<span class="number">0</span>)</div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(query[pre[y]],max(query[y],mat[y][pre[y]])));</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                query[pre[y]]=max(query[y],mat[y][pre[y]]);</div><div class="line">                y=pre[y];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(pre[y]==<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query[y]);</div></pre></td></tr></table></figure><p>B题</p><p>C题披着计算几何外衣（给出坐标系）的水题。就给出一些点的坐标(double)，每个点只会向斜上方的方块（0,0就1,1以上这样）连线，问连线的<strong>曼哈顿</strong>长度的平均值。</p><p>思路就是出自曼哈顿距离，所以可以把每个方块中的点简缩成一个点，然后直接求x <em> ty-y </em> tx，t就是数量因为斜上方所以保证了一定大于，就酱。</p><p>因为会爆int，所以wa了一发而不知所措=。=</p><p>D题</p><p>E题</p><p>F题</p><p>G题</p><p>H题</p><p>I题题意是给出多组a0-a9和a10，问是否存在N!=1，使得$（\sum_{i = 0}^{9}a<em>i） \% N = a</em>{10}$</p><p>扔给lyy大佬做了。具体的话，首先如果s &lt; a10，那么肯定不行。其次如果s == a10那么答案必定大于s。最后s &gt; a10，ans = 所有s - a[i]的gcd（且答案大于a10）。</p><p>判断一下情况，有没有前面答案小于或者上面第一种情况。</p><p>J题</p><hr><h2 id="第六次训练"><a href="#第六次训练" class="headerlink" title="第六次训练"></a>第六次训练</h2><p>么得题解（鸽了）</p><hr><p>##第七次训练。</p><p>琦神又去开组会了，然后我们心不在焉的做了有史以来最惨的两题。当时我们基本上放弃了，lyy拿着电脑去打印模板啥的。。</p><p>A题就是水题，给出一堆排序的要求，排个序，加个贡献什么的…</p><p>B</p><p>C题题意就是要求将游戏机上一串A改变成想要的字母需要操作多少次左右箭头。字母连通，首尾连通。</p><p>其实很简单，我一开始没有意识到走法。就是先左后右或者先右后左，正着跑一遍的情况其实已经包含在里面了。</p><p>所以其实就几行的代码，我写了很久，改了很久，这次题少很大程度怪我。没有理好公式和方法。</p><p>D</p><p>E题意思是给出一个之前的排名和所有改变排名的数对，每一个数对(a,b)表示原先b在a前面而现在a在b前面。问最后确定下来的排名。观察可以发现，对于给出的数对，改变的一定只有1的权值。那么就好做很多了，直接按照每个查询+-1就行了。</p><p>lyy疯狂wa，应该是存在a &gt; b的情况，并不是impossible。</p><p>F</p><p>G</p><p>H也是水题，就模拟交易，sell按低出，buy按高出，优先队列不断弹就行了。自己写的没什么问题，但是题读的有问题，初始化交易记录的地方写错了。卡了两个小时（后来自己在宿舍写的）</p><p>I</p><p>J</p><hr><h2 id="第八次训练。"><a href="#第八次训练。" class="headerlink" title="第八次训练。"></a>第八次训练。</h2><p>这次的题，意外的非常棘手（扎实）</p><p>BH水题不表。才不是我去晚了这两个题听都没听呢。</p><p>D题题意：给出一些串，所有串可以当成n <em> m的表格（由逗号分开），问是否有两行中存在两列相同的。n&lt;10000, m &lt; 10。我当时感觉无论如何都要防止n^2，然后就在想想想=。=然而没想到的是，lyy写完hash(极不信任map)想了想居然跑了个O(n^2 </em> m)然后过了。</p><p>1e9在600ms里过了。无法信任了！</p><p>I题题意：给出一张dag图，要求跑完所有边。每次跑不下去的时候可以重新选择起点，问最少选择的次数以及跑的路线。</p><p>首先琦神nb！</p><p>首先设超级起点和超级汇点，跑一遍上下界最小流。不过好像没有最小流的板子，有个上界下界的板子。我和琦神在lyy不能光看板子啊不能依赖板子啊要自己写啊的疯狂抱怨中研究出了最小流的写法，然后暴力跑一个dfs（这次是n^4！100^4！琦神嫌再写一个邻接表的dfs繁就跑的矩阵的。。）搜出所有路每次在流量上-1就行。</p><h4 id="C题交互题"><a href="#C题交互题" class="headerlink" title="C题交互题"></a>C题交互题</h4><p>直接贴lyy的题解</p><p><a href="https://vjudge.net/problem/Gym-101308C" target="_blank" rel="external">https://vjudge.net/problem/Gym-101308C</a></p><p>一道很有意思的交互题</p><p>题意：</p><p>是给你一个1-n的排列，告诉你n(3&lt;=n&lt;=200)，然后你可以进行若干次（不超过2000次）询问，询问的格式是{P1,P2,P3}(三个数两两不相等),  意思是问排列中位置为P1,P2,P3的三个数大小在中间的那个数是多少，系统返回给你中间的那个数的值，最后你要确定最后的答案（答案可能不止一个，你只需找到解系中的任意一个解即可</p><p>样例和分析：</p><p>4 ： 1 2 3</p><p>2 ： 2 3 4</p><p>3 ： 1 2 4 </p><p>2 ： 1 3 4</p><p>3 ： ok 2 1 4 3 </p><p>先告诉你排列的长度为4，</p><p>你询问a1a2a3 中大小在中间的数是多少，返回结果为2</p><p>你询问a2a3a4 中大小在中间的数是多少，返回结果为3</p><p>你询问a1a2a4 中大小在中间的数是多少，返回结果为2</p><p>你询问中大小在中间的数是多少，返回结果为3</p><p>可以确定最终的结果2 1 4 3</p><p>分析：</p><p>对于n=3这种情况，我们知道不管怎么去询问，都会回答2，所以无法判断，解系是3个数的任意一组排列*</p><p>n&gt;=4时，你是无法区分1和2，n和n-1，因为如果你的询问的位置上的数包含1和2，一定会返回2，如果询问位置上的数不包含1或者不包含2，那返回结果一定不是1和2。(n和n-1同理。)对于其它的数一定能判断，所以解系是一组特解然后可以将1和2，n和n-1互换位置。</p><p>那么如何确定每个数的位置呢?</p><p>我们可以采用生成随机询问的方法，如果询问是{P1,P2,P3}，返回结果是x，那么我们就可以判断x在P1,P2,P3位置中的一个，我们只记录x这个数可能的位置，如果多次返回了x我们就可以通过集合的并集确定x的位置。</p><p><strong>我们生成随机询问，保证P1,P2,P3这三个位置上的数之前都没有确定，我们先进行若干次询问，直到没有被确定的位置小于等于10（在n=200的情况下只需要400-450次询问即可）；然后我们对于剩下10个位置每三个数询问一次，共C_{10}^3= 120 次，这样除了1,2,n-1,n都可以确定了，然后再进行4次询问，确定1,2和n-1,n。</strong></p><hr><h2 id="第九次训练"><a href="#第九次训练" class="headerlink" title="第九次训练"></a>第九次训练</h2><p>大概也鸽了</p><p>两道水题。</p><p>C - 给出一个洞的上下界，问最多能储多少水（不能碰到上界）</p><p>从右到左扫一遍就能得到每一列的最高的水位，再从左到右扫一遍就行了</p><p>琦神nb</p><p>E - 两两匹配问题，即，</p><hr><h2 id="第十次训练。"><a href="#第十次训练。" class="headerlink" title="第十次训练。"></a>第十次训练。</h2><p>4题可怜。</p><p>A题三分。三分一般用在有单一极值的地方。<br>补一下代码（lyy）学习一波。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">struct</span> point</div><div class="line">&#123;</div><div class="line"><span class="keyword">double</span> x,y;</div><div class="line">&#125;p[<span class="number">50005</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line">ans=max(ans,<span class="built_in">sqrt</span>((p[i].x-x)*(p[i].x-x)+p[i].y*p[i].y));</div><div class="line">&#125;</div><div class="line"><span class="comment">//printf("%.1f %.1f\n",x,ans);</span></div><div class="line"><span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">find</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">double</span> l=<span class="number">-1e9</span>,r=<span class="number">1e9</span>;</div><div class="line"><span class="keyword">double</span> m1,m2;</div><div class="line"><span class="keyword">while</span> (r-l&gt;<span class="number">1e-9</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">//cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;endl;</span></div><div class="line">m1=(l*<span class="number">2</span>+r)/<span class="number">3</span>;</div><div class="line">m2=(l+r*<span class="number">2</span>)/<span class="number">3</span>;</div><div class="line"><span class="keyword">if</span> (f(m1)&gt;f(m2)) l=m1;</div><div class="line"><span class="keyword">else</span> r=m2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> (l+r)/<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n!=<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;p[i].x,&amp;p[i].y);</div><div class="line">&#125;</div><div class="line"><span class="keyword">double</span> k=find();</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%.8f %.8f\n"</span>,k,f(k));</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>I题水题</p><p>B题阅读题，今天代码有点问题，怎么都在错。</p><p>J题就是对后缀数组的应用。琦神和lyy扔了大把时间在里面。</p><p>D题dp。<br>题意：AB玩飞镖。A随意扔，B瞄准扔到相邻3个区域中的一个。现在有n &lt; 501分，问分别先手的获胜概率</p><blockquote><p>用$dp[0][n][m]$表示当A剩余n分，B剩余m分时，A先手获胜的概率<br>用$dp[1][n][m]$表示当A剩余n分，A剩余m分时，B先手获胜的概率</p><p>那么当n和m都不小于20时有递推式</p><p>$dp[0][n][m] =\sum<em>{i = 1}^{20}  \frac{1}{20}(1-dp[1][n-d[i]][m])$<br>$dp[1][n][m] =max</em>{1&lt;=i&lt;=20} \frac{1}{20}\sum_{j = -1}^{1} \frac{1}{3}(1-dp[0][n][m-d[i+j]])$</p><p>从下向上递推，在n&lt;d[i]和m&lt;d[i+j]的时候跳过（其实就是空了一个回合）即可。</p></blockquote><p>其实有了递推式就很简单了，问题是递推式是怎么来的。<br>$dp[0][n][m]$：当A剩余n分，B剩余m分时，A先手获胜的概率为扔到所有点的（1-B获胜概率）之和<br>$dp[1][n][m]$：当A剩余n分，B剩余m分时，B先手获胜的概率为B锁定所有点里面，对其胜率最大的，这个胜率是三个点的（1-A的胜率）之和。<br>我觉得这道题非常好，模型很优秀。</p><p>补一下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> a[maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> dart[] = &#123;<span class="number">20</span>,<span class="number">1</span>,<span class="number">18</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">17</span>,<span class="number">3</span>,<span class="number">19</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">1</span>,<span class="number">18</span>&#125;;</div><div class="line"><span class="keyword">double</span> dp[<span class="number">502</span>][<span class="number">502</span>][<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line"><span class="comment">//freopen("","r",stdin);</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">int</span> n = <span class="number">501</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">double</span> x = dp[i][j][<span class="number">0</span>];</div><div class="line">            <span class="keyword">double</span> y = dp[i][j][<span class="number">1</span>];</div><div class="line">            <span class="comment">//x = p0*y+q0;</span></div><div class="line">            <span class="keyword">double</span> q0 = <span class="number">0</span>,p0 = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(dart[k] &gt; i) p0 += <span class="number">1.0</span>/<span class="number">20</span>;</div><div class="line">                <span class="keyword">else</span> q0 += <span class="number">1.0</span>/<span class="number">20</span> * dp[i - dart[k]][j][<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">            y = <span class="number">1</span>;</div><div class="line">            dp[i][j][<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k  = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">double</span> p1 = <span class="number">0</span>,q1 = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">3</span>; r++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">int</span> d = dart[r+k];</div><div class="line">                    <span class="keyword">if</span>(d &gt; j)</div><div class="line">                    &#123;</div><div class="line">                        p1 += <span class="number">1.0</span>/<span class="number">3</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> q1 += <span class="number">1.0</span>/<span class="number">3</span> * dp[i][j-d][<span class="number">0</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">double</span> tmp = (p1*q0+q1)/(<span class="number">1</span>-p1*p0);</div><div class="line">                <span class="keyword">if</span>(tmp &lt; y) &#123;</div><div class="line">                    y = tmp;</div><div class="line">                    dp[i][j][<span class="number">1</span>] = tmp;</div><div class="line">                    dp[i][j][<span class="number">0</span>] = p0*y + q0;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//x = p0 * y + q0;</span></div><div class="line">            <span class="comment">// y = p1*x + q1 = p1*(p0*y+q0) + q1;</span></div><div class="line">            <span class="comment">// (1-p1*p0) y = p1*q0 + q1;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%.9f %.9f"</span>,dp[n][n][<span class="number">0</span>],<span class="number">1</span>-dp[n][n][<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>G题dp+计算几何</p><p>C题dp</p><p>F题bellmanford最短路<br>神tm当时没过。后来仔仔细细做了一遍，发现没过是应该的。<br>题意：给出一个图，图里有一些虫洞和墙，问起点（左下角）到终点（右上角）的最大值。<br>可以知道就是带负环回路求最短路，其中有这么几种情况要考虑：<br>1.要跑虫洞就会经过终点。这时候我们不以终点向外连线即可。<br>2.虫洞无法抵达。这样的话需要在bellmanford里面加入已经跑过的判断，以及离散化…(?)反正我没写离散化就没过，跑的spfa。<br>3.跑的时候注意虫洞就只往传送方向连边<br>别的大概没啥了。点挺多的，框架很快写好，细节检查许久。</p><hr><h2 id="第十一次训练"><a href="#第十一次训练" class="headerlink" title="第十一次训练"></a>第十一次训练</h2><p>J 阅读题，and chelf，看到的话秒过。</p><p>A 给出一个20 * 1000的矩阵，问哪一列乘积最大。</p><p>扔给lyy写大数了。其实可以不用大数，每个数相乘那么每个数取log也是可以的，就是要注意负数的情况。</p><p>写的wa炸了。其实就是考虑负数而已。。。心态炸了，直接用别人的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bigger</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(a[u]&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(a[v] &lt;=<span class="number">0</span> )<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> num[u] &gt; num[v]+eps;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(a[u] == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(a[v] &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(a[v] &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> num[u]+eps &lt; num[v];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>H 当一行或列和为偶时可以删掉这一行。那么从第一个位置向右下角递推就行了。一定是可以按次序确定的。写的时候有点僵硬，没有推清奇偶状态和变换关系啊，没有考虑边界啊。</p><p>E 水题 琦神切的。</p><p>D 给出一些比赛和题目数，给出你会做的题目出现在哪些比赛中，问能填满的最多比赛数。已知比赛数&lt;15而你会做的题目&lt;50</p><p>枚举所有比赛的状态，那么剩下的问题就是怎样安排比赛使得比赛既没有冲突且最大。一种显然的思路是二分图，但是发现其实求的好像是多重匹配。</p><p>于是跑最大流。但是如果每次都跑会炸。我们就在这里T掉了，然后从sap改成isap，然后改成dinic，都不行。</p><p>最后发现只需要更新当前这种比赛安排比ans大的情况，其他情况不用跑网络流，就不会T了。</p><p>琦神：这题傻逼。</p><p>dinic的板子是网上来的。到最后都不知道这个有没有弧优化，到时候再找一个看起来就比较靠谱的吧，在那之前先用着isap。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;cassert&gt;</div><div class="line">#include&lt;map&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#include&lt;queue&gt;</div><div class="line">#include&lt;sstream&gt;</div><div class="line">#include&lt;stack&gt;</div><div class="line">#include&lt;set&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define rep(i,a,n) for (int i=a;i&lt;n;i++)</div><div class="line">#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)</div><div class="line">#define pb push_back</div><div class="line">//#define mp make_pair</div><div class="line">#define all(x) (x).begin(),(x).end()</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define SZ(x) ((int)(x).size())</div><div class="line">typedef vector&lt;int&gt; VI;</div><div class="line">typedef long long ll;</div><div class="line">typedef pair&lt;int,int&gt; PII;</div><div class="line">const ll mod=1000000007;</div><div class="line">ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;</div><div class="line">ll gcd(ll a,ll b) &#123; return b?gcd(b,a%b):a;&#125;</div><div class="line"></div><div class="line">const int maxx=10005;</div><div class="line">const int INF = 0x3f3f3f3f;</div><div class="line">int n,m,k;</div><div class="line">int a[maxx],f[20];</div><div class="line">int vis[maxx];</div><div class="line">char aa[10005];</div><div class="line">vector&lt;int&gt; v[55];</div><div class="line">int ans = 0,cnt = 0,pos = 0;</div><div class="line">int l = 0,r = 0;</div><div class="line">char s[maxx];</div><div class="line">map&lt;string,int&gt; pp;</div><div class="line">string str;</div><div class="line">const int Ni = 80;</div><div class="line">const int MAX = 1&lt;&lt;26;</div><div class="line"> struct Edge&#123;</div><div class="line">     int u,v,c;</div><div class="line">     int next;</div><div class="line"> &#125;edge[80*Ni];</div><div class="line"> int edn;//边数</div><div class="line"> int p[Ni];//父亲</div><div class="line"> int d[Ni];</div><div class="line"> int sp,tp;//原点，汇点</div><div class="line"></div><div class="line"> void addedge(int u,int v,int c)</div><div class="line"> &#123;</div><div class="line">     edge[edn].u=u; edge[edn].v=v; edge[edn].c=c;</div><div class="line">     edge[edn].next=p[u]; p[u]=edn++;</div><div class="line"></div><div class="line">     edge[edn].u=v; edge[edn].v=u; edge[edn].c=0;</div><div class="line">     edge[edn].next=p[v]; p[v]=edn++;</div><div class="line"> &#125;</div><div class="line"> int bfs()</div><div class="line"> &#123;</div><div class="line">     queue &lt;int&gt; q;</div><div class="line">     memset(d,-1,sizeof(d));</div><div class="line">     d[sp]=0;</div><div class="line">     q.push(sp);</div><div class="line">     while(!q.empty())</div><div class="line">     &#123;</div><div class="line">         int cur=q.front();</div><div class="line">         q.pop();</div><div class="line">         for(int i=p[cur];i!=-1;i=edge[i].next)</div><div class="line">         &#123;</div><div class="line">             int u=edge[i].v;</div><div class="line">             if(d[u]==-1 &amp;&amp; edge[i].c&gt;0)</div><div class="line">             &#123;</div><div class="line">                 d[u]=d[cur]+1;</div><div class="line">                 if(u == tp) return 1;</div><div class="line">                 q.push(u);</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     return d[tp] != -1;</div><div class="line"> &#125;</div><div class="line"> int dfs(int a,int b)</div><div class="line"> &#123;</div><div class="line">     int r=0;</div><div class="line">     if(a==tp)return b;</div><div class="line">     for(int i=p[a];i!=-1 &amp;&amp; r&lt;b;i=edge[i].next)</div><div class="line">     &#123;</div><div class="line">         int u=edge[i].v;</div><div class="line">         if(edge[i].c&gt;0 &amp;&amp; d[u]==d[a]+1)</div><div class="line">         &#123;</div><div class="line">             int x=min(edge[i].c,b-r);</div><div class="line">             x=dfs(u,x);</div><div class="line">             r+=x;</div><div class="line">             edge[i].c-=x;</div><div class="line">             edge[i^1].c+=x;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     if(!r)d[a]=-2;</div><div class="line">     return r;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> int dinic(int sp,int tp)</div><div class="line"> &#123;</div><div class="line">     int total=0,t;</div><div class="line">     while(bfs())</div><div class="line">     &#123;</div><div class="line">         while(t=dfs(sp,MAX))</div><div class="line">         total+=t;</div><div class="line">     &#125;</div><div class="line">     return total;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">#ifdef LOCAL</div><div class="line">//    freopen("","r",stdin);</div><div class="line">#endif</div><div class="line">    freopen("d.in","r",stdin);</div><div class="line">    while(scanf("%d%d",&amp;n,&amp;m) &amp;&amp; (n + m))</div><div class="line">    &#123;</div><div class="line">        pp.clear();</div><div class="line">        rep(i,0,m) v[i].clear();</div><div class="line">        int d;</div><div class="line">        cnt = 0;</div><div class="line">        rep(i,0,n)&#123;</div><div class="line">            scanf("%s%d",s,&amp;d);</div><div class="line">            str = string(s);</div><div class="line">            pp[str] = cnt;</div><div class="line">            f[cnt++] = d;</div><div class="line">        &#125;</div><div class="line">        getchar();</div><div class="line">        for(int i=0; i&lt;m; i++)</div><div class="line">        &#123;</div><div class="line">            gets(aa);</div><div class="line">            int l=strlen(aa);</div><div class="line">            str="";</div><div class="line">            for(int j=0;j&lt;l;j++)</div><div class="line">            &#123;</div><div class="line">                if(aa[j]==' ')</div><div class="line">                &#123;</div><div class="line">                    if(str != "")</div><div class="line">                    &#123;</div><div class="line">                        v[i].push_back(pp[str]);</div><div class="line">                        str="";</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                else str+=aa[j];</div><div class="line">            &#125;</div><div class="line">            if(str!="")v[i].push_back(pp[str]);</div><div class="line">        &#125;</div><div class="line">        sp = m,tp = n+m+1;</div><div class="line">        int i,j;</div><div class="line">        ans=0;</div><div class="line">        for(int i = 0; i &lt; (1&lt;&lt;n); i++)</div><div class="line">        &#123;</div><div class="line">            edn = 0;</div><div class="line">            memset(p,-1,sizeof(p));</div><div class="line">//            init();</div><div class="line">            for(int j=0;j&lt;m;j++)</div><div class="line">            &#123;</div><div class="line">                addedge(m,j,1);</div><div class="line">            &#125;</div><div class="line">            for(int j =0;j&lt;m;j++)</div><div class="line">            for(int k=0;k&lt;v[j].size();k++)</div><div class="line">            &#123;</div><div class="line">                addedge(j,v[j][k]+m+1,1);</div><div class="line">            &#125;</div><div class="line">            j=0;</div><div class="line">            int now=i;</div><div class="line">            int num=0;</div><div class="line">            int t = 0;</div><div class="line">            while(now)</div><div class="line">            &#123;</div><div class="line">                if((now&amp;1)==1)</div><div class="line">                &#123;</div><div class="line">                    t += f[j];</div><div class="line">                    addedge(j+m+1,m+n+1,f[j]);</div><div class="line">                    num++;</div><div class="line">                &#125;</div><div class="line">                now=now&gt;&gt;1;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            if(num &lt;= ans) continue;</div><div class="line">            int nowflow=dinic(m,n+m+1);</div><div class="line">            if(nowflow==t &amp;&amp; num&gt;ans)ans=num;</div><div class="line">        &#125;</div><div class="line">        printf("Case #%d: %d\n",++pos,ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="第十二次训练-第七次训练"><a href="#第十二次训练-第七次训练" class="headerlink" title="第十二次训练 (=第七次训练)"></a>第十二次训练 (=第七次训练)</h2><p>B dp</p><p>就是从第一个的排序之后在第二个里找一个值最大的。已知第一个只会一个一个往下取，所以就在第二个里面按偶数个能取的个数+1</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;cassert&gt;</div><div class="line">#include&lt;map&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#include&lt;queue&gt;</div><div class="line">#include&lt;stack&gt;</div><div class="line">#include&lt;set&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define rep(i,a,n) for (int i=a;i&lt;n;i++)</div><div class="line">#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)</div><div class="line">#define pb push_back</div><div class="line">#define mp make_pair</div><div class="line">#define all(x) (x).begin(),(x).end()</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define SZ(x) ((int)(x).size())</div><div class="line">typedef vector&lt;int&gt; VI;</div><div class="line">typedef long long ll;</div><div class="line">typedef pair&lt;int,int&gt; PII;</div><div class="line">const ll mod=1000000007;</div><div class="line">ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;</div><div class="line">ll gcd(ll a,ll b) &#123; return b?gcd(b,a%b):a;&#125;</div><div class="line"></div><div class="line">const int maxx=2005;</div><div class="line">const int INF = 0x3f3f3f3f;</div><div class="line">int n,m,k;</div><div class="line">struct pp&#123;</div><div class="line">    int x,y;</div><div class="line">&#125;a[maxx];</div><div class="line">char s[maxx];</div><div class="line">int vis[maxx];</div><div class="line">int ans = 0,cnt = 0,pos = 0;</div><div class="line">int l = 0,r = 0;</div><div class="line">struct p&#123;</div><div class="line">    int m,tiexin;</div><div class="line">&#125;dp[maxx][maxx];</div><div class="line">int cmp(pp a,pp b)&#123;</div><div class="line">    if(a.x != b.x)</div><div class="line">    return a.x &gt; b.x;</div><div class="line">    else return a.y &lt; b.y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">#ifdef LOCAL</div><div class="line">    freopen("/Users/ecooodt/Desktop/c++ and acm/_集训2/sp_12/b.txt","r",stdin);</div><div class="line">#endif</div><div class="line">    int T;</div><div class="line">    scanf("%d",&amp;T);</div><div class="line">    while(T--)</div><div class="line">    &#123;</div><div class="line">        scanf("%d",&amp;n);</div><div class="line">        scanf("%s",s);</div><div class="line">        ans = 0;</div><div class="line">        rep(i,1,n+1)&#123;</div><div class="line">            int x,y;</div><div class="line">            scanf("%d%d",&amp;x,&amp;y);</div><div class="line">            a[i].x = x,a[i].y = y;</div><div class="line">            ans += a[i].x;</div><div class="line">        &#125;</div><div class="line">        sort(a+1,a+n+1,cmp);</div><div class="line">        //memset()</div><div class="line">        int t = 1;</div><div class="line">        if(s[0] =='P')&#123;</div><div class="line">//            ans1 += a[0].x;</div><div class="line">            t = 2;</div><div class="line">        &#125;</div><div class="line">        memset(dp,0,sizeof(dp));</div><div class="line">        rep(i,1,n-t+2)&#123;</div><div class="line">            rep(j,1,(i+1)/2+1)&#123;</div><div class="line">                if(dp[i-1][j-1].m + a[i+t-1].y &gt; dp[i-1][j].m)</div><div class="line">                &#123;</div><div class="line">                    dp[i][j].m = dp[i-1][j-1].m + a[i+t-1].y;</div><div class="line">                    dp[i][j].tiexin = dp[i-1][j-1].tiexin + a[i+t-1].x;</div><div class="line">                &#125;</div><div class="line">                else if(dp[i-1][j-1].m + a[i+t-1].y == dp[i-1][j].m)&#123;</div><div class="line">                    dp[i][j] = dp[i-1][j];</div><div class="line">                    if(dp[i-1][j-1].tiexin+a[i+t-1].x &lt; dp[i-1][j].tiexin)&#123;</div><div class="line">                        dp[i][j].tiexin = dp[i-1][j-1].tiexin + a[i+t-1].x;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    dp[i][j] = dp[i-1][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        printf("%d %d\n",ans-dp[n-t+1][(n-t+2)/2].tiexin,dp[n-t+1][(n-t+2)/2].m);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">3</div><div class="line">4</div><div class="line">Petra</div><div class="line">100 80</div><div class="line">70 80</div><div class="line">50 80</div><div class="line">30 50</div><div class="line">4</div><div class="line">Petra</div><div class="line">10 1</div><div class="line">1 10</div><div class="line">6 6</div><div class="line">4 4</div><div class="line">7</div><div class="line">Jan</div><div class="line">4 1</div><div class="line">3 1</div><div class="line">2 1</div><div class="line">1 1</div><div class="line">1 2</div><div class="line">1 3</div><div class="line">1 4</div><div class="line"> */</div></pre></td></tr></table></figure><p>F 最大流</p><p>网上题解写的不错（摸</p><p>给n个点的无权无向图（n&lt;=100），每个点有一个非负数ai。若ai==0则此点归敌方所有，若ai&gt;0则此点归你且上面有ai个属于你的士兵。保证至少有一个属于你的点与敌方的点相邻。你可以让你的每个士兵最多移动一次，每次可以待在原地或者去到相邻的属于你的领地，但每个点至少要留1各士兵，使得最薄弱的关口尽量坚固。关口是指与敌方点相邻的点，薄弱与坚固分别指兵少与兵多。</p><p>把每个点拆成两个点，一个入度，一个出度，入度向自己的和每个相邻的点的出度连一条边，容量是ai，每个点出度连一条边到汇点，容量为1，那些与敌人相邻的点再多连一条边到汇点，容量是二分的值，我们只需要二分这个值，跑一下网络流，如果满流，表示可以，否则不行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;cassert&gt;</div><div class="line">#include&lt;map&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#include&lt;queue&gt;</div><div class="line">#include&lt;stack&gt;</div><div class="line">#include&lt;set&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define rep(i,a,n) for (int i=a;i&lt;n;i++)</div><div class="line">#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)</div><div class="line">#define pb push_back</div><div class="line">#define mp make_pair</div><div class="line">#define all(x) (x).begin(),(x).end()</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define SZ(x) ((int)(x).size())</div><div class="line">typedef vector&lt;int&gt; VI;</div><div class="line">typedef long long ll;</div><div class="line">typedef pair&lt;int,int&gt; PII;</div><div class="line">const ll mod=1000000007;</div><div class="line">ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;</div><div class="line">ll gcd(ll a,ll b) &#123; return b?gcd(b,a%b):a;&#125;</div><div class="line"></div><div class="line">const int maxx=105;</div><div class="line">const int INF = 0x3f3f3f3f;</div><div class="line">int n,m,k;</div><div class="line">int a[maxx];</div><div class="line">int vis[maxx];</div><div class="line">int ans = 0,cnt = 0,pos = 0;</div><div class="line">int l = 0,r = 0;</div><div class="line">char s[maxx][maxx];</div><div class="line"></div><div class="line"></div><div class="line">const int maxn = 305;</div><div class="line">int flow[maxn][maxn];</div><div class="line">int maz[maxn][maxn];</div><div class="line">int gap[maxn],dis[maxn],pre[maxn],cur[maxn];</div><div class="line">int sap(int start,int end,int nodenum)</div><div class="line">&#123;</div><div class="line">    memset(cur,0,sizeof(cur));</div><div class="line">    memset(dis,0,sizeof(dis));</div><div class="line">    memset(gap,0,sizeof(gap));</div><div class="line">    memset(flow,0,sizeof(flow));</div><div class="line">    int u = pre[start] = start,maxflow = 0,aug = -1;</div><div class="line">    gap[0] = nodenum;</div><div class="line">    while(dis[start] &lt; nodenum)</div><div class="line">    &#123;</div><div class="line">    loop:</div><div class="line">        for(int v = cur[u]; v &lt; nodenum; v++)</div><div class="line">        &#123;</div><div class="line">            if(maz[u][v]-flow[u][v] &amp;&amp; dis[u] == dis[v] + 1)</div><div class="line">            &#123;</div><div class="line">                if(aug == -1 || aug &gt; maz[u][v] - flow[u][v]) aug = maz[u][v] - flow[u][v];</div><div class="line">                pre[v] = u;</div><div class="line">                u = cur[u] = v;</div><div class="line">                if(v == end)</div><div class="line">                &#123;</div><div class="line">                    maxflow += aug;</div><div class="line">                    for(u = pre[u]; v != start; v= u, u = pre[u])</div><div class="line">                    &#123;</div><div class="line">                        flow[u][v] += aug;</div><div class="line">                        flow[v][u] -= aug;</div><div class="line">                    &#125;</div><div class="line">                    aug = -1;</div><div class="line">                &#125;</div><div class="line">                goto loop;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int mindis = nodenum - 1;</div><div class="line">        for(int v = 0; v &lt; nodenum; v++)</div><div class="line">        &#123;</div><div class="line">            if(maz[u][v] - flow[u][v] &amp;&amp; mindis &gt; dis[v])</div><div class="line">            &#123;</div><div class="line">                cur[u] = v;</div><div class="line">                mindis = dis[v];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if((--gap[dis[u]]) == 0) break;</div><div class="line">        gap[dis[u] = mindis + 1] ++;</div><div class="line">        u = pre[u];</div><div class="line">    &#125;</div><div class="line">    return maxflow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int ok(int mid)</div><div class="line">&#123;</div><div class="line">    memset(maz,0,sizeof(maz));</div><div class="line">    int t = 0;</div><div class="line">    rep(i,1,n+1)&#123;</div><div class="line">        if(a[i])</div><div class="line">        &#123;</div><div class="line">            maz[i*2-1][i*2] = a[i];</div><div class="line">            maz[0][2*i-1] = a[i];</div><div class="line">            int g = 0;</div><div class="line">            rep(j,1,n+1)</div><div class="line">            &#123;</div><div class="line">                if(s[i][j] == 'Y')&#123;</div><div class="line">                    if(a[j]) maz[i*2-1][j*2] = a[i];</div><div class="line">                    else g = 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if(!g) &#123;</div><div class="line">                maz[i*2][n*2+1] = 1;</div><div class="line">                t++;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                maz[i*2][n*2+1] = mid;</div><div class="line">                t += mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int nowflow = sap(0,2*n+1,2*n+2);</div><div class="line">    printf("%d %d\n",t,nowflow);</div><div class="line">    if(nowflow &gt;= t) return 1;</div><div class="line">    else return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void erfen()</div><div class="line">&#123;</div><div class="line">    int mid;</div><div class="line">    while(l&lt;=r)</div><div class="line">    &#123;</div><div class="line">        mid = (l + r) / 2;</div><div class="line">        if(ok(mid))</div><div class="line">        &#123;</div><div class="line">            l = mid + 1;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            r = mid - 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    l--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">#ifdef LOCAL</div><div class="line">    freopen("/Users/ecooodt/Desktop/c++ and acm/_集训2/sp_12/f.txt","r",stdin);</div><div class="line">#endif</div><div class="line">    int T;</div><div class="line">    scanf("%d",&amp;T);</div><div class="line">    while(T--)</div><div class="line">    &#123;</div><div class="line">        cnt = 0;</div><div class="line">        scanf("%d",&amp;n);</div><div class="line">        rep(i,1,n+1)&#123;</div><div class="line">            scanf("%d",&amp;a[i]);</div><div class="line">        &#125;</div><div class="line">        rep(i,1,n+1)</div><div class="line">        &#123;</div><div class="line">            scanf("%s",s[i]+1);</div><div class="line">        &#125;</div><div class="line">        l = 1,r = 10000;</div><div class="line">        erfen();</div><div class="line">        printf("%d\n",l);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="第十三次训练"><a href="#第十三次训练" class="headerlink" title="第十三次训练"></a>第十三次训练</h2><p>A 水题</p><p>D</p><p>在一个三维空间中，给定一些点，这些点的z坐标都是大于0的。要求求出一个圆锥（底面是圆形），使得这个圆锥的底面在z = 0的平面上，它能够包含所有给定的点并且圆锥的体积要求最小。</p><p>琦神写了一大片板子就过了</p><p>网上的做法是三分，看了看确实不知道比琦神要节省多少时间hhh</p><p>转成二维问题，要求要求$y^2x$的值最小。发现对过p(a,b)，y = K <em> (x - a) + b<br>x =  - a </em> k + b<br>y = -b / k + a<br>V = pi <em> x </em> y^2 = pi <em> (-a </em> k + b) <em> (-b / k + a) ^ 2<br>求个导，发现影响正负的是 -(aK^2 + 2bK)。得到结论，k = -2b/a时取得最小值。<br>三分y，x 用z </em> y / x - (ai^2+bi^2表示就能取到最大)</p><p>E</p><p>给出n个人，m个地方的一维坐标，每个地方至少一个人，使得所有人走动的距离最少的值。</p><p>$dp[i][j] = min(dp[i-1][j],dp[i-1][j-1]) + abs(a[i]-b[j])$</p><p>注意输出路径。</p><p>F<br>$$<br>\frac{p_1!p_2!..p_n!}{q_1!q_2!..q_m!} \r_1!^{s_1}r_2!^{s_2}…r_k!^{s_k}t<br>$$<br>这题想要化简分子和分母都是阶乘之积，即第一幅图，然后形成第二幅图的形式，让r、s尽量大，不管t，并且询问第一个式子是不是整数。<br>q p &lt; 1e4 nm &lt; 1e3</p><p>存每个数的素因子及其个数。然后看分子是否不小于分母。不小于就是整数。</p><p>然后二分r就行了。r的上界就是1e4，r比s优先就不用管s</p><p>G</p><p>交互题，扔给lyy了。</p><p>I </p><p>给出边权，问从1-n的「边权字典序」最小的一种。</p><p>先用一遍bfs跑出d数组，再用一次bfs每次只更新距离+1的点的最小边权，如果有多种则统统扔进queue里，每次统统弹出来扫一遍。</p><p>一开始写的时候是一个一个扔一个一个扫的，这样不能保证字典序最小。</p><p>K </p><p>问在节点度数最多为k的情况下对所有节点染不超过k种的染色方案。</p><p>用bfs遍历一遍图，先用vis扫一遍所有邻边，染一个周围没染过的颜色，再扫一遍把周围邻边的颜色从vis撤出来，就行了</p><hr><h2 id="第十四次训练"><a href="#第十四次训练" class="headerlink" title="第十四次训练"></a>第十四次训练</h2><p>lyy因为要当出题人所以摸了。最后一道题我背了大锅居然忘记了 &amp; 的优先级，结束之后15s过的题</p><p>G题水题</p><p>D题很有意思。D问的是最多只相隔一个连续区间的最长连续序列有多长。</p><p>想到lis的nlogn解法，lis是b里放每个长度LIS的最小末尾，这里我们同样放每个连续递增序列的最后一个元素的最小值。同样二分，同样更新。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;cassert&gt;</div><div class="line">#include&lt;map&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#include&lt;queue&gt;</div><div class="line">#include&lt;stack&gt;</div><div class="line">#include&lt;set&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define rep(i,a,n) for (int i=a;i&lt;n;i++)</div><div class="line">#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)</div><div class="line">#define pb push_back</div><div class="line">#define mp make_pair</div><div class="line">#define all(x) (x).begin(),(x).end()</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define SZ(x) ((int)(x).size())</div><div class="line">typedef vector&lt;int&gt; VI;</div><div class="line">typedef long long ll;</div><div class="line">typedef pair&lt;int,int&gt; PII;</div><div class="line">const ll mod=1000000007;</div><div class="line">ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;</div><div class="line">ll gcd(ll a,ll b) &#123; return b?gcd(b,a%b):a;&#125;</div><div class="line"></div><div class="line">const int maxx=10005;</div><div class="line">const int INF = 0x3f3f3f3f;</div><div class="line">int n,m,k;</div><div class="line">int vis[maxx];</div><div class="line">int l = 0,r = 0;</div><div class="line"></div><div class="line">int len[200005],pos[200005],a[200005],b[200005];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">#ifdef LOCAL</div><div class="line">    freopen("/Users/ecooodt/Desktop/c++ and acm/_集训2/sp_14/d.txt","r",stdin);</div><div class="line">#endif</div><div class="line">    int T,i,n;</div><div class="line">    scanf("%d",&amp;T);</div><div class="line">    while(T--)</div><div class="line">    &#123;</div><div class="line">        memset(b,0x3f,sizeof(b));</div><div class="line">        int ans = 0;</div><div class="line">        scanf("%d",&amp;n);</div><div class="line">        for(i=1;i&lt;=n;i++)</div><div class="line">        scanf("%d",&amp;a[i]);</div><div class="line">        len[1]=1;</div><div class="line">        pos[1]=1;</div><div class="line">        for(i=2;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            if(a[i-1]&lt;a[i])</div><div class="line">            &#123;</div><div class="line">                len[i]=len[i-1]+1;</div><div class="line">                pos[i]=pos[i-1]+1;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                len[i]=1;</div><div class="line">                pos[i]=1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        for(i=n-1;i&gt;=1;i--)</div><div class="line">        &#123;</div><div class="line">            if(a[i]&lt;a[i+1])</div><div class="line">            &#123;</div><div class="line">                len[i]=len[i+1];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        for(i=1;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            //update ans</div><div class="line">            int now=lower_bound(b+1,b+1+n,a[i])-b-1;</div><div class="line">            if(now+len[i]-pos[i]+1&gt;ans)ans=now+len[i]-pos[i]+1;</div><div class="line">            if(a[i]&lt;b[pos[i]])b[pos[i]]=a[i];</div><div class="line">        &#125;</div><div class="line">        printf("%d\n",ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>E题set的应用。</p><p>如果一个水塘连续两次下雨就会炸，必须在第二次之前喝掉水塘里的水。这道题问题就在于水塘里没有水的时候没法喝，不能直接模拟。</p><p>改为贪心，每次下雨取和上次下雨之间区间的第一个不下雨的日子喝掉。用set维护，并用set二分查找。十分方便。</p><p>C题马拉车的应用。</p><p>找一个ww^rww^r，即w和w的反 <em> 2的最长长度。琦神的后缀数组处理不了一些奇怪的height的情况。于是用马拉车，对于每个ww^rww^r，w和w^r必然构成一个回文。但是ww^rww^r可能比ww^r </em> 2要小（大的情况会缩回来变成小的情况），只要找两个w和ww^r中间那里的最长回文是否大于中间的一半就行了</p><p>注意小判断。比如我一直错的地方：只有在字母之间的位置才能进行判断（毕竟%4）</p><p>J题构造</p><p>A题同上海C，求空间中线段距离的平方，用分数表示。<br>先判断线段平行或重合，直接计算每个端点过去的最小值，否则异面直线，带入模版。</p><p>这里先贴一个csdn的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a / gcd(a, b) * b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">struct</span> Rat &#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b;</div><div class="line">    Rat(<span class="keyword">long</span> <span class="keyword">long</span> a = <span class="number">0</span>):a(a), b(<span class="number">1</span>) &#123;&#125;</div><div class="line">    Rat(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y):a(x), b(y) &#123;</div><div class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</div><div class="line">            a = -a;</div><div class="line">            b = -b;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = gcd(a, b);</div><div class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</div><div class="line">            temp = -temp;</div><div class="line">        a /= temp;</div><div class="line">        b /= temp;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Rat <span class="keyword">operator</span> + (<span class="keyword">const</span> Rat&amp; A, <span class="keyword">const</span> Rat&amp; B) &#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = lcm(A.b, B.b);</div><div class="line">    <span class="keyword">return</span> Rat(A.a * (temp / A.b) + B.a * (temp / B.b), temp);</div><div class="line">&#125;</div><div class="line">Rat <span class="keyword">operator</span> - (<span class="keyword">const</span> Rat&amp; A, <span class="keyword">const</span> Rat&amp; B) &#123;</div><div class="line">    <span class="keyword">return</span> A + Rat(-B.a, B.b);</div><div class="line">&#125;</div><div class="line">Rat <span class="keyword">operator</span> * (<span class="keyword">const</span> Rat&amp; A, <span class="keyword">const</span> Rat&amp; B) &#123;</div><div class="line">    <span class="keyword">return</span> Rat(A.a * B.a, A.b * B.b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Min</span><span class="params">(Rat&amp; A, <span class="keyword">const</span> Rat&amp; B)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (A.a * B.b &gt; B.a * A.b) &#123;</div><div class="line">        A.a = B.a;</div><div class="line">        A.b = B.b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Point3 &#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y, z;</div><div class="line">    Point3(<span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">long</span> y = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">long</span> z = <span class="number">0</span>):x(x), y(y), z(z) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> Point3 Vector3;</div><div class="line"></div><div class="line">Vector3 <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector3&amp; A, <span class="keyword">const</span> Vector3&amp; B) &#123;</div><div class="line">    <span class="keyword">return</span> Vector3(A.x + B.x, A.y + B.y, A.z + B.z);</div><div class="line">&#125;</div><div class="line">Vector3 <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector3&amp; A, <span class="keyword">const</span> Vector3&amp; B) &#123;</div><div class="line">    <span class="keyword">return</span> Vector3(A.x - B.x, A.y - B.y, A.z - B.z);</div><div class="line">&#125;</div><div class="line">Vector3 <span class="keyword">operator</span> * (<span class="keyword">const</span> Vector3&amp; A, <span class="keyword">long</span> <span class="keyword">long</span> b) &#123;</div><div class="line">    <span class="keyword">return</span> Vector3(A.x * b, A.y * b, A.z * b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point3&amp; A, <span class="keyword">const</span> Point3&amp; B) &#123;</div><div class="line">    <span class="keyword">return</span> A.x == B.x &amp;&amp; A.y == B.y &amp;&amp; A.z == B.z;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Dot</span> <span class="params">(<span class="keyword">const</span> Vector3&amp; A, <span class="keyword">const</span> Vector3&amp; B)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> A.x * B.x + A.y * B.y + A.z * B.z;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Length</span><span class="params">(<span class="keyword">const</span> Vector3&amp; A)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Dot(A, A);</div><div class="line">&#125;</div><div class="line"><span class="function">Vector3 <span class="title">Cross</span><span class="params">(<span class="keyword">const</span> Vector3&amp; A, <span class="keyword">const</span> Vector3&amp; B)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Vector3(A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x);</div><div class="line">&#125;</div><div class="line"><span class="comment">//点到线段距离</span></div><div class="line"><span class="function">Rat <span class="title">Rat_DistanceToSegment</span><span class="params">(<span class="keyword">const</span> Point3&amp; P, <span class="keyword">const</span> Point3&amp; A, <span class="keyword">const</span> Point3&amp; B)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (A == B)</div><div class="line">        <span class="keyword">return</span> Rat(Length(P - A));</div><div class="line">    Vector3 v1 = B - A, v2 = P - A, v3 = P - B;</div><div class="line">    <span class="keyword">if</span> (Dot(v1, v2) &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> Rat(Length(v2));</div><div class="line">    <span class="keyword">if</span> (Dot(v1, v3) &gt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> Rat(Length(v3));</div><div class="line">    <span class="keyword">return</span> Rat(Length(Cross(v1, v2)), Length(v1));</div><div class="line">&#125;</div><div class="line"><span class="comment">//求p1 + su和p2 + tv两个异面直线的公垂线，如果平行或重合返回false</span></div><div class="line"><span class="comment">//两次调用解出t和s两个参数</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Rat_LineDistance3D</span><span class="params">(<span class="keyword">const</span> Point3&amp; p1, <span class="keyword">const</span> Vector3&amp; u, <span class="keyword">const</span> Point3&amp; p2, <span class="keyword">const</span> Vector3&amp; v, Rat&amp; s)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b = Dot(u, u) * Dot(v, v) - Dot(u, v) * Dot(u, v);</div><div class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a = Dot(u, v) * Dot(v, p1 - p2) - Dot(v, v) * Dot(u, p1 - p2);</div><div class="line">    s = Rat(a, b);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rat_GetPointOnLine</span><span class="params">(<span class="keyword">const</span> Point3&amp; A, <span class="keyword">const</span> Point3&amp; B, <span class="keyword">const</span> Rat&amp; t, Rat&amp; x, Rat&amp; y, Rat&amp; z)</span> </span>&#123;</div><div class="line">    x = Rat(A.x) + Rat(B.x - A.x) * t;</div><div class="line">    y = Rat(A.y) + Rat(B.y - A.y) * t;</div><div class="line">    z = Rat(A.z) + Rat(B.z - A.z) * t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cas;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cas);</div><div class="line">    <span class="keyword">while</span> (cas--) &#123;</div><div class="line">        Point3 L1[<span class="number">2</span>], L2[<span class="number">2</span>];</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>, &amp;L1[<span class="number">0</span>].x, &amp;L1[<span class="number">0</span>].y, &amp;L1[<span class="number">0</span>].z, &amp;L1[<span class="number">1</span>].x, &amp;L1[<span class="number">1</span>].y, &amp;L1[<span class="number">1</span>].z);</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>, &amp;L2[<span class="number">0</span>].x, &amp;L2[<span class="number">0</span>].y, &amp;L2[<span class="number">0</span>].z, &amp;L2[<span class="number">1</span>].x, &amp;L2[<span class="number">1</span>].y, &amp;L2[<span class="number">1</span>].z);</div><div class="line">        Rat res = Rat(<span class="number">1e9</span>) s, t;</div><div class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (Rat_LineDistance3D(L1[<span class="number">0</span>], L1[<span class="number">1</span>] - L1[<span class="number">0</span>], L2[<span class="number">0</span>], L2[<span class="number">1</span>] - L2[<span class="number">0</span>], s)) &#123;</div><div class="line">            <span class="keyword">if</span> (s.a &gt; <span class="number">0</span> &amp;&amp; s.a &lt; s.b &amp;&amp; Rat_LineDistance3D(L2[<span class="number">0</span>], L2[<span class="number">1</span>] - L2[<span class="number">0</span>], L1[<span class="number">0</span>], L1[<span class="number">1</span>] - L1[<span class="number">0</span>], t)) &#123;</div><div class="line">                <span class="keyword">if</span> (t.a &gt; <span class="number">0</span> &amp;&amp; t.a &lt; t.b) &#123; <span class="comment">//点要在线段上需要参数保证在0~1之间</span></div><div class="line">                    flag = <span class="number">1</span>;</div><div class="line">                    Rat x1, y1, z1, x2, y2, z2;</div><div class="line">                    Rat_GetPointOnLine(L1[<span class="number">0</span>], L1[<span class="number">1</span>], s, x1, y1, z1);</div><div class="line">                    Rat_GetPointOnLine(L2[<span class="number">0</span>], L2[<span class="number">1</span>], t, x2, y2, z2);</div><div class="line">                    res = Rat((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!flag) &#123;</div><div class="line">            Min(res, Rat_DistanceToSegment(L1[<span class="number">0</span>], L2[<span class="number">0</span>], L2[<span class="number">1</span>]));</div><div class="line">            Min(res, Rat_DistanceToSegment(L1[<span class="number">1</span>], L2[<span class="number">0</span>], L2[<span class="number">1</span>]));</div><div class="line">            Min(res, Rat_DistanceToSegment(L2[<span class="number">0</span>], L1[<span class="number">0</span>], L1[<span class="number">1</span>]));</div><div class="line">            Min(res, Rat_DistanceToSegment(L2[<span class="number">1</span>], L1[<span class="number">0</span>], L1[<span class="number">1</span>]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (res.a == <span class="number">0</span>)</div><div class="line">            res.b = <span class="number">1</span>;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, res.a, res.b);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>I题</p><hr><h2 id="第十五次训练。"><a href="#第十五次训练。" class="headerlink" title="第十五次训练。"></a>第十五次训练。</h2><h4 id="A-水题"><a href="#A-水题" class="headerlink" title="A 水题"></a>A 水题</h4><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>给出两个1000 <em> 1000的矩阵A B，问A ^ 2 是否 == B（其实是给出一个图，问第二个图是不是第一个图走长为2的路形成的图）<br>普通n^3肯定不妥。用 a </em> (a <em> c) = b </em> c 优化矩阵到n^2</p><h4 id="F题-bfs-dp"><a href="#F题-bfs-dp" class="headerlink" title="F题 bfs dp"></a>F题 bfs dp</h4><p>一只猴子在树上跳来跳去，问你至少要多少次才能保证打死这只猴子，每开一枪猴子都会跳到其他的点上。</p><p>我们把有可能有猴子设为1，没有设为0，那么就是由一个初始全1的串到全0的串的路径长，每开一枪就能把这个点设为0，然后下一个状态就是剩下那些1和他们相通的点，bfs即可，注意记录路径。</p><h4 id="H题-区间dp"><a href="#H题-区间dp" class="headerlink" title="H题 区间dp"></a>H题 区间dp</h4><hr><h2 id="第十六次训练"><a href="#第十六次训练" class="headerlink" title="第十六次训练"></a>第十六次训练</h2><p>鸽了</p><hr><h2 id="第十七次训练"><a href="#第十七次训练" class="headerlink" title="第十七次训练"></a>第十七次训练</h2><p>第十七次训练</p><p>A 求= c(&lt;=1e15)的所有c(n,m)。</p><p>枚举n，二分m。写的话有点小麻烦</p><p>B zz阅读题</p><p>E 不知道</p><p>C 每次从栈里取出一个标号扔到顶上，n 1e5 ，询问每次扔之前它上面有多少个东西。询问1e5</p><p>想到模拟这个栈，每次取出一个标号就给他另赋一个顶值，就可以用一个树桩数组直接维护每个位置了。</p><p>想不到就很麻烦，调了半天树堆，发现312这样的我再取第k大的时候是取不到的。</p><blockquote><p>是Splay的不错的替代品，不过至今还是有一些问题不能很好的解决<br>譬如查询某个数在序列中的第几个位置QAQ</p></blockquote><p>D 大概是2sat问题，虽然有人用二分图过了，不过大概是数据太水。</p><p>F 最大流经典紫书题。。给出一个n * m的矩阵，里面有#和.，#是草，.是洞，洞和草可以以一定代价互相转化，而最后要在保证最外围一圈都是草的情况下给所有洞和草之间以一定代价围上篱笆，问最小代价。</p><p>看到给草和洞之间以代价围篱笆，想到最小割。最小割就是最大流。<br>首先保证最外围一圈都是草，然后把外围草和原点的限流设为无限大，把内部草和原点连限流为代价的边（就是变成洞的代价），内部洞和汇点连限流为代价的边，然后内部之间连边（洞和草之间围栏的代价）跑最大流就行了</p><p>H 大模拟</p><p>类似状态压缩dp。。。？</p><p>有个东西我非常在意：枚举集合sup的子集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = sup; i; i = (i<span class="number">-1</span>)&amp;sup;)<span class="comment">//也可以i != sup</span></div></pre></td></tr></table></figure><p>这还是骚啊。就能直接跑1011（11）的 10,9,8,3,2,1这些。</p><p>另外</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) <span class="keyword">if</span>(t&amp;(<span class="number">1</span>&lt;&lt;i)) v.pb(i);</div></pre></td></tr></table></figure><p>就能直接取出t里面二进制位是1的位置。</p><p>这题就给你13张牌，已知有对子，3，4，3+2，&gt;=5的顺子的出牌方式，问最少多少次能打出所有牌。</p><p>先处理出所有的结束状态。枚举(1&lt;&lt;13) 的状态，用上面的东西枚举子集，i是现在的状态，j是子集的状态，如果i-j是一个结束状态，表示从i状态打到j状态只需要一次，则有更新dp[i] = max(dp[i],dp[j] + 1)这样。</p><p>输出也有点麻烦，dfs跑一遍。</p><hr><h2 id="第十八次训练"><a href="#第十八次训练" class="headerlink" title="第十八次训练"></a>第十八次训练</h2><p>A.水题，扫过不是.之后到下一个不是.的.都算一遍就行了</p><p>B.阅读题，模拟（我都能1a）</p><p>K.猜测、图论</p><p>问你最少连哪些边使得图里没有割边。</p><p>按照dfs序上的连i与i+(n+1)/2即可。正确性不明。</p><p>E.大模拟，bfs没有跑到所有的点wa了两发</p><p>G.分析</p><p>在1-n里猜一个数，每次告诉你猜的数和真正的数的gcd</p><p>当猜一个数他说gcd不为1时缩小的范围一定比说为1的情况大。所以一定都说1，问题转化为给n以内的素数分组，使得每组之积不大于n，求最小的组数。（就是每次猜一组素数乘积的数字）每次取最大的和小的合并就行了</p><p>D</p><p>给出n个word，问能组成多少个串，满足要么这个串是word，要么可以被分成两份，前份是某个word的前缀，后份是某个word的后缀。</p><p>显然想到字典树。</p><p>字典树可以很好的去掉重复组成，但是有另一个种重复，就abc可以分为a|bc，也可以分为ab|c。对于每个前缀，向后添加一个字符时，以这个字符为首的后缀都算重了，就统计以x为儿子的前缀数量，以x为儿子的后缀数量，相乘就是重复数。（换个说法，统计两个树里除了和根相连的字母出现次数）最后加上长度为1的单词</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;cassert&gt;</div><div class="line">#include&lt;map&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#include&lt;queue&gt;</div><div class="line">#include&lt;stack&gt;</div><div class="line">#include&lt;set&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define rep(i,a,n) for (int i=a;i&lt;n;i++)</div><div class="line">#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)</div><div class="line">#define pb push_back</div><div class="line">#define mp make_pair</div><div class="line">#define all(x) (x).begin(),(x).end()</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define SZ(x) ((int)(x).size())</div><div class="line">typedef vector&lt;int&gt; VI;</div><div class="line">typedef long long ll;</div><div class="line">typedef pair&lt;int,int&gt; PII;</div><div class="line">const ll mod=1000000007;</div><div class="line">ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;</div><div class="line">ll gcd(ll a,ll b) &#123; return b?gcd(b,a%b):a;&#125;</div><div class="line"></div><div class="line">const int maxx=40005;</div><div class="line">const int INF = 0x3f3f3f3f;</div><div class="line">int n,m,k;</div><div class="line">int a[maxx];</div><div class="line">int vis[maxx];</div><div class="line">int ans = 0,cnt = 0,pos = 0;</div><div class="line">int l = 0,r = 0;</div><div class="line"></div><div class="line">struct Trie&#123;</div><div class="line">    int sz,g[maxx][26];</div><div class="line">    int c[26];</div><div class="line"></div><div class="line">    void init()&#123;</div><div class="line">        sz = 1;</div><div class="line">        memset(g[0],0,sizeof(g[0]));</div><div class="line">        memset(c,0,sizeof(c));</div><div class="line">    &#125;</div><div class="line">    void insert(char *s)&#123;</div><div class="line">        int u = 0,n = strlen(s);</div><div class="line">        for(int i = 0; i &lt; n; i++)</div><div class="line">        &#123;</div><div class="line">            int v = s[i]-'a';</div><div class="line">            if(g[u][v] == 0)&#123;</div><div class="line">                memset(g[sz],0,sizeof(g[sz]));</div><div class="line">                g[u][v] = sz++;</div><div class="line">                if(i) c[v]++;</div><div class="line">            &#125;</div><div class="line">            u = g[u][v];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;pre,suf;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">#ifdef LOCAL</div><div class="line">//    freopen("","r",stdin);</div><div class="line">#endif</div><div class="line">    freopen("dictionary.in","r",stdin);</div><div class="line">    freopen("dictionary.out","w",stdout);</div><div class="line">    scanf("%d",&amp;n);</div><div class="line">    char word[45];</div><div class="line">    pre.init();</div><div class="line">    suf.init();</div><div class="line">    for(int i = 0; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        scanf("%s",word);</div><div class="line">        pre.insert(word);</div><div class="line">        if(strlen(word) == 1) vis[word[0]-'a'] = 1;</div><div class="line">        reverse(word,word+strlen(word));</div><div class="line">        suf.insert(word);</div><div class="line">    &#125;</div><div class="line">    ll ans = 1ll * (pre.sz-1) * (suf.sz-1);</div><div class="line">    rep(i,0,26)&#123;</div><div class="line">        ans -= (ll)pre.c[i] * suf.c[i] - vis[i];</div><div class="line">    &#125;</div><div class="line">    printf("%lld\n",ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="第19次训练"><a href="#第19次训练" class="headerlink" title="第19次训练"></a>第19次训练</h2><h4 id="JD-水题"><a href="#JD-水题" class="headerlink" title="JD 水题"></a>JD 水题</h4><h4 id="I题-思维"><a href="#I题-思维" class="headerlink" title="I题 思维"></a>I题 思维</h4><p>给出一个区间，查询里面是否有重复的数，如果有，随便输出一个。</p><p>处理出每个数和他后面一个数，那么这个d[i] = min(d[i+1],pos)。</p><h4 id="C题大模拟"><a href="#C题大模拟" class="headerlink" title="C题大模拟"></a>C题大模拟</h4><h4 id="B题中国剩余定理"><a href="#B题中国剩余定理" class="headerlink" title="B题中国剩余定理"></a>B题中国剩余定理</h4><h4 id="F题-动态树板题"><a href="#F题-动态树板题" class="headerlink" title="F题 动态树板题"></a>F题 动态树板题</h4><p>然而动态树板子不够优秀，不能封装k个lct（其实是不会改…）。<br>抄了个别的板子，怎么用还是个问题。</p><h4 id="E题-假题"><a href="#E题-假题" class="headerlink" title="E题 假题"></a>E题 假题</h4><hr><h2 id="第20次训练"><a href="#第20次训练" class="headerlink" title="第20次训练"></a>第20次训练</h2><p>orz我做了一堆水题，没什么好说的。</p><p>吐个槽，有个题给出网球规则，结果给错了却按照真实的来。。我就不该认真读题。shit</p><hr><h2 id="第21次训练"><a href="#第21次训练" class="headerlink" title="第21次训练"></a>第21次训练</h2><p>AH lyy切</p><h4 id="B-树状数组"><a href="#B-树状数组" class="headerlink" title="B 树状数组"></a>B 树状数组</h4><p>题意给出2 * n个竖着的方块，每次相同的碰撞会使得两两抵消，问最少交换多少次相邻的两个方块使得所有的方块都可以被抵消？</p><p>emmm，我也是听了隔壁的思路做的。猜测每次都从左向右贪心每个不能抵消的方块最优，而每个不能抵消的方块需要抵消的话就需要找前面的他自己出现的位置，问题转换为查询每个数字前一次出现的位置，这样就是很简单的bit的题了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;cassert&gt;</div><div class="line">#include&lt;map&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#include&lt;queue&gt;</div><div class="line">#include&lt;stack&gt;</div><div class="line">#include&lt;set&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define rep(i,a,n) for (int i=a;i&lt;n;i++)</div><div class="line">#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)</div><div class="line">#define pb push_back</div><div class="line">#define mp make_pair</div><div class="line">#define all(x) (x).begin(),(x).end()</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define SZ(x) ((int)(x).size())</div><div class="line">typedef vector&lt;int&gt; VI;</div><div class="line">typedef long long ll;</div><div class="line">typedef pair&lt;int,int&gt; PII;</div><div class="line">const ll mod=1000000007;</div><div class="line">ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;</div><div class="line">ll gcd(ll a,ll b) &#123; return b?gcd(b,a%b):a;&#125;</div><div class="line"></div><div class="line">const int maxx=1000500;</div><div class="line">const int INF = 0x3f3f3f3f;</div><div class="line">int n,m,k;</div><div class="line">int a[maxx];</div><div class="line">int vis[maxx];</div><div class="line">int c[maxx];</div><div class="line">int ans = 0,cnt = 0,pos = 0;</div><div class="line">int l = 0,r = 0;</div><div class="line"></div><div class="line">int lowbit(int x)</div><div class="line">&#123;</div><div class="line">    return x &amp; (-x);</div><div class="line">&#125;</div><div class="line">void add(int x,int add)//一维</div><div class="line">&#123;</div><div class="line">    while(x &lt;= n*2)</div><div class="line">    &#123;</div><div class="line">        c[x]+=add;</div><div class="line">        x+=lowbit(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int sum(int x)</div><div class="line">&#123;</div><div class="line">    int s=0;</div><div class="line">    while(x &gt; 0)</div><div class="line">    &#123;</div><div class="line">        s += c[x];</div><div class="line">        x -= lowbit(x);</div><div class="line">    &#125;</div><div class="line">    return s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">#ifdef LOCAL</div><div class="line">//    freopen("","r",stdin);</div><div class="line">#endif</div><div class="line">    freopen("b.in","r",stdin);</div><div class="line">    scanf("%d",&amp;n);</div><div class="line">    rep(i,1,2*n+1)&#123;</div><div class="line">        scanf("%d",&amp;a[i]);</div><div class="line">    &#125;</div><div class="line">    memset(vis,0,sizeof(vis));</div><div class="line">    rep(i,1,2*n+1)&#123;</div><div class="line">        if(vis[a[i]])&#123;</div><div class="line">            int t = sum(i) - sum(vis[a[i]]-1);</div><div class="line">            add(vis[a[i]],-1);</div><div class="line">            ans += t-1;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            vis[a[i]] = i;</div><div class="line">            add(i,1);</div><div class="line">        &#125;</div><div class="line">//        printf("%d\n",ans);</div><div class="line">    &#125;</div><div class="line">    printf("%d\n",ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="C题水题"><a href="#C题水题" class="headerlink" title="C题水题"></a>C题水题</h4><p>这题该lyy切的。。我不适合切什么质数之类的破题</p><h4 id="E题大模拟"><a href="#E题大模拟" class="headerlink" title="E题大模拟"></a>E题大模拟</h4><p>模拟一个折叠翻转的过程。。。调参一个半小时才调出来</p><h4 id="G题队列模拟"><a href="#G题队列模拟" class="headerlink" title="G题队列模拟"></a>G题队列模拟</h4><h4 id="I题-树"><a href="#I题-树" class="headerlink" title="I题 树"></a>I题 树</h4><p>求树上每个点和他距离最远的点距离。lca做多了直接一发lca贴上去发现不对。</p><p>先随便取个根，求出与这个根最远的点，然后求出与这个最远的点最远的点，则答案一定取自这两个点之中一个。正确性。。emmmm，显然！（不显然）</p><hr><h2 id="第22次训练"><a href="#第22次训练" class="headerlink" title="第22次训练"></a>第22次训练</h2><h4 id="A-最大流"><a href="#A-最大流" class="headerlink" title="A 最大流"></a>A 最大流</h4><p>求有向图里不重复走边1-n的两条路的权值和。有向图，拆点。</p><h4 id="D-模拟"><a href="#D-模拟" class="headerlink" title="D 模拟"></a>D 模拟</h4><h4 id="E-fibonacci"><a href="#E-fibonacci" class="headerlink" title="E fibonacci"></a>E fibonacci</h4><p>很奇怪，环里取匹配数居然是fibonacci，不过好像有个什么locas定理就是a[n-1]+a[n-2]</p><h4 id="I-2-sat"><a href="#I-2-sat" class="headerlink" title="I 2-sat"></a>I 2-sat</h4><p>裸题。。。</p><h4 id="J-水题"><a href="#J-水题" class="headerlink" title="J 水题"></a>J 水题</h4><p>我就不说我直接贴set忘记重复的事了。。</p><hr><h1 id="秋季训练"><a href="#秋季训练" class="headerlink" title="秋季训练"></a>秋季训练</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新区域赛的题。。大概会更新的吧。咕咕咕&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://oodtoodt.github.io/categories/acm/"/>
    
    
      <category term="shujia" scheme="http://oodtoodt.github.io/tags/shujia/"/>
    
  </entry>
  
  <entry>
    <title>rmq系列</title>
    <link href="http://oodtoodt.github.io/2018/07/15/%E4%B8%93%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/rmq%E7%B3%BB%E5%88%97/rmq%E7%B3%BB%E5%88%97/"/>
    <id>http://oodtoodt.github.io/2018/07/15/%E4%B8%93%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/rmq%E7%B3%BB%E5%88%97/rmq%E7%B3%BB%E5%88%97/</id>
    <published>2018-07-15T13:33:34.000Z</published>
    <updated>2018-07-15T13:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>rmq系列。有一些之前写的题。多是些半途而废（对说的就是主席树和树状数组）的专题，有时间另专开几个讨论他们好了</p><a id="more"></a><hr><p>Rmq</p><p>就是区间查询的问题，有三（四？）种写法：线段树，树状数组（只能求和【存疑】），st（只能求最值【存疑】），（差分？）</p><p>写了几个线段树之后发现最值的话还是直接用st算了</p><hr><h3 id="划分树"><a href="#划分树" class="headerlink" title="划分树"></a>划分树</h3><blockquote><p>主要用于快速求出(在log(n)的时间复杂度内）序列区间的第k大值。</p></blockquote><p>划分树是从上向下，按排序依次把小于区间中位数的放在左子树，大于的放到右子树，维护每一层到i点进入左子树的数量，查询时直接获取是左还是右，是第几个，递归（思想其实像二分）。建树复杂度在nlogn，查询就是logn了。</p><p>其实也可以理解成一个线段树，先归并排序，存每一段的起点和终点，然后二分枚举查找区间内比当前枚举数小和相等的数是多少。其实大体思路相似。</p><p>板子（带了求和，是hdu3473的板子）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</div><div class="line">ll suml[<span class="number">20</span>][MAXN],sum[MAXN];<span class="comment">//注意suml是单层，不要更新错</span></div><div class="line"><span class="keyword">int</span> tree[<span class="number">20</span>][MAXN];<span class="comment">//表示每层每个位置的值</span></div><div class="line"><span class="keyword">int</span> sorted[MAXN];<span class="comment">//已经排序好的数</span></div><div class="line"><span class="keyword">int</span> toleft[<span class="number">20</span>][MAXN];<span class="comment">//toleft[p][i]表示第i层从1到i有数分入左边</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dep)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> same = mid - l + <span class="number">1</span>;<span class="comment">//表示等于中间值而且被分入左边的个数</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) <span class="comment">//注意是l,不是one</span></div><div class="line">    <span class="keyword">if</span>(tree[dep][i] &lt; sorted[mid]) same--;</div><div class="line">    <span class="keyword">int</span> lpos = l;</div><div class="line">    <span class="keyword">int</span> rpos = mid+<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) &#123;</div><div class="line">        <span class="keyword">if</span>(tree[dep][i] &lt; sorted[mid]) &#123;</div><div class="line">            tree[dep+<span class="number">1</span>][lpos++] = tree[dep][i];</div><div class="line">            suml[dep][i] = suml[dep][i<span class="number">-1</span>] + tree[dep][i];<span class="comment">//左进一</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[dep][i] == sorted[mid] &amp;&amp; same &gt; <span class="number">0</span>) &#123;</div><div class="line">            tree[dep+<span class="number">1</span>][lpos++] = tree[dep][i];</div><div class="line">            suml[dep][i] = suml[dep][i<span class="number">-1</span>] + tree[dep][i];<span class="comment">//左进一</span></div><div class="line">            same--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            tree[dep+<span class="number">1</span>][rpos++] = tree[dep][i];</div><div class="line">            suml[dep][i] = suml[dep][i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">        toleft[dep][i] = toleft[dep][l<span class="number">-1</span>] + lpos - l;</div><div class="line">    &#125;</div><div class="line">    build(l,mid,dep+<span class="number">1</span>);</div><div class="line">    build(mid+<span class="number">1</span>,r,dep+<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> lnum,rnum;</div><div class="line">ll lsum;</div><div class="line"><span class="comment">//查询区间第k大的数,[L,R]是大区间，[l,r]是要查询的小区间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dep,<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(l == r) &#123;</div><div class="line">        <span class="keyword">return</span> tree[dep][l];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> cnt = toleft[dep][r] - toleft[dep][l<span class="number">-1</span>];</div><div class="line">    <span class="keyword">if</span>(cnt &gt;= k)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> newl = L + toleft[dep][l<span class="number">-1</span>] - toleft[dep][L<span class="number">-1</span>];</div><div class="line">        <span class="keyword">int</span> newr = newl + cnt - <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> query(L,mid,newl,newr,dep+<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> newr = r + toleft[dep][R] - toleft[dep][r];</div><div class="line">        <span class="keyword">int</span> newl = newr - (r-l-cnt);</div><div class="line">        lnum += cnt;</div><div class="line">        lsum += suml[dep][r] - suml[dep][l<span class="number">-1</span>];</div><div class="line">        <span class="keyword">return</span> query(mid+<span class="number">1</span>,R,newl,newr,dep+<span class="number">1</span>,k-cnt);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="hdu2665-poj2104"><a href="#hdu2665-poj2104" class="headerlink" title="hdu2665 poj2104"></a>hdu2665 poj2104</h4><p>模板题</p><h4 id="hdu3473"><a href="#hdu3473" class="headerlink" title="hdu3473"></a>hdu3473</h4><p>在一段区间内选一个数使得区间内其他数与它的差的绝对值和最小，并求这个和。关键：许多查询，区间，和。<br>上面的板子再加上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span>(T--)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++pos);</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tree[<span class="number">0</span>][i]);</div><div class="line">            sum[i] = sum[i<span class="number">-1</span>] + tree[<span class="number">0</span>][i];</div><div class="line">            sorted[i] = tree[<span class="number">0</span>][i];</div><div class="line">        &#125;</div><div class="line">        sort(sorted+<span class="number">1</span>,sorted+n+<span class="number">1</span>);</div><div class="line">        build(<span class="number">1</span>,n,<span class="number">0</span>);</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</div><div class="line">            l++,r++;</div><div class="line">            lnum = <span class="number">0</span>,lsum = <span class="number">0</span>;</div><div class="line"><span class="comment">//            int p = ((l+r)&gt;&gt;1) + 1;</span></div><div class="line">            <span class="keyword">int</span> t = query(<span class="number">1</span>,n,l,r,<span class="number">0</span>,(r-l)/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">            <span class="keyword">int</span> rnum = r - l + <span class="number">1</span> - lnum;</div><div class="line">            ll rsum = sum[r] - sum[l<span class="number">-1</span>] - lsum;</div><div class="line"><span class="comment">//            ll ans = rsum-lsum + t*(lnum-rnum);</span></div><div class="line">            ll ans = t*lnum - lsum - (t * rnum - rsum);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//if(T != 0)</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="hdu4417"><a href="#hdu4417" class="headerlink" title="hdu4417"></a>hdu4417</h4><p>问如果马里奥最多能跳H高，那么能达到[L,R]里多少个方块？</p><p>二分+划分树….二分个数，划分树求出值与H比较大小即可。因为二分一直跑了个0的下标，一直在re。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> a[maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</div><div class="line">ll suml[<span class="number">20</span>][MAXN],sum[MAXN];<span class="comment">//注意suml是单层，不要更新错</span></div><div class="line"><span class="keyword">int</span> tree[<span class="number">20</span>][MAXN];<span class="comment">//表示每层每个位置的值</span></div><div class="line"><span class="keyword">int</span> sorted[MAXN];<span class="comment">//已经排序好的数</span></div><div class="line"><span class="keyword">int</span> toleft[<span class="number">20</span>][MAXN];<span class="comment">//toleft[p][i]表示第i层从1到i有数分入左边</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dep)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> same = mid - l + <span class="number">1</span>;<span class="comment">//表示等于中间值而且被分入左边的个数</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) <span class="comment">//注意是l,不是one</span></div><div class="line">    <span class="keyword">if</span>(tree[dep][i] &lt; sorted[mid]) same--;</div><div class="line">    <span class="keyword">int</span> lpos = l;</div><div class="line">    <span class="keyword">int</span> rpos = mid+<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) &#123;</div><div class="line">        <span class="keyword">if</span>(tree[dep][i] &lt; sorted[mid]) &#123;</div><div class="line">            tree[dep+<span class="number">1</span>][lpos++] = tree[dep][i];</div><div class="line">            suml[dep][i] = suml[dep][i<span class="number">-1</span>] + tree[dep][i];<span class="comment">//左进一</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[dep][i] == sorted[mid] &amp;&amp; same &gt; <span class="number">0</span>) &#123;</div><div class="line">            tree[dep+<span class="number">1</span>][lpos++] = tree[dep][i];</div><div class="line">            suml[dep][i] = suml[dep][i<span class="number">-1</span>] + tree[dep][i];<span class="comment">//左进一</span></div><div class="line">            same--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            tree[dep+<span class="number">1</span>][rpos++] = tree[dep][i];</div><div class="line">            suml[dep][i] = suml[dep][i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">        toleft[dep][i] = toleft[dep][l<span class="number">-1</span>] + lpos - l;</div><div class="line">    &#125;</div><div class="line">    build(l,mid,dep+<span class="number">1</span>);</div><div class="line">    build(mid+<span class="number">1</span>,r,dep+<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> lnum,rnum;</div><div class="line">ll lsum;</div><div class="line"><span class="comment">//查询区间第k大的数,[L,R]是大区间，[l,r]是要查询的小区间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> dep,<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(l == r) &#123;</div><div class="line">        <span class="keyword">return</span> tree[dep][l];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> cnt = toleft[dep][r] - toleft[dep][l<span class="number">-1</span>];</div><div class="line">    <span class="keyword">if</span>(cnt &gt;= k)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> newl = L + toleft[dep][l<span class="number">-1</span>] - toleft[dep][L<span class="number">-1</span>];</div><div class="line">        <span class="keyword">int</span> newr = newl + cnt - <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> query(L,mid,newl,newr,dep+<span class="number">1</span>,k);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> newr = r + toleft[dep][R] - toleft[dep][r];</div><div class="line">        <span class="keyword">int</span> newl = newr - (r-l-cnt);</div><div class="line">        lnum += cnt;</div><div class="line">        lsum += suml[dep][r] - suml[dep][l<span class="number">-1</span>];</div><div class="line">        <span class="keyword">return</span> query(mid+<span class="number">1</span>,R,newl,newr,dep+<span class="number">1</span>,k-cnt);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> mid)</span></span></div><div class="line">&#123;</div><div class="line"><span class="comment">//    if()</span></div><div class="line">    <span class="keyword">int</span> t = query(<span class="number">1</span>,n,l,r,<span class="number">0</span>,mid);</div><div class="line">    <span class="keyword">if</span>(t &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">erfen</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> mid;</div><div class="line">    <span class="keyword">int</span> ll = <span class="number">1</span>,rr = r-l+<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(ll&lt;=rr)</div><div class="line">    &#123;</div><div class="line">        mid = (ll + rr) / <span class="number">2</span>;</div><div class="line">        <span class="comment">//      printf("%d\n",mid);</span></div><div class="line">        <span class="keyword">if</span>(ok(mid))</div><div class="line">        &#123;</div><div class="line">            ll = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            rr = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//    ll--;</span></div><div class="line">    <span class="keyword">return</span> ll;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/special--专题/5-数据结构/hfs划分树/hdu4417.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span>(T--)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tree[<span class="number">0</span>][i]);</div><div class="line">            sum[i] = sum[i<span class="number">-1</span>] + tree[<span class="number">0</span>][i];</div><div class="line">            sorted[i] = tree[<span class="number">0</span>][i];</div><div class="line">        &#125;</div><div class="line">        sort(sorted+<span class="number">1</span>,sorted+n+<span class="number">1</span>);</div><div class="line">        build(<span class="number">1</span>,n,<span class="number">0</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,++cnt);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</div><div class="line">            l++,r++;</div><div class="line">            <span class="keyword">int</span> t = erfen();</div><div class="line">            <span class="keyword">if</span>(t &gt; <span class="number">0</span>) t--;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="st板子"><a href="#st板子" class="headerlink" title="st板子"></a>st板子</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dp[maxx][<span class="number">20</span>];</div><div class="line"><span class="keyword">int</span> mm[maxx];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initrmq</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> b[])</span></span></div><div class="line">&#123;</div><div class="line">    mm[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        mm[i] = ((i&amp;(i<span class="number">-1</span>)) == <span class="number">0</span>)?mm[i<span class="number">-1</span>]+<span class="number">1</span>:mm[i<span class="number">-1</span>];</div><div class="line">        dp[i][<span class="number">0</span>] = b[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mm[n]; j++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span>&lt;&lt;j) <span class="number">-1</span> &lt;= n; i++)&#123;</div><div class="line">            dp[i][j] = max(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> k = mm[y-x+<span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> max(dp[x][k],dp[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="bzoj-1067"><a href="#bzoj-1067" class="headerlink" title="bzoj 1067"></a>bzoj 1067</h4><p>这个题太暴力了….我选择死亡。</p><p>认真点说的话，去网上查一下吧还是。大概要考虑6种情况，还要放到线段树里，st的话，还是算了吧。</p><h4 id="hdu3486"><a href="#hdu3486" class="headerlink" title="hdu3486"></a>hdu3486</h4><p>题意：给出一串数(n&lt;200000)，问最小选出多少个区间（区间长度=n / 区间个数）使得每个区间内的最大值的和大于给定的一个值？</p><p>一种做法是二分区间长度（个数），rmq查询最大值。但是有一个问题：二分不一定得到的是最优解，虽然过了但是我觉得很奇怪…..比如 1 1 1000 1000 1 1，大于1500的话，答案应该是2，但是二分时第一次选3个区间，过不了，就会往大里选，最后选到6。</p><p>嘛。。枚举会好一点。应该说会是正确的。应该是数据水了。</p><h4 id="hdu3193"><a href="#hdu3193" class="headerlink" title="hdu3193"></a>hdu3193</h4><p>给出一些旅馆的di和pi，如果存在di和pi同时小于该旅馆的某个旅馆则放弃该旅馆，问最后剩下哪些旅馆？n &lt; 10000</p><p>首先对其中一个数据从小到大排序，另一个数据次要从大到小排序，然后对次要数据做rmq，找到每个旅馆是不是最小值，如果是就扔进答案里。</p><p>如果不用rmq的话，感觉排序之后遍历记录值的方法似乎也可以做。QAQ</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="comment">//int a[maxx];</span></div><div class="line"><span class="keyword">struct</span> pp&#123;</div><div class="line">    <span class="keyword">int</span> p,d;</div><div class="line">&#125;a[maxx];</div><div class="line"><span class="keyword">int</span> b[maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"><span class="built_in">vector</span>&lt;pp&gt; ve;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(pp a,pp b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(a.d != b.d) <span class="keyword">return</span> a.d &lt; b.d;</div><div class="line">    <span class="keyword">return</span> a.p &gt; b.p;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(pp a,pp b)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(a.p != b.p) <span class="keyword">return</span> a.p&lt;b.p;</div><div class="line">    <span class="keyword">return</span> a.d &lt; b.d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> dp[maxx][<span class="number">20</span>];</div><div class="line"><span class="keyword">int</span> mm[maxx];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initrmq</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    mm[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        mm[i] = ((i&amp;(i<span class="number">-1</span>)) == <span class="number">0</span>)?mm[i<span class="number">-1</span>]+<span class="number">1</span>:mm[i<span class="number">-1</span>];</div><div class="line">        dp[i][<span class="number">0</span>] = a[i].p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mm[n]; j++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span>&lt;&lt;j) <span class="number">-1</span> &lt;= n; i++)&#123;</div><div class="line">            dp[i][j] = min(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> k = mm[y-x+<span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> min(dp[x][k],dp[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/special--专题/5-数据结构/rmq区间查询/st/hdu3193.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        ve.clear();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].p,&amp;a[i].d);</div><div class="line">        &#125;</div><div class="line">        sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</div><div class="line">        initrmq(n);</div><div class="line"><span class="comment">//        ve.push_back(a[1]);</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> t = rmq(<span class="number">1</span>,i);</div><div class="line"><span class="comment">//            printf("t = %d   %d %d\n",t,a[i].p,a[i].d);</span></div><div class="line">            <span class="keyword">if</span>(t &gt;= a[i].p) ve.push_back(a[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ve.size());</div><div class="line">        sort(ve.begin(),ve.end(),cmp1);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve.size(); i++)&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ve[i].p,ve[i].d);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><p>尽是些板子题，不贴也罢？</p><p>有点感觉就行了。</p><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>树状数组有着代码短小，常数小（快）的特点，所以能用树状数组的地方尽量就用。</p><p>BIT模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> x &amp; (-x);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> add)</span><span class="comment">//一维</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(x &lt;= n)</div><div class="line">    &#123;</div><div class="line">        a[x]+=add;</div><div class="line">        x+=lowbit(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        s += a[x];</div><div class="line">        x -= lowbit(x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> data)</span><span class="comment">//二维</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;MAXN;i+=lowbit(i))</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;MAXN;j+=lowbit(j))</div><div class="line">            a[i][j]+=data;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&gt;<span class="number">0</span>;j-=lowbit(j))</div><div class="line">            res+=a[i][j];</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=i&amp;(-i)) </div><div class="line">    &#123;</div><div class="line">      c1[i]+=y;</div><div class="line">  c2[i]+=(<span class="keyword">long</span> <span class="keyword">long</span>)x*y;</div><div class="line">    &#125;<span class="comment">//给差分数组中的位置x加上y</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//查询前x项的和</span></div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i;i-=i&amp;(-i)) ans+=(x+<span class="number">1</span>)*c1[i]-c2[i];</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><blockquote><p>逆序对仅在数组中有意义，对于一个包含n个非负整数的数组a，如果有i<j，且a[i]>a[j]，则称（a[i]，A[j]）为数组a中的一个逆序对</j，且a[i]></p></blockquote><p>关于逆序对…..离散化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Node&#123;</div><div class="line">    <span class="keyword">int</span> v;</div><div class="line">    <span class="keyword">int</span> order;</div><div class="line">&#125;a[maxx];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> a.v &lt; b.v;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> x &amp; (-x);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> add)</span><span class="comment">//一维</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(x &lt;= n)</div><div class="line">    &#123;</div><div class="line">        c[x]+=add;</div><div class="line">        x+=lowbit(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        s += c[x];</div><div class="line">        x -= lowbit(x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/special--专题/5-数据结构/bit树状数组/hdu1394.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].v);</div><div class="line">        a[i].order = i;</div><div class="line">    &#125;</div><div class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</div><div class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        b[a[i].order] = i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        add(b[i],<span class="number">1</span>);</div><div class="line">        ans += i - sum(b[i]);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>我还是有点绕不过来。在这里理一下</p><p>首先，离散化a，a按数值大小排序，然后依照在原a中的序号给b[序号] = i，所以b现在就是离散化过的原数组了（大概</p><p>然后用离散过的b[i]，每次在b[i]上更新1，然后每次求1~b[i]的和就能求出小于b[i]的值的数量，嗯~巧妙。这时i-sum(b[i])就是当前数字与前面所有数字形成的逆序对的个数</p><p>那么问题在于为什么要在线更新？离线就是错的吗？试了一下直接会出很大的数。</p><p>我想了一下，因为离线的话就会无视顺序了。就 1 3，会把1更到3的前面导致1 3成为一个逆序对。</p><h4 id="hdu1394"><a href="#hdu1394" class="headerlink" title="hdu1394"></a>hdu1394</h4><p>求一个数列不停左移（溢出填进最右边）过程中，逆序对最少的数量</p><p>其实就是将第一个数移到最后一个数。这个操作会减去第一个数的所有逆序对(sum b[i]-1，这里不需要考虑顺序因为是第一个元素），然后加上所有大于第一个数的逆序对(n-sum(b[i]))就是更新过的数量了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> c[maxx];</div><div class="line"><span class="keyword">int</span> b[maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Node&#123;</div><div class="line">    <span class="keyword">int</span> v;</div><div class="line">    <span class="keyword">int</span> order;</div><div class="line">&#125;a[maxx];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> a.v &lt; b.v;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> x &amp; (-x);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> add)</span><span class="comment">//一维</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(x &lt;= n)</div><div class="line">    &#123;</div><div class="line">        c[x]+=add;</div><div class="line">        x+=lowbit(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        s += c[x];</div><div class="line">        x -= lowbit(x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/special--专题/5-数据结构/bit树状数组/hdu1394.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].v);</div><div class="line">            a[i].order = i;</div><div class="line">        &#125;</div><div class="line">        sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</div><div class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</div><div class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            b[a[i].order] = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            add(b[i],<span class="number">1</span>);</div><div class="line">            ans += i-sum(b[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> A = ans;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            ans += (n-sum(b[i])-sum(b[i])+<span class="number">1</span>);</div><div class="line">            A = min(ans,A);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,A);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="hdu1556"><a href="#hdu1556" class="headerlink" title="hdu1556"></a>hdu1556</h4><p>每次给出l,r，使得区间+1。问每个单点的值。思路就a[l]++,a[r+1]–，统计一波前缀和或者直接用树状数组维护</p><h1 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h1><p>说实话这种数据结构我不是很懂。话说的很清楚：每个操作只修改logn个点（修改的点和改变过的点），对于每个修改都记录下来，使用n个线段树的思想却只是使用了历史版本和一个logn线。</p><blockquote><p>注意，这个线段树对一条线段，保存的是这个数字区间的出现次数，所以是可以互相加减的！还有，由于每棵线段树都要保存同样的数字，所以它们的大小、形态也都是一样的！这实在是两个非常好的性质，是平衡树所不具备的。</p><p>对于询问 (i,j)，我只要拿出 Tj 和 Ti-1，对每个节点相减就可以了。说的通俗一点，询问 i..j 区间中，一个数字区间的出现次数时，就是这些数字在 Tj 中出现的次数减去在 Ti-1 中出现的次数。</p><p>那么有修改操作怎么办呢？</p><p>如果将询问看成求一段序列的数字和，那么上面那个相当于求出了前缀和。加入修改操作后，就要用树状数组等来维护前缀和了。于是那个 “很好的性质” 又一次发挥了作用，由于主席树可以互相加减，所以可以用树状数组来套上它。做法和维护前缀和长得基本一样，不说了。</p></blockquote><p>大体就是这样，也说不出什么东西，然而理解不到。做题。</p><h4 id="poj2104"><a href="#poj2104" class="headerlink" title="poj2104"></a>poj2104</h4><p>又拿出第k大来当模板….看完主席树就知道其实线段树就能搞这个题，离散后记录数本身，然后查询数的位置应该就行。</p><p>主席树的思路有些许的不同了，就成了建[1,1];[1,2]…[1,n]的所有的线段树，然后直接把[1,l-1],[1,r]相减（某性质），后面一样。直接对现在这颗树二分查找就是第k大。</p><p>代码参照的uestc。</p><p>按照代码来理解的话，主席树里存的是离散化过的数据（就是有一个1就a[1]+1那种感觉），sum[i]表示[1,i]里有多少个数，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">100</span>;</div><div class="line"><span class="keyword">int</span> rt[N],ls[N*<span class="number">100</span>],rs[N*<span class="number">100</span>],sum[N*<span class="number">100</span>];</div><div class="line"><span class="keyword">int</span> a[N],b[N],tot;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> lower_bound(v.begin(),v.end(),x) - v.begin() + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    o= ++tot,sum[o]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</div><div class="line">    build(ls[o],l,mid);</div><div class="line">    build(rs[o],mid+<span class="number">1</span>,r);</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> last,<span class="keyword">int</span> p,<span class="keyword">int</span> v)</span></span></div><div class="line">&#123;<span class="comment">//p是更新的点，last是上一个点，o是树根(?)</span></div><div class="line">    o= ++tot;</div><div class="line">    ls[o]=ls[last],rs[o]=rs[last];</div><div class="line">    sum[o]=sum[last]+v;</div><div class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(p&lt;=mid) update(ls[o],l,mid,ls[last],p,v);</div><div class="line">    <span class="keyword">else</span> update(rs[o],mid+<span class="number">1</span>,r,rs[last],p,v);</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> vis[<span class="number">1000000</span>+<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(l==r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> l;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> s = sum[ls[y]]-sum[ls[x]];</div><div class="line">    <span class="keyword">if</span>(k&lt;=s) <span class="keyword">return</span> query(ls[x],ls[y],l,mid,k);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rs[x],rs[y],mid+<span class="number">1</span>,r,k-s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/special--专题/5-数据结构/zxs主席树/poj2104.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        v.push_back(a[i]);</div><div class="line">    &#125;</div><div class="line">    sort(v.begin(),v.end());</div><div class="line">    v.erase(unique(v.begin(),v.end()),v.end());</div><div class="line">    build(rt[<span class="number">0</span>],<span class="number">1</span>,n);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        update(rt[i],<span class="number">1</span>,n,rt[i<span class="number">-1</span>],getid(a[i]),<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> l,r,k;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</div><div class="line">        <span class="keyword">int</span> ans = v[query(rt[l<span class="number">-1</span>],rt[r],<span class="number">1</span>,n,k)<span class="number">-1</span>];</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="spoj-dquery"><a href="#spoj-dquery" class="headerlink" title="spoj-dquery"></a>spoj-dquery</h4><p>题意：对于[i,j]统计其中不同数字的个数。</p><p>主席树里就是[1,n]不同数字的个数。所以对于每个查询[l,r]，对于第r颗树的从l开始的元素数。</p><p>更新主席树的时候，如果之前出现过这个数就在前面那颗树的位置-1，在现在的位置+1。</p><p>写的时候还是参照了别人的代码，query那一块不是很好理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">100</span>;</div><div class="line"><span class="keyword">int</span> rt[N],ls[N*<span class="number">100</span>],rs[N*<span class="number">100</span>],sum[N*<span class="number">100</span>];</div><div class="line"><span class="keyword">int</span> a[N],b[N],tot,q;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> lower_bound(v.begin(),v.end(),x) - v.begin() + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    o= ++tot,sum[o]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</div><div class="line">    build(ls[o],l,mid);</div><div class="line">    build(rs[o],mid+<span class="number">1</span>,r);</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> last,<span class="keyword">int</span> p,<span class="keyword">int</span> v)</span></span></div><div class="line">&#123;<span class="comment">//p是更新的点，last是上一个点，o是树根(?)</span></div><div class="line">    o= ++tot;</div><div class="line">    ls[o]=ls[last],rs[o]=rs[last];</div><div class="line">    sum[o]=sum[last]+v;</div><div class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(p&lt;=mid) update(ls[o],l,mid,ls[last],p,v);</div><div class="line">    <span class="keyword">else</span> update(rs[o],mid+<span class="number">1</span>,r,rs[last],p,v);</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> vis[<span class="number">1000000</span>+<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(l==r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> sum[c];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</div><div class="line"><span class="comment">//    int s = sum[ls[y]]-sum[ls[x]];</span></div><div class="line">    <span class="keyword">if</span>(pos&lt;=mid)  <span class="keyword">return</span> sum[rs[c]] + query(ls[c],pos,l,mid);</div><div class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> query(rs[c],pos,mid+<span class="number">1</span>,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/special--专题/5-数据结构/zxs主席树/spoj-dquery.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">            v.push_back(a[i]);</div><div class="line">        &#125;</div><div class="line">        sort(v.begin(),v.end());</div><div class="line">        v.erase(unique(v.begin(),v.end()),v.end());</div><div class="line">        build(rt[<span class="number">0</span>],<span class="number">1</span>,n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span>(!vis[getid(a[i])])</div><div class="line">            update(rt[i],<span class="number">1</span>,n,rt[i<span class="number">-1</span>],i,<span class="number">1</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                update(tmp,<span class="number">1</span>,n,rt[i<span class="number">-1</span>],vis[getid(a[i])],<span class="number">-1</span>);</div><div class="line">                update(rt[i],<span class="number">1</span>,n,tmp,i,<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            vis[getid(a[i])] = i;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</div><div class="line">        <span class="keyword">while</span>(q--)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</div><div class="line">            ans = query(rt[r],l,<span class="number">1</span>,n);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rmq系列。有一些之前写的题。多是些半途而废（对说的就是主席树和树状数组）的专题，有时间另专开几个讨论他们好了&lt;/p&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://oodtoodt.github.io/categories/acm/"/>
    
    
      <category term="special" scheme="http://oodtoodt.github.io/tags/special/"/>
    
      <category term="xds" scheme="http://oodtoodt.github.io/tags/xds/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序简单</title>
    <link href="http://oodtoodt.github.io/2018/04/03/%E4%B8%93%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95/"/>
    <id>http://oodtoodt.github.io/2018/04/03/%E4%B8%93%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95/</id>
    <published>2018-04-03T12:21:15.000Z</published>
    <updated>2018-04-03T12:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>拓扑排序。</p><p>不是高科技，不是黑科技，简单的数据结构。</p><a id="more"></a><hr><p>关键问题在于解决有向无环图中，任意有一边u-&gt;v，则u在排序中在v之前。</p><p>可以用栈实现。可以寻找入度为0的点。可以用dfs，bfs实现。总之复杂度o(n+e)。</p><p>先上板子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxx];</div><div class="line"><span class="keyword">int</span> in[maxx];</div><div class="line"><span class="keyword">int</span> ve[maxx];</div><div class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</div><div class="line">    <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span>(in));</div><div class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</div><div class="line"><span class="comment">//    ve.clear();</span></div><div class="line">    <span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="keyword">sizeof</span>(ve));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">tp</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) q.push(i);</div><div class="line">    &#125;</div><div class="line">    k = n;</div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;</div><div class="line">        <span class="keyword">int</span> v = q.top();</div><div class="line">        q.pop();</div><div class="line">        <span class="comment">//ve.push_back(v);</span></div><div class="line">        ve[v] = k--;</div><div class="line"><span class="comment">//        ve[k--] = v;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> t = G[v][i];</div><div class="line">            in[t]--;</div><div class="line">            <span class="keyword">if</span>(!in[t]) q.push(t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>大概就用这个了吧。哦对了多说一句，n大于10000时用上边那个板子，但是如果很小就用邻接矩阵吧，免得。。免得没判重出错。板子上没判重，怕炸时间。</p><p>问题在于拓扑排序也有很多有意思的变化。</p><h4 id="hdu1285、hdu3342、poj-2367"><a href="#hdu1285、hdu3342、poj-2367" class="headerlink" title="hdu1285、hdu3342、poj 2367"></a>hdu1285、hdu3342、poj 2367</h4><p>poj 2367 确定一些人的父子关系，保证输入正确<br>hdu 1285 确定比赛名次，给出队伍之间的胜负，保证输入正确<br>hdu 3342 有些人是别的人的老师，给出关系，问是否有矛盾？<br>纯板子题。判重、是否有拓扑排序是重点。矩阵即可。</p><h4 id="hdu2647"><a href="#hdu2647" class="headerlink" title="hdu2647"></a>hdu2647</h4><p>….题意：我，工厂，发钱。但是工人们都有想法，比如比xxx高一块钱。问如何使得给的钱最少？<br>这是个，逆序拓扑。<br>如果不能理解的话，想象我a&gt;b&gt;c d&gt;b ，则c吃保底，然后b次之，ad最好。而非ad最少，所以答案会有所区别。但是发现取边时会第一个取出ad。这里也不能拓扑后逆序输出，就像刚才那个例子一样，不知道树的深浅，答案是不会正确的。<br>所以反向拓扑。只有反向拓扑还是不够的，需要记录层的值，这里用一个数组表示，在对每个入度为0的点搜索的时候（因为反向，其实是最没要求的底层），出边=max(点+1,边)<br>注意优先队列取值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> a[maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxx];</div><div class="line"><span class="keyword">int</span> in[maxx];</div><div class="line"><span class="keyword">int</span> ve[maxx];</div><div class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();</div><div class="line">    ans = <span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span>(in));</div><div class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</div><div class="line"><span class="comment">//    ve.clear();</span></div><div class="line">    <span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="keyword">sizeof</span>(ve));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">tp</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) &#123;</div><div class="line">            q.push(i);</div><div class="line">            k ++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//    k = n;</span></div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;</div><div class="line">        <span class="keyword">int</span> v = q.top();</div><div class="line">        q.pop();</div><div class="line">        <span class="comment">//ve.push_back(v);</span></div><div class="line"><span class="comment">//        ve[v] = k--;</span></div><div class="line"><span class="comment">//        ans += k++;</span></div><div class="line"><span class="comment">//        ve[k--] = v;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> t = G[v][i];</div><div class="line">            in[t]--;</div><div class="line">            <span class="keyword">if</span>(ve[v] + <span class="number">1</span> &gt; ve[t]) ve[t] = ve[v] + <span class="number">1</span>;<span class="comment">//凡边皆高</span></div><div class="line">            <span class="keyword">if</span>(!in[t]) &#123;</div><div class="line">                q.push(t);</div><div class="line">                k++;</div><div class="line">                ans += ve[t];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/special--专题/5-数据结构/tp拓扑/hdu2647.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</div><div class="line">    &#123;</div><div class="line">        init();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> u,v;</div><div class="line">            <span class="keyword">int</span> visit = <span class="number">0</span>;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[v].size(); j++)&#123;</div><div class="line">                <span class="keyword">if</span>(G[v][j] == u) &#123;</div><div class="line">                    visit = <span class="number">1</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(visit) <span class="keyword">continue</span>;</div><div class="line">            G[v].push_back(u);</div><div class="line">            in[u]++;</div><div class="line">        &#125;</div><div class="line">        tp(n);</div><div class="line"><span class="comment">//        printf("%d\n",k);</span></div><div class="line">        <span class="keyword">if</span>(k == n) &#123;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t = (<span class="keyword">long</span> <span class="keyword">long</span>) ans + <span class="number">1l</span>l * n * <span class="number">888</span>;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,t);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="hdu4857"><a href="#hdu4857" class="headerlink" title="hdu4857"></a>hdu4857</h4><p>题意：排队。你得到消息，有些大人物要排在某人前面。已知1-n是已排好的人物顺序，在得到消息之后的顺序。<br>拓扑的话，如果1要在2之前，那么1-2。如果有这样的数据：2-3,4-1，那么拓扑出来的结果是2341，显然会造成大人物的愤怒，因为编号小店应当尽量靠前<br>所以又要反向拓扑了。反向拓扑先选出编号较大的点，最后逆置。<br>选编号大的点，所以队列直接用优先队列。<br>3-2,1-4,这样取3214，倒过来就是4123了。<br>因为反向取，<code>k=n，ve[k--] = v;</code>把先取出来的扔到后边。另外记得不要写成<code>ve[v] = k--</code>。</p><h4 id="poj3687"><a href="#poj3687" class="headerlink" title="poj3687"></a>poj3687</h4><p>emmm，坑题<br>题意：给n个球，编号为1-n，重量为1-n，编号重量不对应，给一些约束a<b，表示a比b轻。另外尽量让编号小的球轻。输出1-n编号的球的重量。 这是一个从题意开始就在疯狂搞事的题。="" 同样先数据验证：2-3，4-1，拓扑结果2341，好像哪里不对。3<4，1<2，没问题。3-2，4-1呢？3241。4="">2，打住。<br>反向的话呢？2-3，1-4。1234，倒置4321。正确是正确了，但是顺序似乎不如3412好。<br>问题出在球的编号没变，输出的是重量。而非平时拓扑中重新排序。<br>但是球之间仍然是有着拓扑的关系。这里我们需要尽量把小的重量给小的标号。基本上因为尽量这个条件，反向拓扑没的跑了。<br>这里记录数据的时候用的就是<code>ve[v] = k--</code>，体会一下输出重量和顺序的区别。</b，表示a比b轻。另外尽量让编号小的球轻。输出1-n编号的球的重量。></p><h4 id="hdu5222"><a href="#hdu5222" class="headerlink" title="hdu5222"></a>hdu5222</h4><p>是很巧妙的题，没有想到确实是我僵硬了。<br>给许多有向路和无向路，每条路只能走一次，问是否存在环。<br>起初以为bellman的题乱入进来了…想了想那边好像是正环负环…建图的时候发现因为无向路只能走一次，所以不是很懂怎么处理。<br>查了一下发现居然是并查集+拓扑排序。<br>首先缩点。把无向图连接的边用并查集缩点。然后用缩过的点与有向图做拓扑排序。<br>感觉缩点是强连通分量的内容…那么这个题应该强连通也能做。</p><p>另外读取的时候不要中途break。。会wa的。。(つД`)ノ</p><h4 id="poj-1094"><a href="#poj-1094" class="headerlink" title="poj 1094"></a>poj 1094</h4><p>可以说是非常zz的一题了。<br>三点要求，摆在明面上：是否出唯一的拓扑序列，不能确定顺序，第几步出现环。<br>大概难点在是否出现唯一的拓扑序列这里，在队列里检查队列元素个数，大于1则说明有两个点同时入度为0，则不能确定顺序。<br>另外就是恶心的判断咯。<br>不想写，回头贴吧。</p><p>写了写，想用队列元素个数判断的，但是又想对每个读入的关系都新做一次拓扑排序。。。最后发现是元素个数是用来判断唯一的，也就是说不是用来判断顺序的。</p><p>另外的话读题的时候又出了差错。。只会给出固定的一种顺序。即a&lt;b这种形式。写着写着回退到数组形式的tp了，忘了vector版的怎么判重了。。回去想一下。</p><p>输出还wa+pe了好几发。。我tm差一个空格，然后怎么交都是之前的那个答案…看来自带判重。。。(つД`)ノ</p><hr><p>ok全勤了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拓扑排序。&lt;/p&gt;
&lt;p&gt;不是高科技，不是黑科技，简单的数据结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://oodtoodt.github.io/categories/acm/"/>
    
    
      <category term="special" scheme="http://oodtoodt.github.io/tags/special/"/>
    
  </entry>
  
  <entry>
    <title>dp2</title>
    <link href="http://oodtoodt.github.io/2018/03/27/%E4%B8%93%E9%A2%98/dp/dp2/"/>
    <id>http://oodtoodt.github.io/2018/03/27/%E4%B8%93%E9%A2%98/dp/dp2/</id>
    <published>2018-03-27T12:20:35.000Z</published>
    <updated>2018-04-03T12:33:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了教我自己的不会的dp两天里做的…</p><a id="more"></a><p>动态规划是通过<strong>拆分问题，</strong>定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p><h4 id="hdu1024"><a href="#hdu1024" class="headerlink" title="hdu1024"></a>hdu1024</h4><p>报警了啊….输出k个最大连续子序列的和最大的值。</p><p>果然我的dp水平还停留在最大连续子序列的阶段…</p><p>$dp[i][j]$ 前i个数，组成j组的和的最大值<br>决策：第i个数包含在第j个组里，或者自己单独成组。<br>$dp[i][j] = max(dp[i-1][j] + a[i] ,max(dp[0][j-1]～dp[i-1][j-1]) + a[i])$<br>其中$max(dp[0][j-1]～dp[i-1][j-1])$指的是前面i个数放在j-1个组里的最大值。为了使单独成组后和最大。<br>但是n和m都很大。所以还是要化成一维。$dp[i][j] 只与 dp[?][j]和dp[?][j-1]有关$，可以滚动数组。注意到遍历dp[i]时可以记录上面的max值。<br>输出时应为max值，而不是dp[n]。。。照搬题解还做错我也是(T ^ T)</p><p>不大行，基本上是照搬题解。感觉是好题。</p><p>核心代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> maxd = -INF;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        dp[i] = max(dp[i<span class="number">-1</span>]+a[i],maxdp[i<span class="number">-1</span>] + a[i]);</div><div class="line">        maxdp[i<span class="number">-1</span>] = maxd;</div><div class="line">        maxd = max(maxd,dp[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="hdu1029"><a href="#hdu1029" class="headerlink" title="hdu1029"></a>hdu1029</h4><p>给定一串数字，问出现次数大于某个值的数字是什么。<br>不用dp的话map可以水过。<br>dp的话，$dp[i][j]$表示…算了不dp了。</p><h4 id="hdu1069"><a href="#hdu1069" class="headerlink" title="hdu1069"></a>hdu1069</h4><p>我是不是不适合做dp。。<br>典型dp。<br>题意：给出很多数目不限的方块的三维数据，然后问在长宽严格递减的情况下，如何摆放着使得高最大？<br>做法：枚举每一个方块的所有摆放方式，然后排序长度、宽度，对于长度、宽度做关于高度的lis…<br>回想一下正常的lis的话：<br>$𝑑𝑝[𝑘]=max(𝑑𝑝[𝑖]+1, 𝑑𝑝[𝑘]) $<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; cnt; j ++)</div><div class="line"><span class="keyword">if</span>(a[j].x &gt; a[i].x &amp;&amp; a[j].y &gt; a[i].y)</div><div class="line">dp[j] = max(dp[j],dp[i]+ve[j].z);</div></pre></td></tr></table></figure></p><p>dp[i]表示扫到第i个元素最大高度，然后遍历所有元素，对于每个比第i个元素长宽大的位置更新dp为这个地方的dp或者是第i个元素+高。<br>硬要写只能写出这个来…真讲的话没法讲的。</p><h4 id="hdu1074"><a href="#hdu1074" class="headerlink" title="hdu1074"></a>hdu1074</h4><p>题意：给出一些任务，给出任务的deadline和要做的话需要的天数，问如何安排使得所有任务超过deadline的天数总和最少。<br>想了半天不会写方程。<br>看了题解，是状压dp。</p><blockquote><p>对于完成123 和132来说，消耗的天数一定相同，只是完成顺序不同而扣的分不同，所以可以将完成x相同任务的状态压缩成一种状态并记录扣的最少分即可。<br>即状态压缩dp。<br>对于到达状态i，从何种状态到达i呢？只需要枚举所有的任务<br>对于k，i中若k已完成，那么i就是由未完成k的状态到达完成了k的状态。</p></blockquote><p>看到这一切就开朗起来了。所以就直接从小到大枚举所有状态，然后枚举到达状态的所有可能的状态，取超过deadline的天数总和的最小值作为dp值。</p><p>写一下代码。</p><p>记录下完成i的时间，另外注意每次更新dp、时间、还要更新输出顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">20</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> dead[maxx];</div><div class="line"><span class="keyword">int</span> cost[maxx];</div><div class="line"><span class="built_in">string</span> s[maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">100000</span>];</div><div class="line"><span class="keyword">int</span> t[<span class="number">100000</span>];</div><div class="line"><span class="keyword">int</span> pre[<span class="number">100000</span>];</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/special--专题/8-dp/简单(easy?)dp/hdu1074.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span>(T--)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;s[i]&gt;&gt;dead[i]&gt;&gt;cost[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span> &lt;&lt; n;</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="keyword">sizeof</span>(t));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</div><div class="line">        &#123;</div><div class="line">            dp[i] = INF;</div><div class="line">            <span class="keyword">int</span> pos = i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> temp = (<span class="number">1</span>&lt;&lt;j);</div><div class="line">                <span class="keyword">if</span>(!(i &amp; temp) || temp &gt; i)<span class="keyword">continue</span>;</div><div class="line">                temp = i-temp;</div><div class="line">                <span class="keyword">int</span> te = t[temp] + cost[j] - dead[j];<span class="comment">//j扣分数</span></div><div class="line">                te = max(te,<span class="number">0</span>);</div><div class="line">                <span class="keyword">if</span>(dp[temp] + te &lt; dp[i])</div><div class="line">                &#123;</div><div class="line">                    t[i] = t[temp] + cost[j];</div><div class="line">                    dp[i] = dp[temp] + te;</div><div class="line">                    pre[i] = j;</div><div class="line"><span class="comment">//                    printf("dp[%d](%d) = dp[%d](%d) + %d\n",i,dp[i],temp,dp[temp],te);</span></div><div class="line"><span class="comment">//                    printf("pre[%d] = %d\n",i,j);</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(dp[temp] + te == dp[i])&#123;</div><div class="line">                    <span class="keyword">if</span>(s[j] &gt; s[pre[i]]) &#123;</div><div class="line">                        pre[i] = j;</div><div class="line"><span class="comment">//                        cout&lt;&lt;s[j]&lt;&lt;s[pre[i]]&lt;&lt;endl;</span></div><div class="line"><span class="comment">//                        printf("pre[%d] = %d\n",i,j);</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cnt--;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[cnt]);</div><div class="line">        v.clear();</div><div class="line">        <span class="keyword">while</span>(cnt)</div><div class="line">        &#123;</div><div class="line">            v.push_back(s[pre[cnt]]);</div><div class="line">            cnt = cnt - (<span class="number">1</span>&lt;&lt;pre[cnt]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = v.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;v[i]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="hdu-1087"><a href="#hdu-1087" class="headerlink" title="hdu 1087"></a>hdu 1087</h4><p>题意就是求子序列递增且和最大的值。</p><p>类似lis，其中dp的含义改为和的最大值。</p><h4 id="hdu1257"><a href="#hdu1257" class="headerlink" title="hdu1257"></a>hdu1257</h4><p>题意求多少个递减序列能遍历所有的元素。可以贪心更新每个递减序列的最小值…更好的做法是求一个lis就行了。另外，最长上升子序列的长度就是不下降子序列的个数…</p><h4 id="poj1458"><a href="#poj1458" class="headerlink" title="poj1458"></a>poj1458</h4><p>lcs裸题…lcs重点在于用二维表示i和j。</p><h4 id="hdu1114"><a href="#hdu1114" class="headerlink" title="hdu1114"></a>hdu1114</h4><p>题意：给出一个存钱罐的本体重和存满重，给出不同钱币样式的重量和价值，问使得存钱罐存满（一定满）的钱价值最小是多少。</p><p>完全背包，求使背包满的最小值。max改成min。</p><h4 id="hdu1176"><a href="#hdu1176" class="headerlink" title="hdu1176"></a>hdu1176</h4><p>题意：天上掉锅。要尽量接住更多的锅，但是你很笨，每秒只能移动一个距离，给出锅下的坐标和时间，坐标一维，只有0-10这11个点。锅数100000。</p><p>看到n100000我以为凉了的，想到只有0-10，又想了下状态压缩，我丢人了。</p><p>$dp[i][j]$表示i时间在j点接住的锅数。用$a[i][j]$记录i时间j掉的锅数(很重要）。枚举所有时间i，所有点j，有</p><p>$dp[i][j] = max(dp[i-1][j],dp[i-1][j+1],dp[i-1][j-1]) + a[i][j];$</p><h4 id="hdu1260"><a href="#hdu1260" class="headerlink" title="hdu1260"></a>hdu1260</h4><p>简单dp啦。。问两个人付和一个人付的所有情况里付钱最少的情况<br>$        dp[i] = min(dp[i-2]+b[i-1],dp[i-1]+a[i]);$</p><h4 id="hdu1160"><a href="#hdu1160" class="headerlink" title="hdu1160"></a>hdu1160</h4><p>给出每个老鼠的w和s，求一个老鼠序列s.t. w严格递增，s严格递减<br>类似1069，只是变成+1</p><h4 id="poj1015"><a href="#poj1015" class="headerlink" title="poj1015"></a>poj1015</h4><p>做这个题把自己做进去了….<br>题意：给出n人的d和p值，求m个人的d值和sumd，p值和sump，abs(sumd-sump)最小的情况，如果有相同的输出sumd+sump最大的情况。d和p不超过20。n&lt;200,m&lt;20。</p><p>我一开始当成和上个题上不多的dp了。。写完了样例也过了，却一直wa。找了点数据，又回头看，自己的三重循环并不是对的——对于m个人的限制来说，并不是说更新值就一定是最优的，可能更到sumd远大于sump然后最后来一个反着差的数据使得其变成最优，而不是说每次最优结果一定最优。</p><p>明白了这一点后结合d和p不超过20就能发现这其实是背包吧…<br>讲道理为一开始都没注意到题目里藏了个条件没用orz。</p><p>$dp[i][j]$表示从n个人中选出差为j的和最大值。<br>发现j并不好求，那么就去掉绝对值，只求d-p。然后先行+400(20 * 20)使得不会出现负数并且能够最后求得正确的值。<br>说一下为什么要选这样的j。因为每次更新的时候对于每个确定的j，其前面的状态是确定的。即可以这样推上来最优。<br>贴代码。（好像还没写好。。</p><h4 id="poj1221"><a href="#poj1221" class="headerlink" title="poj1221"></a>poj1221</h4><p>拆成对称的且先递增后递减的整数拆分。<br>整数拆分 $dp[i][j]$是数i最大不超过j的划分数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i &lt; j  dp[i][j] = dp[i][i]</div><div class="line">i == j dp[i][j] = dp[i][j<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">i &gt; j  dp[i][j] = dp[i][j<span class="number">-1</span>]+dp[i-j][j];</div></pre></td></tr></table></figure></p><p>这道题的话有两种情况——首先这样一个划分必定是abcba或者abba这两种情况，而后者只会出现在偶数中，而前面那个则要求n-c为偶数，这时候只需要看左边区间的划分就能得到所有情况，划分数就是$dp[(n-c)/2][c]$，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了教我自己的不会的dp两天里做的…&lt;/p&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://oodtoodt.github.io/categories/acm/"/>
    
    
      <category term="special" scheme="http://oodtoodt.github.io/tags/special/"/>
    
  </entry>
  
  <entry>
    <title>并查集一套1</title>
    <link href="http://oodtoodt.github.io/2018/03/09/%E4%B8%93%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%80%E5%A5%971/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%80%E5%A5%971/"/>
    <id>http://oodtoodt.github.io/2018/03/09/%E4%B8%93%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%80%E5%A5%971/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%80%E5%A5%971/</id>
    <published>2018-03-09T02:55:33.000Z</published>
    <updated>2018-03-20T09:35:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>并查集…</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>kuangbin的板子里没并查集。。。我用白书的板子了\没有路径压缩。。我自己加下试试\带了，是递归版的。。放在return里了。</p><h4 id="原板子"><a href="#原板子" class="headerlink" title="原板子"></a>原板子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> par[maxx];</div><div class="line"><span class="keyword">int</span> num[maxx];<span class="comment">//添加了统计集合中数字的功能</span></div><div class="line"><span class="keyword">int</span> rak[maxx];<span class="comment">//本为rank，我的编译器不支持。。这里记录的是树的高度</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        par[i] = i;</div><div class="line">        rak[i] = <span class="number">0</span>;</div><div class="line">        num[i] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(par[x] == x)&#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> par[x] = find(par[x]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">    x = find(x);</div><div class="line">    y = find(y);</div><div class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">if</span>(rak[x] &lt; rak[y])&#123;<span class="comment">//这个地方我不会调整，所以干脆换了个板子。。</span></div><div class="line">        par[x] = y;</div><div class="line">        num[y] += num[x];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        par[y] = x;</div><div class="line">        num[x] += num[y];</div><div class="line">        <span class="keyword">if</span>(rak[x] == rak[y]) rak[x]++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> find(x) == find(y);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> par[maxx];</div><div class="line"><span class="keyword">int</span> rak[maxx];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        par[i] = i;</div><div class="line">        rak[i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(par[x] == x)&#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">int</span> t = par[x];</div><div class="line">        par[x] = find(par[x]);</div><div class="line"><span class="comment">//        rak[x] = (rak[t] + rak[x] );</span></div><div class="line">        <span class="keyword">return</span> par[x];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> fx,fy;</div><div class="line">    fx = find(x);</div><div class="line">    fy = find(y);</div><div class="line">    <span class="keyword">if</span>(fx == fy) &#123;</div><div class="line"><span class="comment">//        if(rak[x] - rak[y] != c) ans++;</span></div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        par[fx] = fy;</div><div class="line"><span class="comment">//        rak[fx] = -rak[x] + rak[y] + c;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="poj-1611"><a href="#poj-1611" class="headerlink" title="poj 1611"></a>poj 1611</h4><p>题意：给出一些群体的所有人的编号，已知0号可能患传染病，问有多少人可能患传染病？<br>模版题，教会如何使用并查集。<br>嗯，如果是做并查集之前，我会感觉无从下手：1和2是一个集合的根1，2和3是一个集合的根2吗？那怎么办呢？<br>现在知道了并查集原来能直接日进去…</p><h4 id="poj2236"><a href="#poj2236" class="headerlink" title="poj2236"></a>poj2236</h4><p>地震中一些电脑坏了。要修电脑的同时检查她们是否连接，一定距离内的电脑可以连接。给出电脑坐标，给出修或是检查的指令。<br>我用的是给出修指令的时候遍历以前修过的电脑检查是否在距离内扔进并查集…虽然n在1000理论上o(n^2)问题不大不过….不知道还有没有更快的方法，毕竟用了2000ms…</p><h4 id="hdu1213"><a href="#hdu1213" class="headerlink" title="hdu1213"></a>hdu1213</h4><p>一些人只跟自己的朋友吃饭。已知朋友是一个可传递的属性，问应该安排几桌<br>呃。。<code>find(x)==x ans++</code>即可</p><h4 id="hdu3038"><a href="#hdu3038" class="headerlink" title="hdu3038"></a>hdu3038</h4><p>感觉似曾相识的题…经典问题<br>好难！<br>题意：给出区间[1,n],下面有m组数据，l r v区间[l,r]之和为v,每输入一组数据，判断此组条件是否与前面冲突 ,最后输出与前面冲突的数据的个数.</p><p>带权并查集，这里复制一下别人的关于向量偏移的讲解</p><p>「很好用。」</p><blockquote><p>这题让我学到了很多，特别是关于向量偏移，可以直接找到根节点与子节点的关系</p><p>这题我们利用一个sum[]数组保存从某点到其祖先节点距离。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAY0AAAFMCAIAAAC4cXeXAAAPi0lEQVR4nO3d23nyuBqAUQqZy6mCgqiHamiGGqYG5sIJ8UE+G/xJWuv5bwYMsSX5jSHszeUFENvl7B0AmKFTQHQ6BUSnU0B0OgVEp1NAdDoFRKdTQHQ6BUSnU0B0OgVEp1NAdDoFRKdTQHQ6BUSnU0B0OgVEp1NAdDoFRKdTQHQ6BUSnU0B0OgVEp1NAdDoFRKdTQHSZdOpxu1xuj/5N1/szse3zfn3f8bhdEnrPNHiu5/063CbxY+Y3Ag6QR6eGTZqoRK9TSx64tVMJ6XYCO4Tv1CAH1/szdZ3014eFnUpfaiUlm/XV66nE9STUI4tO/Z2hTXcGZ+1PjvrpuT1Ked2nU1QtVKfa106/Z+WwU9fr5HtVz/v1svZ13/rdm7nwetwul+v90Tygs2vjtRy5t/dTf58sNVZQqECdet5vnRO6OSNT11ODh7Zuftyu1+v77J3s1JJXfu0ETCeuc+/PU7e3ftw6N7QOcf7ewfVUeqygUIE61fE+MdPvT/WS8c7R83693Zv3p5736/V+X/a6byRBj9uuTvUrlSjmzzbT975mXvd5UUjpYnWqe4Xz7lTyeqp1bv9u07yDnngfvf/+07N/9ZFMUP/G1a/7uu94DX7Ae6Ppe3//Y/hadzK9UI44nWrOu9/zrXM9Nfa673ej320et79adbdvlSx5Wi/q1MqD+WCnRsYKChWmU90z++/MXfL+VHeb9OcSxgqVeobEE/082fsTDX9vcbWu77pvN/Ufe9zrvrGxgkKF6tTv2fbTlDWdat2a7NTj1nxIYfyzoclrrPRb2d334tt/gWtf4nR3tDmmbmv6f9Qbu7f/fGNjBYUK06n22z/tj0il30cfPHC8U51HPW7JZ/hrTOfHdZ+09+e45r9GPgWRuEBq703yOJbd+/dX0OFYQaECdSpt7Hpq/KxudSp5BqdeJ829FdW/jvt74k6o+q8UgSOE7xRQPZ0CotMpIDqdAqLTKSA6nQKi0ykgOp0CotMpIDqdAqLTKSA6nQKi0ykgukCdSv9/ofS38K3If+ZHDIqQU6d8K3KPTlGJTDrlW5Ffr+H1pE5RiYw65VuRdYpKxetU8ot+fSty6luRp0YMChKsU4PzufcNfe8tfSvyzIhBQaJ1qlOA7rdjdfhW5JkRg4IE61TvNO18E6dvRV7w/pS3rChR7p16VfytyDpFLYJ1avAHvNb31flW5PnXfTJFkaJ1qndWJr6B+OVbkTv3j4xYbhSWCcE69f4rfu+qx7cid+9tfy4hPWK50SkmBOrUFN+KXBqfWWWFTDpFaXSKFXSKRXy2nhPpFIv4bD0n0ikW8dl6TqRTLOIzq5xIp1hEpziRTrGIz9ZzIp1iEZ+t50Q6xSI+W8+JdAqITqeA6HSKP+2PiR/yPEftGJWzkvhxmbT5eT63w9TDMuLHdKeW1Gfbo2CWpcOPVZ0a1mfzw1WMWRYHf/a35nBnDwkhWAeknR2oP2ePBOezCFhEpziRRcAW23KjU2xjEbDah3IjUoyxDlhnW6REhz0sHVbYEymdYjNLh0WWl0iqOJx1w7zlVZrYWKfYzLphxnRx1nZKqtjAomHKbGtmO5W8BVaxaEhbeDW0oVNSxVpWDAmbI7XqRljIiqFvYaSGWy6/UapYxXLhz1ihxrKy6tJJp9jMcuHHqkIlHzJxY/L5P3s8FMRa4fXaFKnhoyZunL0LJlgrHBmpiduTP+gjx0NxLJSqbStU8rGzty+5F5IslHrtidTw4bO3j/3Qw46HclklldoZqeEzzN6+fAPosUqqM1aotck4qlNSxSxLpC6HFGr4PAvvWrUNvFkiFTkqUsOnWnjXxJ5sOR6qYX1UYaxQmwMx/SRLnlynWM76KN+xhUo+5yF7tWd/KJvFUbhPRKr3zEft2/5dolQWR8k+F6lDhN0xorEyyhS8UG/Bd48grIwC5RKpl0sqlrEsSpNRpBq57CcnsizKMVao4Cd/XnvLKayJQuRYqLcc95lvsiZKkHWkXi6pmGNBZC/3SDWy3nk+zYLIWBmFapRxFHyI1ZCrkiLVKOZAOJzVkKXyIvVyScU4SyEzY4Uq46wu74g4hKWQk4IL1Sj40NjDOshG8ZFqlH10bGMd5KGSSL1cUpFiEURXT6He6jlSFrIIQqswUi+XVAxYAXHVGalGhYfMBCsgopoL1aj52Bky/eGIVKPyw6fN9MciUm8GgTdzH8VYoWo+P40DDXMfgkIlGRAaJv7tcbtcbo8TfrBITTAmvHSq5ZxOidQ0I8Mr6049bpfL9f64Xy+Xy+V6fza3Ppv//tHvzsi93ZvfT9a++fiCKdRCxoeMZ/1xGwTkcevc8LxfWwWbuXdwPfW83zrxa226n0gtZ5TIeMp72fm9wOrE5Hm//m4zfe9r5nXfoS8KRWotA1W5jKe8H55udfobTd/7+x+9DX4u2Y576TdWKOfeNMNVuYzn+8Odahr1e8MR11MKtYdBq1nG8z14IXfo677u5snKrSJSOxm6mmU82cPwNH+f67am/0e9sXv7z9e+9+fvfts7JVKHMHrVyniyExdIr95bSoO7l93b3PH3qYTr/bn1dZ9CHcgwVstMf5BIHc5I1slMf4pIfYLxrJNpPt5YoZxUhzCkFTLNB1OoTzO2FTLHx5i4hnIiHc7w1sYcH0Ckvswg18YEH0Chvs9QV8UE7zUbKafTJ/itUBWzu9H0a733abNkG7YxmPUwu+vM5ql92izf2Gm2gTGsh6mdtyo3Rzn7oPNg0Cphakedkqeks0ciLmNVCfPa9/0MrXL28IRjfGpgXjtOSc9aZw9SLManBia1Y1Ujhnclt1/yhLM/d2wfeLmkqoBJ7ViVhiXFmX7asefXqVUMUfHMaN/C5T52boydMLOpmvhxzsBZOlU2M7rR8h6N3b62VkwwjGUznRtNnBXLE6ZWBzKABTOdW0xnZfldanUgo1cwc7nF9PmwqlPJG51v2xi3UpnLLWbPh+WpGrtdrTYwaKUykastORmWd2r23k+eeK2vCRt+w1iedKpIJnK1JWfC9DZrM/eRc+9xu3S/8fm+82vpY/hw2TmHWVxtQ6cuay6pJjY77vTb/0X0celUecziOsvPgektl3fnI7UqOVMuqQpkCtf5fqeSG+89D4vu1MslVXFM4Qo747Ln2ZLb7zgbH7dy3jpPOCDlRGL+Vli79Ge333AuHVWr5/16aV9SPW6FXV7pVEnM3wqf7tTy0+mYWrU+llDei8DNY0tAJm+pDet+yfZ7zqVjalUuo1EMk7fUtkU/u/3+c0mtxhiKYpi5pT634g95TqlKMg5lMHOL5HLmq1WPQSiDaVskr7WuVm2VH34ZTNsi2a316VRlcQhHqfnYi2HO5uW70NWqUedRl8Sczct9latVhYdcGBM2r4wlXnmtqjrY8piwGYWt72prVc+RFslszShycddZqxqOsVRma0rZJ3BtqarhGEtlqqbUsKyrqlXZR1cwUzWlnmVdSa0KPrSymadRta3p6VQVc/hFHlTxzNOoOhd08bUq74hqYJJG1byay65VScdSCZOUVtiZuU2ptSrmQOphhtKs47cia1XAIVTFDKVZxz2F1Sr3/a+N6UmwiMcUnKqzd4cppifBCp5WRq3y3fMKmZsEy3eJAmqV4z7Xydz0WbvLTacq/uhlt8PVMjF9Fu5aWdcqo12tmYnpyOscCyXTWuWyn5UzKx2W7E451ir+HmJWOizZQ+RVq+C7x0un2qzXY2VUq7A7RsOU/LFYPyGLVIXdMRrm44+V+jnxaxVwl3gzHz9injyFiVyraPtDm8n4YY1+x3Sqzh35OHtCj8n4YY1+U8xaBdkNhszE62WBniRgrU7fAZLMxOtldZ4qVK0itJIh0/B66VQAcWplMQRkGvwKDSRCrayHgMyB35/hREvVF34i08yBRRnUibVySRVN7RNgOQZ3Vq0sjFBqnwDLMb7pVH1o1lxShVL16FuLGfl+rayNOKoefQsxO9+slV9jcVQ99FZhpr5WKyskiHqH3m/L3H2hVhZJEPWOu/VXhk/XyjqJoN5xt/5K8rlUuaSKoNJBt/iK9KFaWSqnq3TQrbyCHV4rv9VOV+mIW3Zlm07Vhhm3YM5V44j79ViJA2tlzZyrxuG24KpyVK0smxPVONwWXIX218ol1YmqG2tLrWY7a2XxnKW6sbbU2Fwrl1RnqWugrTPeDknVN3e4ZnUNtEVGz9pa+VV3irpG2QojaVWtrKLvq2iU/SYk6b9//v3vn3+nU9VeLRbS91U0xNYWQ02k3v8W1spa+rKKhtjaYqjXqSW1ermk+rpaxtfCIinZqelaNQ+0nL6plvG1qhgzkapkrZpH+c33TbUMriXFtIW1aj/EovqaKgbXrz4Wmq5V8++9sXX1NVWMrMXEKktq1QTL0vqOKkbWYmKbJbWyur6g/GF1cc5Oq2p19s6WqfxhFSkOsbxWZ+9pgcofU51i2sJ3oxb+s8Y+ofAxFakKHdudDZ2y0g5X+IDqVBnOTY9Ona7kAfUOelin1+SjkbLSDlfygIrU15weiK/9Sx6+lfZpJY+p1bPH6UU4sTurWGZfUOywetHXc3oRMkrPcpbZdxQ7rDWsntOLUF53VhlGqtSVdrpihzXH1XN6ESrvznLJQuWyzHJU5sgGWUCnF0F6PkGkvq/Mwf3cAjq9CLpzLpE6RZnju3wNnV4E6cmISJ2lwCHuraHTA6E7ZdhQqMftcrnen9/Zv6IV3qnTa6I7Zdh2GaVTR9Ep6WHKntd6OnWUAjv1aq0t3WGPnW9I6dRRyuxUm+6wzc5Ivd6det6v7wffHp/b4YKV3ynYYH+kXk2nLq1Lquf96gJrE52ChJ2Fajxu/Suo5/3qmmoDnYKE/ZF6Jd+f8pbVJjoFaTsj9dKp4+gUfMrwdZ9MbaNT8Ck/76O/SzXsFsvoFHxKc/X08LGE3XLplI+gQL3y6NTzfvMRFKhWHp3qeNxcUkFVsunUz1uSXvpBfbLoVNOo3za5noLK5NCp7mdO/C8PoDa5dOq3TD9/99MpqEgOnWp/KuF6f3rdB5XJo1NAzXQKiE6ngOh0CohOp4DodAqITqeA6HQKiE6ngOh0CohOp4DodAqITqeA6HQKiE6ngOh0CohOp4DodAqITqeA6HQKiE6ngOh0CohOp4DodAqITqeA6HQKiE6ngOh0CohOp4DodAqITqeA6HQKiE6ngOh0CohOp4DodAqITqeA6HQKiE6ngOh0CohOp4DodAqITqeA6HQKiE6ngOh0CohOp4DodAqITqeA6HQKiE6ngOh0CohOp4DodAqITqeA6HQKiE6ngOh0CohOp4Do/gcBSYLaE1UYqwAAAABJRU5ErkJggg==" alt=""><br>1.从上图我们可以看出，当roota!=rootb时 如果将roota并入rootb，那么是不是 roota-&gt;rootb = b-&gt;rootb - b-&gt;roota</p><p>然后我们可以知道 b-&gt;roota = a-&gt;roota - a-&gt;b</p><p>所以最后可以推出 roota -&gt;rootb = b-&gt;rootb + a-&gt;b - a-&gt;roota</p><p>而roota的根节点是rootb,所以 roota-&gt;rootb = sum[roota]</p><p>然后依次推出得到 sum[roota] = -sum[a]+sum[b]+v （这里的a要说明一下由于是区间 [a,b] ，[a,b] = [root,b]-[root,a-1],所以a要减一）</p><p>kuangbin：对于A~B之间的和是S，其实可以理解成B比A-1大S；</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAaAAAAFiCAIAAAA/dJuxAAAK9ElEQVR4nO3c0XkbtxaFURaSx1ShPtyC6lE1akY1pAbmQZRMieRwOAQGwMZaHx9uLNshcQ5+0ZZyD0eAUIfWTwCgFoEDYgkcEEvggFgCB8QSOCCWwAGxBA6IJXBALIEDYgkcEEvggFgCB8QSOCCWwAGxBA6IJXBALIEDYgkcEEvggFgCB8QSOCCWwAGxBA6IJXBALIEDYgkcEEvggFgCB8QSOCCWwAGxBA6IJXBALIEDYgkcEEvggFgCB8QSOCCWwAGxBA6IJXBALIEDYgkcEEvggFgCB8QSOCCWwAGxBA6IJXBALIEDYgkcEEvggFgCB8QSOCp5fz0cXt9bPwvmJnBUInC0J3CcvL8eDi9v728vh8Ph8PL28fmjH5//fPI7WDc++vOH//5msDOB4+T99aJh768/fuDj7eW8Vssf9Q6ODggcJ7969fWW7sebr4+3l6+fs/zRo8DRA4Hj5Hexfubq909a/ujXPwgcbQkcJwJHHoHj5OLPnP6IyvAEjpPLYn1+MfRvpH7+Ld3yR68WEHYmcJxcD9Lpa6s3vt9j3UdljlYEDoglcEAsgQNiCRwQS+CAWAIHxBI4IJbAUczhQutnxOysIGVc1k3maM7ysd15whYCJ3O0Yu3Y6G7RZI7mLBxbbKubzLEzq8bDnqybzLEbS8ZjStVN5tiB9eIBxeumcVRlt1irUt1kjnpsFasUrJjMsRv7xH3F+7Xm94Hn2STueChkt378arxkjtrsEEserdjCh26VS+aox/Zw00Julnu0oVkaRw1Wh+u21e1q4K7+kvX/UoFjM6vDFcuVuRu4y59z9Vet/7fXfr2ksjr89kzdigTu1+9Q75USz/bw23KJnsnZo42DJ9kwfltft4XAPfSDUIkN44pbAbqVp82B0ziqsl6stdCmh1qmcezGbrHWcpXWv4m7+1tBKXaLVe6+7XomcBpHJRaLVe72aE3gNI6d2SruWxOjlSF76PeEJ9kq7ltZoqs/YeHXahy1WSnueD5D69/3aRxl2SfuqBoggaMq+8SSHQKkcdRjmbhpt/QIHJVYJm5qFTiNoxSbxHU7R0fjqMEacZ3AEcAacUWT3GgcxdkhrmgVGo2jLAvEbw0rI3CUZYH4rW1iNI6CbA8/9NCX5k+AGLaHH3qISw+RJYPV4a9+ytLPM2Fo9oa/+mmKwFGEveGkt6b09nwYkaXhpMOaaBxPsjEcj72mpM9nxUBsDMdjl2/fPmkcz7Au9B6Rnp8bnbMu9F6QzvtLz+zK7IbIxxBPkg5ZlKmNEo5Rnie9sShTGygcAz1V+mFL5jVcMoZ7wjRnReY1XC+Ge8I0Z0UmNWgsBn3atGI/JjVuJsZ95uzPfsxo6PdBQz95dmY5ZjR6IDSOlWzGdALqEPAS2IfNmE5GGjSONazFXJK6kPRaqMROzCWpCALHXXZiInlFyHtFlGUhJhLZgsgXRSkWYhapb3ZSXxdF2IZZBFdA47jFKkwhOwHZr45nWIV8M9z/GV4jG9iDfJNc/kleJg+xBOHmufbzvFLWswThprr2U71Y1rABySa88BO+ZBYYf7IJb/uEL5kFxh9r2qs+7QvnktnHmvmSz/zaOWf2mSZ/FzP5y+ebwWdyvTWOo8BFcrePDoHj8ShwkVzsTxqHkadxq885jcmZdxr3+ZzATc68o7jPl5zJzAw7ipt8lWOZlmHn8FblFiczLZPO4Q4v0Lg5GXMIF3iZ85mTMSdwe9dwShMy4wSu7koOajYGPDyXdj1nNRsDHp5L+xDHNRXTHZvruoETm4fpjs1d3cBnhXkY7cBc1M0c3STMdWCu6GYCNwlzHZUr+iQHOANDHZXL+TyNi2eiQ3Izi3CM8Ux0SK5lKRqXzTjH406W5TCDGed4XMiyfMIIZpaDcRtrcKqpDHIw7mENApfKIEfiHtbjbCOZ4jDcwNqccB4jHIbrV5sTzmOEY3D39uGcw5jfGFy83TjnJOY3AHXbk9NOYngDcOV25sBjmFzvXLb9OfMYJtc7N60JjctgbF1zzRpy+AHMrGsuWEMCF8DM+uWCNWcEozOwfrlaPdC4oZlWp9yrThjE0EyrUy5VPzRuXEbVIzeqN8YxKKPqkevUG59yBmVO3XGX+mQuIzKk7rhFfRK4ERlSX9yinpnOcEyoI+5P/8xoLMbTEZenf2Y0FuPphZszCpMaiNn0wrUZiEmNwmy6oG5jMa9RGEwX3JbhaNwQTKU9V2VEpjYEU2nPPRmUxvXPSBpzSYZmfJ0zj8Zcj6EJXOfMoyXXI4Ah9swwWnIxMphjtwyjGZ/5Yxhlt0yiGVciicb1yRjacB/CGGifjKENlyGPxnXIDBpwE1KZbG8MoAF3IJXA9cYA9uYOZDPfrjj9Xdn+GRhxP5z+rgRuBqbcD0e/H3s/D7PuhHPfj6Wfh1l3wrnvxMbPxsR74NB3YtcnpHHNOfE9WPQ5mXtzTnwPtnxaGteW467Oik/O9Bty3NXZ78n5DNeQs67LcnO0Bu046LqsNUeBa8dBV2St+WYZmnDKFVlozmnc/hxxLbaZX6zE/hxxLVaZSxq3M+dbhT3mFouxJ+dbnrqxwHrsyeGWZ4NZZkN242QLs7usYUn24WQLEzjWsCf7cKwl2VrWsy07cKYlWVnWsy07cKbF2FceZWdqc6DF2FQ20LiqnGYZ1pRtbE5VTrMMO8pmGlePoyzAgvIk+1OJoyzAdvIknyMrcY7PspoUYZFqcIjPspQUIXA1OMSnWEoKsk7FOcGnWEfK0riyHN92dpHiLFVZjm87i8hK//3z7+djzU/WuIKc3Ua2kJW+67Y+c1arFGe3hbqx3mXg7pbOgpXi4Lawf6y3ELiFzNmxIpzaw2wej7rbuMvMWbMinNrDbB7bPJo5m/Y8R/YYO8eT1mTuu3T27UnO6zG2jVLWZE7gnuS8HmDbKG5D5lo/5ZE4rAfYMyp5qHGtn+xIHNZa5xu28q9RPDxqPFpfhZEI3Frq5tHPo/VtGIbArSVwHjs//vx0/qHWt2EYAvcAgfPY8/Hnz5/v3RO4bQRui+ar7zHD41bgGm7+cAQOGlsZuIbPcFwCB22seQd3rvXzHZLAwa4e+lNq6yc7PIGD6ha+HqprVQkcVLfw9VBdq0rgoLrlwDV8YvEEDqq7GriGz2ceAgfV+XpoK8MF7uPt5fs/mnp9b/1sgJ4NFriPt9e3j6//+XI4vHz9E8CFwQL3w/urN3HAgvEC9/56/v/MJnDATWMF7jNuX1HzDg5YNFTg3l/P/9bt4+1F4ODnteCH4QL3lbTTV1MFjtkJ3IKhAnf+TSIvbx/+iAoCt2iwwAG/CNwCgYOxnQLnW+CvETgY2+kbp158C/wVAgdjO//a2yffYPBN4GBsV/4Ozl/LfRE4GJvALRA4GNvlH1H17ZvAwdhOX2T4Ttxl8CYmcDC2z/dr775L5BqBA2IJHBBL4IBYAgfEEjgglsABsQQOiCVwQCyBA2IJHBBL4IBYAgfEEjgglsABsQQOiCVwQCyBA2IJHBBL4IBYAgfEEjgglsABsQQOiCVwQCyBA2IJHBBL4IBYAgfEEjgglsABsQQOiCVwQCyBA2IJHBBL4IBYAgfEEjgglsABsQQOiCVwQCyBA2IJHBBL4IBYAgfEEjgglsABsQQOiCVwQCyBA2IJHBBL4IBYAgfEEjgglsABsQQOiCVwQCyBA2IJHBBL4IBYAgfEEjgglsABsQQOiCVwQCyBA2IJHBBL4IBYAgfEEjgglsABsf4HL+C5DbATDiUAAAAASUVORK5CYII=" alt=""></p><p>2.如果roota==rootb 是不是 a和b的根节点已经相同了？所以我们只要验证 a-&gt;b是否与题中的长度一致了。</p><p>所以 a-&gt;b = a-&gt;root - b-&gt;root</p><p>然后得到表达式 v = sum[a]-sum[b] (一定要记住这里的sum都是相对于根节点的，sum的更新在路径压缩的时候更新了)</p><p>这样说是不是懂了向量偏移的思想呢？？</p></blockquote><p>然后今天发现还是wa了=-=<br>不能理解为什么要在find里面增加对sum的改变，这样的话只能做一次find我倒是能理解。<br>hdu炸了。。<br>吐槽下</p><blockquote><p>狗屎hdu，要多组数据直说好吗？劳资辛辛苦苦做了题wa了对着题解一点一点改把程序改的不成样子最后告诉劳资多组数据问题？？？我可qnm的吧</p></blockquote><h4 id="poj1182"><a href="#poj1182" class="headerlink" title="poj1182"></a>poj1182</h4><p>食物链啊。<br>想当初在科协组里做了一次看题解云里雾里，后来备赛看了一次还是有点僵硬害怕，又要做这个题了吗。<br>经典啊。</p><p>看了会带权并查集，改下板子好了。<br>忽然就明白为什么在find里增加对rak的改变了，是因为在solve里其实改变的只是根部的rak值（rak是权，就比如食物链那种关系），新并入的元素并没有之间的关系，也没有与上级的关系，只有一个根部的值，所以每次寻根的时候都调整一下之间的关系…但是问题又来了，只能修改一次与根部的关系吧？多次的话是会出错的吧？嘛算了…先按下。做完食物链之后发现可以不止一次的修改，且不会出错。<br>甚至说，「当前的话表示X吃X，就是假话。 」这句话我没有判断，也就是说并查集里有find(x),find(x)这种疯狂叠加rak的操作都没问题…..</p><h4 id="poj-1417"><a href="#poj-1417" class="headerlink" title="poj 1417"></a>poj 1417</h4><p>岛上有一群天使/恶魔，天使说真话，恶魔说假话，你只询问他们其他某人是什么东西，并知道天使的数量和恶魔的数量，问多少人是天使？<br>这可能是第一道长的不那么像并查集的题了（不因为我之前判断并查集是——一堆话里把前面所有的视为对的，出现错误的无视掉这种套路的，其实有一些问题，比如如果问如何判断使得出现的错误数最少，就迷了），但是应该可以很key的把握到前提知道了天使和恶魔的数量是这种区别的原因。<br>嗯，在我不知道带权并查集的时候感觉可以枚举，但是隐约哪里不对。<br>知道了之后发现是%2权并查集，草草写完后发现有人数限制，gg。</p><p>人数限制。那么这个题其实是背包（dp，说背包更好理解）+并查集。</p><blockquote><p>但这样只能分出几个大集合来，每个集合又分成两个小集合表示两种类型的个数，而我们要求的是在所有大集合中选出一个小集合然后加起来看能 不能组 合成p1，并且要唯一，这里我们可以想到用背包来做，<code>dp[i][j]表示前i个大集合好人为j个的方案数，第i种状态只能是有第i-1种状态而来，我们用w0[i],w1[i]表示第i个集合两个小集合的个数 ，所以dp[i][j]可以由dp[i-1][j-w0[i]]和dp[i-1][j-w1[i]]得来，这样我们只需判断dp[cnt][l]是否等于1</code></p></blockquote><p>dp不大行….(´▽｀)挺好的题。可以等做dp的时候回来做www</p><p>####poj1456</p><p>惊了 水题。安排一些日期干什么活收益最大。直接贪心。。</p><h4 id="poj-1733"><a href="#poj-1733" class="headerlink" title="poj 1733"></a>poj 1733</h4><p>给出二进制某个区间内的数字有奇数或偶数个1，问有几个问答是不对的。</p><p>跟套路相符，直接代入板子。与hdu3038有异同之处。直接带权，是偶数就0，奇数就1，注意[l,r) l要-1.</p><p>但是我输出做的不好，疯狂wa，改了三个小时，最后发现没有特判给0个问答的时候输出结果。。。</p><h4 id="poj2492"><a href="#poj2492" class="headerlink" title="poj2492"></a>poj2492</h4><p>题意：一些人谈恋爱，不能有同性恋，问给出的数据是否正确？</p><p>直接带1权并查集。。两类人的题还是很比较容易做的吧。</p><h4 id="poj1984"><a href="#poj1984" class="headerlink" title="poj1984"></a>poj1984</h4><p>题意巨长，直接看别人的题意了</p><blockquote><p>有多个点，给出一些关系，表示某个点在另一个点的东西南北方向多少距离，然后给出一系列询问，表示第几个关系给出后询问两点间的曼哈顿距离，未知输出-1</p></blockquote><p>不过居然1a了。。带权并查集真神奇。直接用板子模拟，因为曼哈顿距离，所以带权的时候带两个权。又因为给出一系列询问问的是某一关系之后的距离，需要离线处理。<br>不过一开始写的时候更新权值只更新了提供一个方向的权值，忘了更新另一个没提供方向的权值了…emmm，就是说每次连边的时候都要更新rak.x和rak.y。</p><h4 id="poj2912"><a href="#poj2912" class="headerlink" title="poj2912"></a>poj2912</h4><p>rochambeau…剪刀石头布？我好像做过啊…是见过，训练的时候…(つД`)ノ然而还是不会。<br>题意：有一群孩子和一个睿智，孩子们分成3组，每组只会出一种手势，但是这个睿智是随机出手，给出一些比赛结果，问能否判断出睿智？有无睿智？最快第几次比赛之后判断出来？数据集 n个孩子&lt;500，m个结果&lt;2000<br>做题ing：枚举睿智并查集吧。。时间上说确实可以，不过如何知道睿智啥时候判断出来呢。事后再枚举一下应该可以。剩下就是判断是否成立。应该就权有问题的时候。权直接取01%3加权，不过问题在于。。最后睿智不会判断QAQ</p><blockquote><p>而判断出来的局数，就是枚举其他所有人出现矛盾的游戏场次的最大值，因为只有否定完其他所有人才能确定这个人是特殊的。</p></blockquote><p>这个还是有点厉害的。。。就是说要先否定其他人，才能肯定你自己。</p><p>还是wa了好几次，init()放在了错误的地方。。还以为是上面那个否定出了问题。</p><h4 id="zoj3261"><a href="#zoj3261" class="headerlink" title="zoj3261"></a>zoj3261</h4><p>在星系中，恒星的编号$0～n-1$，有$p_i$的能量。给出事先的一些路。给出一些询问或者是摧毁某些恒星之间的道路，问能否找到当时询问的恒星所能到达的能量最大的恒星？n&lt;10000，m &lt; 20000</p><p>暴力做无论什么方法nm肯定不行。重点在删除某些边如何处理。就是说有没有线性时间内的回退操作…？或者是直接构造摧毁图？</p><blockquote><p>看到删边，很容易想到逆向离线处理，先把最终的状态建立出来</p></blockquote><p>但是最终状态的建立也并非易事。首先纯模拟是可以的，记录点到点间所有的边，用类似链表的东西记录nxt之类的。但是我不是很会这种方法。回头看一下题解。另外就是事先记录两个点是否被破坏，不进行并查集操作。但是这样又回回到之前的问题：不进行并查集操作和删除两点间所有的边的概念是否等价？<br>举几个例子，可以发现是不一样的。删除两点间的边不等于删除两个点。我厚颜无耻的观察了大家的代码，发现一般的代码是直接遇到两个点时不加进并查集，但是并没有拦下间接的路。<br>于是我又去看了一个用nxt,head数组做的大佬。看了许久，大体理解了一下这个意思——和上面那个一样。</p><p>原来我题意理解错了？</p><p>我tm。<br>用map+并查集写了写，wa三发，pe两发。问题1:当两者能量一样用编号最小的。问题2:最后应该是$a[find(i)] != a[i]$，是判断能量，问题3:输出每个case间空行时应做个判断在while下面一行输出。问题4:记得交换ab，省去一些判断。</p><h4 id="hdu1272"><a href="#hdu1272" class="headerlink" title="hdu1272"></a>hdu1272</h4><p>给出一些建边，希望任意两个房间有且仅有一条路径可以相通。问是否符合条件？</p><p>简化题意的话，就是裸的判断无向图是否有环。你会说：简单并查集啊！</p><p>然而我看了半天写了半天并查集就是查不出来。我tm也是醉了啊。我fk每次都更新了，真tm是惊了，感觉我的起码一个小时就这么荒芜掉了。</p><h4 id="poj1308"><a href="#poj1308" class="headerlink" title="poj1308"></a>poj1308</h4><p>给出一些有向边，问是否是一棵树？</p><p>1.入度为1<br>2.不成环<br>3.根结点只有一个。</p><p>只要三个都判断到了就可以了。写代码的时候因为上一个题气得要命失了智。</p><hr><p>啊终于做完了。这套题拖拖拖，不大行啊。<em>18-3-20__17:35</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并查集…&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://oodtoodt.github.io/categories/acm/"/>
    
    
      <category term="special" scheme="http://oodtoodt.github.io/tags/special/"/>
    
  </entry>
  
  <entry>
    <title>简单搜索1...</title>
    <link href="http://oodtoodt.github.io/2018/03/09/%E4%B8%93%E9%A2%98/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A21/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A21/"/>
    <id>http://oodtoodt.github.io/2018/03/09/%E4%B8%93%E9%A2%98/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A21/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A21/</id>
    <published>2018-03-09T02:55:03.000Z</published>
    <updated>2018-03-09T08:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单搜索…本来想以后做的。<br>发现大部分都不会诶。<br><a id="more"></a></p><hr><h4 id="poj2251"><a href="#poj2251" class="headerlink" title="poj2251"></a>poj2251</h4><p>题意：三维迷宫，问逃脱步数<br>dfs令人窒息的t了…<br>最短路还是用bfs做吧…</p><h4 id="poj1321"><a href="#poj1321" class="headerlink" title="poj1321"></a>poj1321</h4><p>题意：给定棋盘(n&lt;8，实在太小了吧。。感觉大了也可以做的说，可以作为状压水题做？)，棋子每行列只能放一个，问所有方案。<br>dfs，然后遍历检查情况</p><h4 id="poj-3278"><a href="#poj-3278" class="headerlink" title="poj 3278"></a>poj 3278</h4><p>题意：追人，已知双方一维坐标，可以+1,-1, * 2移动，目标不会动，问最短时间<br>一维搜索。。bfs。。注意数组大小</p><h4 id="poj3279"><a href="#poj3279" class="headerlink" title="poj3279"></a>poj3279</h4><p>已知按下一个方格会使得4+1个方格黑白对调，问消去所有黑块的操作方案，n <em> m &lt;15 </em> 15.<br>因为每一次的按下都会有很大的影响，尤其是四周的影响让我毛骨悚然般想起了南宁站的题。。兴奋的去查题解，但是发现并不一样。。这是01变换，所以可以通过枚举第一行的变换方法从而决定下面所有行数。<br>起初我理解错了题意，以为是黑块最少的方案，枚举了第一行的状态发现还要细分，并不能这么做╭(°A°<code>)╮当然消去所有黑块的话，应该枚举第一行的踩法。另外</code>c[0][m-1-j] = i &gt;&gt; j &amp; 1;`位枚举可以这么写。<br>在已知思路的情况下wa了三次。。枚举的时候用的n。。判断的时候又把m写成n。。我可能不适合做题了吧(T ^ T)</p><p>#### </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单搜索…本来想以后做的。&lt;br&gt;发现大部分都不会诶。&lt;br&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://oodtoodt.github.io/categories/acm/"/>
    
    
      <category term="special" scheme="http://oodtoodt.github.io/tags/special/"/>
    
  </entry>
  
  <entry>
    <title>dp1</title>
    <link href="http://oodtoodt.github.io/2018/03/09/%E4%B8%93%E9%A2%98/dp/dp1/"/>
    <id>http://oodtoodt.github.io/2018/03/09/%E4%B8%93%E9%A2%98/dp/dp1/</id>
    <published>2018-03-09T02:54:35.000Z</published>
    <updated>2018-03-28T06:48:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>dp专题。。。<br>dp把一个大佬同学劝退了….我好怕啊。。从刚进大学的时候看的题就是dp，当时感觉就是天书，用了两个小时去推到底在算啥。<br>感觉要步后尘了啊。<br><a id="more"></a></p><hr><p>###整数划分</p><ol><li><p>将n划分成m个正整数之和的划分数。（正好为m）<br><code>dp[i][j]</code>  表示i的划分中，j个数的分法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i&lt;j:dp[i][j] = <span class="number">0</span></div><div class="line">i=j:dp[i][j] = <span class="number">1</span></div><div class="line">i&gt;j:dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i-j][j];</div></pre></td></tr></table></figure><p>包括1的情况 + 不包括1的情况（每个数-1）<br>另外，将n划分成不大于m的划分数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i&gt;=j:dp[i][j] = dp[i][j<span class="number">-1</span>] + dp[i-j][j];</div><div class="line">i&lt;j :dp[i][j] = dp[i][j<span class="number">-1</span>]</div></pre></td></tr></table></figure><p>这里可以理解为有无0的情况，也可以理解为有无最大j的情况。</p></li><li><p>将n划分成最大数不超过k的划分数。</p></li></ol><p><code>dp[i][j]</code>表示整数 i 的划分中，每个数不大于 j 的划分数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i &lt; j  dp[i][j] = dp[i][i]</div><div class="line">i == j dp[i][j] = dp[i][j<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">i &gt; j  dp[i][j] = dp[i][j<span class="number">-1</span>]+dp[i-j][j];</div></pre></td></tr></table></figure></p><p>将n划分成最大数不超过k的划分数。不同的数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i &lt; j  dp[i][j] = dp[i][i]</div><div class="line">i == j dp[i][j] = dp[i][j<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">i &gt; j  dp[i][j]= dp[i][j<span class="number">-1</span>]+ dp[i-j][j<span class="number">-1</span>]</div></pre></td></tr></table></figure></p><p>跟上面那个一比，有没有什么发现？</p><ol><li>将n划分成若干奇正整数之和的划分数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">g[i][j]:将i划分为j个偶数</div><div class="line">f[i][j]:将i划分为j个奇数</div><div class="line"></div><div class="line">g[i][j] = f[i - j][j]; </div><div class="line">f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + g[i - j][j];</div></pre></td></tr></table></figure></li></ol><blockquote><p>i中拿出j个1分到每一份中，将剩余的i-j分成j个奇数<br>一份包含奇数1，剩余的i-1分成j-1个奇数；另一种，每份至少大于1，将j个1拿出来分到每一份中，其余i-j分成j份</p></blockquote><p>##背包</p><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>超重要<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f[i][v]=max&#123;f[i<span class="number">-1</span>][v],f[i<span class="number">-1</span>][v-c[i]]+w[i]&#125;</div></pre></td></tr></table></figure></p><p>一维<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</div><div class="line">    <span class="keyword">for</span> v=V.<span class="number">.0</span></div><div class="line">        f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</div></pre></td></tr></table></figure></p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>裸思路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f[i][v]=max&#123;f[i<span class="number">-1</span>][v-k*c[i]]+k*w[i] | <span class="number">0</span>&lt;=k*c[i]&lt;=v&#125;</div></pre></td></tr></table></figure><p>一维且$O(VN)$<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</div><div class="line">    <span class="keyword">for</span> v=<span class="number">0.</span>.V</div><div class="line">        f[v]=max&#123;f[v],f[v-cost]+weight&#125;</div><div class="line"></div><div class="line">f[i][v]=max&#123;f[i<span class="number">-1</span>][v],f[i][v-c[i]]+w[i]&#125;</div></pre></td></tr></table></figure></p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>$O(V*Σn[i])$<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f[i][v]=max&#123;f[i<span class="number">-1</span>][v-k*c[i]]+k*w[i]|<span class="number">0</span>&lt;=k&lt;=n[i]&#125;</div></pre></td></tr></table></figure></p><blockquote><p>多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。</p></blockquote><h4 id="cf922e"><a href="#cf922e" class="headerlink" title="cf922e"></a>cf922e</h4><p>题意：n棵树，召唤第i棵树的鸟需要cost_i的能量，第i棵树有c_i个鸟，召唤一只鸟增加B的能量上限，初始有W的能量，W的上限，前进一棵树回X点能量，只能向前走，问最多召几只鸟。。。。。 n &lt; 10^3 $\sum c_i &lt;10^4$</p><p>用$dp[i][j]$表示走到第i课树，第j个鸟，剩下能量最多的情况。<br>转移方程：$dp[i][j] = max(dp[i-1][j],dp[i-1][j-k] - k*cost[i])$</p><p>三重循环，复杂度$n * \sum c_i $，题意有很明显的提示。。。</p><p>问题在这：如何获取能量的情况？这就跟dp数组挂钩了，使i加的时候+x，j加的时候上限+b吗？</p><p>最后抄了别人的代码：请细细体会能量的获取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  ID: oodt</div><div class="line">  PROG:</div><div class="line">  LANG:C++</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> n,m,k;</div><div class="line"><span class="keyword">int</span> a[maxx];</div><div class="line"><span class="keyword">int</span> cost[maxx];</div><div class="line"><span class="keyword">int</span> c[maxx];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][maxx];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">0</span>,pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> W,B,X;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">    freopen(<span class="string">"/Users/ecooodt/Desktop/c++ and acm/special--专题/8-dp/简单(easy?)dp/cf922e.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;W,&amp;B,&amp;X);</div><div class="line">    <span class="keyword">int</span> w = W;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cost[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = w;</div><div class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">    &#123;</div><div class="line">        tot += c[i];</div><div class="line">        <span class="keyword">int</span> up = w;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= tot; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j &amp;&amp; k &lt;= c[i]; k++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j-k] &lt; k*cost[i]) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">int</span> t = min(up,dp[i<span class="number">-1</span>][j-k]+X);</div><div class="line">                dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j-k] - k*cost[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(dp[i][j] != <span class="number">-1</span>) dp[i][j] = min(dp[i][j] + X,up);</div><div class="line">            up += B;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ans = tot;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(dp[n][i] == <span class="number">-1</span>) ans --;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dp专题。。。&lt;br&gt;dp把一个大佬同学劝退了….我好怕啊。。从刚进大学的时候看的题就是dp，当时感觉就是天书，用了两个小时去推到底在算啥。&lt;br&gt;感觉要步后尘了啊。&lt;br&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://oodtoodt.github.io/categories/acm/"/>
    
    
      <category term="special" scheme="http://oodtoodt.github.io/tags/special/"/>
    
  </entry>
  
  <entry>
    <title>最短路一套</title>
    <link href="http://oodtoodt.github.io/2018/03/09/%E4%B8%93%E9%A2%98/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B8%80%E5%A5%97/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B8%80%E5%A5%97/"/>
    <id>http://oodtoodt.github.io/2018/03/09/%E4%B8%93%E9%A2%98/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B8%80%E5%A5%97/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B8%80%E5%A5%97/</id>
    <published>2018-03-09T02:54:13.000Z</published>
    <updated>2018-03-21T11:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最短路都做不动…</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>####poj 2387 最短路裸题</p><p>####poj 2253<br>源点到终点有多条的路径，每一条路径中都有一段最大的距离，求这些路径中最大距离的最小值。<br>替换松弛条件，或者说dijkstra里lowcost的意义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> cost[][MAXN],<span class="keyword">int</span> lowcost[],<span class="keyword">int</span> n,<span class="keyword">int</span> beg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        lowcost[i] = INF;</div><div class="line">        vis[i] = <span class="literal">false</span>;</div><div class="line">        pre[i] = <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    lowcost[beg] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)<span class="comment">//遍历所有顶点</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> Min = INF;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//找到一个符合条件的值</span></div><div class="line">        &#123;<span class="comment">//起初在未获取最短路径的顶点中，找到离源点最近的顶点。</span></div><div class="line">            <span class="comment">//现为在未取得与源点间的最大距离的顶点中</span></div><div class="line">            <span class="comment">//找到更新后距离源点最大距离最小的点（我的天。</span></div><div class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; lowcost[i] &lt; Min)</div><div class="line">            &#123;</div><div class="line">                Min = lowcost[i];</div><div class="line">                k = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span>) <span class="keyword">break</span>;</div><div class="line">        vis[k] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; max(lowcost[k],cost[k][i]) &lt; lowcost[i])</div><div class="line">            &#123;</div><div class="line">                lowcost[i] = max(lowcost[k],cost[k][i]);</div><div class="line">                pre[i] = k;<span class="comment">//替换lowcost意义为路径中的最大值</span></div><div class="line">            &#125;<span class="comment">//原为与起点之间的最短距离。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="poj1797"><a href="#poj1797" class="headerlink" title="poj1797"></a>poj1797</h4><p>1-n之间的能通过的最大负重。双向通路。<br>dijkstra变形同上题，上面那个是max，这里就是min</p><h4 id="poj3268"><a href="#poj3268" class="headerlink" title="poj3268"></a>poj3268</h4><p>单向路，求所有点到某一点+返回的最小值。<br>起初跑floyd，结果n是1000，炸掉了。<br>没想到做法，度娘一番，发现居然是dijkstra求反路，就直接用正的dij求一遍这个点到其他点的距离，然后用反的路求一遍其他点到这个点的距离，啧啧啧…我大概可以用僵硬来形容自己的思路。</p><h4 id="poj1860"><a href="#poj1860" class="headerlink" title="poj1860"></a>poj1860</h4><p>题意是我手里有一些钱，通过一些关卡时要换成别的钱币，先交税，然后比率兑换，即 (x-y) * h，问我最后能不能回到最初的钱币样并赚钱（笑）<br>关键在于想到只要图内有正环就一定能赚钱——只要在正环内无限循环最后转回最初那种币就行了。反之走一圈检查是行不通的，即可能最后转回最初币的时候大跌一波。<br>那么就成了检查图内正环的问题。<br>类似于判断有无负权回路，把板子改一下…<br>发现自己根本没接触过spfa….嗯听起来好像是队列优化过的bellman…<br>算了回头再说，反正没卡（<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_loop</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</div><div class="line">    d[s] = v;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)</div><div class="line">        &#123;</div><div class="line">            Edge e = es[j];</div><div class="line">            <span class="keyword">if</span>(d[e.v] &lt; (d[e.u] - e.y) * e.h)</div><div class="line">            &#123;</div><div class="line">                d[e.v] = (d[e.u] - e.y) * e.h;</div><div class="line">                <span class="keyword">if</span>(i == V<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="poj3259"><a href="#poj3259" class="headerlink" title="poj3259"></a>poj3259</h4><p>负环裸题。。。<br>我抱着搞下板子的心态弄了弄，啊，还是出了好多错啊（最难受的莫过于没看清是双向路…）上面那个可以的，不过没法求最短路…</p><h4 id="poj1502"><a href="#poj1502" class="headerlink" title="poj1502"></a>poj1502</h4><p>读取很恶心的…呃…最短路裸题</p><h4 id="poj3660"><a href="#poj3660" class="headerlink" title="poj3660"></a>poj3660</h4><p>题意：<br>N（1≤N≤100）奶牛，编号为1..N，正在参加编程比赛。 众所周知，有些奶牛的代码比其他代码更好。 每头奶牛都有一定的技能等级，这在竞争对手中是独一无二的。<br>…翻译比较好玩就贴过来了。问最后能确定排名的奶牛数量。</p><p>floyd求关系的思路没毛病。但是求关系的时候如何判定关系还是要小注意下吧。写的<code>d[i][j] = min(d[i][j],d[i][k] + d[k][j]);</code>就不如<code>d[i][j]=d[i][j] || (d[i][k]&amp;&amp;d[k][j]);</code>后面这种其实是简化过了的，简单展开一下就懂了。</p><p>虽然这么说，感觉很巧妙，但是…这个题本质上，是floyd求传递闭包………….(改天开咯)</p><h4 id="poj2240"><a href="#poj2240" class="headerlink" title="poj2240"></a>poj2240</h4><p>先吐槽一句自己多组数据处理越来越弱了，起手清空永远的痛….另外数组还不会开？？？这不大对了啊。<br>然后就是这个题….题意和1860类似，不过没有指定起点，只是问能不能赚钱？所以要遍历所有起点bellman……(´▽｀)我tm不遍历其实也过了….<br>可是还是卡了。<br>你猜我tm卡什么了？<br>我卡Yes/YES了………………Σ（ﾟдﾟlll）半小时！令人窒息漫长的半小时！！</p><h4 id="poj1511"><a href="#poj1511" class="headerlink" title="poj1511"></a>poj1511</h4><p>给定节点数n,和边数m,边是单向边.数据在1000000内<br>问从1节点出发到2,3,…n 这些节点路程和从从这些节点回来到节点1的路程和最小值。<br>dijkstra求所有点到源点的距离，再把路反一遍再推一遍…话说这样的题就能想到倒过来做，poj3268就没想到…大概是太久没做题？<br>另外卡时间了（，裸dijkstra不能过，需要堆优化的。当板子咯。</p><h4 id="poj-3159"><a href="#poj-3159" class="headerlink" title="poj 3159"></a>poj 3159</h4><p>又一道卡时间的鬼题…用vector的板子竟然无限t….<br>说下题意，题意也很迷一开始理解错了…分糖果，每个人都觉得别人不能比他多$a_i$个糖果，最后问第n个人-第1个人的最大值（我一开始以为largest difference he could make out of it 是说只要差值最大就行。。结果限定比第一个人大。。）<br>把小于等于这个条件换成等于，然后建边求最短路即可。（可以画个三角不等式看一下）<br>这类问题似乎也有着统一的归类，叫「差分约束」。<br>一般差分约束题目会有三种情况：(1)、求取最短路 (2)、求取最长路 (3)、判断差分约束系统的解是否存在</p><ol><li>最短路：dij，bellman，spfa</li><li>最长路：bellman，floyd（无回路），spfa</li><li>判断解是否存在只要判正环就行了，所以bellman，floyd，spfa<br>这个题因为没有负边，所以可以dijkstra+heap优化过…虽然原来的板子过不了。但是一般可能是用到stack优化的spfa做的…我懒啊我不想学…不过还是要学…你看上面的所有都能用spfa…主要是能用到负环或者正环里，万一再跟这种题一样卡一下时间岂不是爆炸。<br>所以回头再做一遍。</li></ol><h4 id="poj2502"><a href="#poj2502" class="headerlink" title="poj2502"></a>poj2502</h4><p>给出家的坐标和学校的坐标，给出各地铁中各站的坐标，已知地铁和走路速度固定，求最短时间。地铁站数&lt;200<br>建图求最短路。<br>我wa了两次，问题出在地铁是双向的….建图的时候要注意不要单向地铁(つД`)ノ<br>关键就是建图。地铁站数这个条件很关键…所以就直接把所有坐标当成点建起来，然后链接所有边，40000嘛。。反之dij就算矩阵形态也是o(v^2+e)的跟边关系不大。。。<br>关键是抽象出点，距离。</p><h4 id="poj1062"><a href="#poj1062" class="headerlink" title="poj1062"></a>poj1062</h4><p>一开始以为是简单dij…是我错了<br>题意可以用别的物品+更便宜的钱买东西，要买的最终目标已经确定，这些人又有等级制度，不跟相差超过某个数的人「间接交易」，韦天魔术棒。<br>这个间接交易直接把我卡死了。从起初的思路（直接等级差）到改进的思路（判断最低可能，但是有等级超过目标的情况）全卡死了。<br>我去睡个觉，看看有没有灵感。<br>耶a了。n很小，只有100，所以直接枚举所有可能的最低等级，然后建好多图都dij一遍。复杂度o(n^3)。优化肯定是还可以优化的。</p><h4 id="poj1847"><a href="#poj1847" class="headerlink" title="poj1847"></a>poj1847</h4><p>???模版题吗？</p><h4 id="lightoj1074"><a href="#lightoj1074" class="headerlink" title="lightoj1074"></a>lightoj1074</h4><p>…题意：(u,v)的边权是(b[v]−b[u])^3，输出从顶点1到各点最短路径，如果最短路径小于3输出 ‘？’，否则输出最短路<br>小于3里其实包含了负数的情况，因为是指向性立方，所以可能有负权…<br>这个题要标记负环上的点，emmm，我用百度的某个bellman标记的，但是感觉不一定正确…因为网上查不到类似的代码…全都是spfa….(つД`)ノ<br>所以回头再做一遍呗…大体的思路是没问题了，至于bellman找点嘛。。需要更多的实践</p><h4 id="hdu4725"><a href="#hdu4725" class="headerlink" title="hdu4725"></a>hdu4725</h4><p>不大行不大行。<br>这个题很好，是很好的思维转换题。<br>题意：有一些点在一些层里，相邻层可以连双向边，权值固定，又有一些点和点之间边，问1-n的最小值。<br>首先要把层抽象成点。但又不能层中点和层连权值为0点双向路，否则会出现层中点互连的情况，与题意不符。这时候就要只连层到点，而点去连相邻层。<br>思路我还是，有点僵硬的。<br>哇然而按着对的思路写还是wa了4次，问题出在点连相邻层后就不需要再让层和层之间连边了，冗余重复甚至有问题（其实不懂诶，应该没问题的吧，存波疑）</p><h4 id="hdu3416"><a href="#hdu3416" class="headerlink" title="hdu3416"></a>hdu3416</h4><p>最短路+最大流（QAQ）<br>打开了最短路和最大流之间的一扇门╭(°A°`)╮ %%%%%%</p><h5 id="POI-ZAW"><a href="#POI-ZAW" class="headerlink" title="POI ZAW"></a>POI ZAW</h5><h5 id="uva10806"><a href="#uva10806" class="headerlink" title="uva10806"></a>uva10806</h5><h4 id="hdu-4370"><a href="#hdu-4370" class="headerlink" title="hdu - 4370"></a>hdu - 4370</h4><p>思维题。巨难(つД`)ノ。<br>另外有提到新的内容，最小环的求法。<br>spfa究竟还是要学的啊。</p><h4 id="poj3169"><a href="#poj3169" class="headerlink" title="poj3169"></a>poj3169</h4><p>差分约束</p><p>嘛就这样呗先。。有点疲累了，下次带着spfa再做，把最后那点内容都弄完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最短路都做不动…&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://oodtoodt.github.io/categories/acm/"/>
    
    
      <category term="special" scheme="http://oodtoodt.github.io/tags/special/"/>
    
  </entry>
  
  <entry>
    <title>org-mode学习笔记_1</title>
    <link href="http://oodtoodt.github.io/2018/02/26/org-mode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/org-mode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://oodtoodt.github.io/2018/02/26/org-mode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/org-mode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</id>
    <published>2018-02-26T05:02:47.000Z</published>
    <updated>2018-02-28T02:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>gtd相关的一些内容<br><a id="more"></a></p><p>这个笔记主要是我看一部分就忘一部分很头疼……</p><p>理一个纲出来：<br>todo状态——包括优先级啊，复选啊，进度啊，多状态啊<br>标签<br>属性（属性是带值的tag，或者实现数据库，暂时先不学了，我本来是想这么说的，结果看了一下column视图实在是很好的东西啊。。）<br>时间戳<br>capture，也是我一直在用的一个吧算是。<br>杂食，比如稀疏树一类的知识</p><h2 id="主食…"><a href="#主食…" class="headerlink" title="主食…"></a>主食…</h2><h4 id="大纲之间跳"><a href="#大纲之间跳" class="headerlink" title="大纲之间跳"></a>大纲之间跳</h4><p>C-c C-n/p 下/上一个标题<br>C-c C-f/b 下/上一个同级标题<br>C-c C-u 上层标题</p><p>####<br>C-x n s/w 视角放大／缩回到某个大纲。</p><h2 id="杂食"><a href="#杂食" class="headerlink" title="杂食"></a>杂食</h2><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>[fn:name] 注释，name是唯一的标签<br>C-c C-x f 当前创建注释<br>C-c C-c 对跳</p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>C-c | 选定域转换为表格<br>别的不管</p><h4 id="sparse树（稀疏树）"><a href="#sparse树（稀疏树）" class="headerlink" title="sparse树（稀疏树）"></a>sparse树（稀疏树）</h4><p>C-c / 特定的sparse树</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>无序列表 - +<br>有序后接句号或右括</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>不会用。可以先用注释代替跳转。。。</p><h2 id="todo状态"><a href="#todo状态" class="headerlink" title="todo状态"></a>todo状态</h2><p>C-c C-t<br>定义各种状态，去init-org.el里改</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>C-c , 设置<br>S-up ／ S-down</p><h4 id="子任务"><a href="#子任务" class="headerlink" title="子任务"></a>子任务</h4><p>在父任务上[/]或者[%]并C-c C-c<br>如果要使父任务能够继承子任务的任务情况，需要:COOKIE_DATA: recursive的属性，记得直接是在父标题下面加的</p><p>子事项以[]开头，则被当成一个checkbox，然而我无论如何也调用不出来，反而耗费了大量时间=-=按下不表</p><h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><h4 id="为标题分配tag"><a href="#为标题分配tag" class="headerlink" title="为标题分配tag"></a>为标题分配tag</h4><p>C-c C-q 输入新的tag。<br>另外设置<br>这句+TAGS: { @work(w)  @home(h)  @tennisclub(t) }  laptop(l)  pc(p)和下面的设置相同（就是lisp翻译）<br>(setq org-tag-alist ‘((:startgroup . nil)<br>,                      (“@work” . ?w) (“@home” . ?h)<br>,                      (“@tennisclub” . ?t)<br>,                      (:endgroup . nil)<br>,                      (“laptop” . ?l) (“pc” . ?p)))</p><h4 id="搜索tag"><a href="#搜索tag" class="headerlink" title="搜索tag"></a>搜索tag</h4><p>C-c / m 。。。记得吗！sparse tree。<br>C-c a m agenda中搜索tag<br>C-c a M agenda中搜索tag但只带todo（并强制子树匹配</p><h2 id="属性和column"><a href="#属性和column" class="headerlink" title="属性和column"></a>属性和column</h2><h4 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h4><p>：PROPERTIES： 特殊抽屉，每个属性一行，键在前，值在后。记得全带:content:</p><h4 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h4><p>。。。太多啦 一般就是todo，tags，priority，deadline，scheduled</p><h4 id="搜索属性"><a href="#搜索属性" class="headerlink" title="搜索属性"></a>搜索属性</h4><p>C-c / m 所有匹配tag搜索的标题<br>C-c a m agenda搜索所有匹配tag/属性搜索的标题<br>C-c / p 根据属性搜索匹配</p><h4 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h4><p>属性默认具有继承性，然而默认不打开:( </p><h4 id="Column视图"><a href="#Column视图" class="headerlink" title="Column视图"></a>Column视图</h4><p>column定义式。。按下<br>C-c C-x C-c<br>r或者g 刷新<br>q 推出<br>e 编辑值<br>v 完整的属性值<br>a 编辑该属性的可选值</p><h4 id="捕捉column视图"><a href="#捕捉column视图" class="headerlink" title="捕捉column视图"></a>捕捉column视图</h4><p>啧，没用。</p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>C-c . 插入对应的时间戳<br>C-c !  无效的时间戳（即不会影响agenda上的显示）<br>C-c C-c 更正时间戳（星期数<br>C-u C-c .／C-u C-c !<br>C-c C-y 根据时间段计算出时间跨度显示在minibuffer上</p><h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><p>deadline &lt;…. +1m -5d&gt;每一个月重复一次，表示提前5天发出警示<br>++指令：比如说更换电池，只需要你在最后一次完成任务的时间点之后开始计算重复<br>C-c C-d 在标题的下一行插入deadline关键字<br>C-c C-s 插入scheduled<br>C-c / d 超期的或快要超期的任务sparse tree<br>C-c C-x C-k 标记任务为agenda action的目标</p><h4 id="计时——Clock"><a href="#计时——Clock" class="headerlink" title="计时——Clock"></a>计时——Clock</h4><p>emmm，挺麻烦的，需要一个started状态才能计时<br>C-c C-x C-i 开始一个计时<br>C-c C-x C-o 结束<br>C-c C-x C-q 取消<br>C-c C-x C-x 在最后一次开计时的地方开计时<br>C-c C-x C-e 更新效用评估信息 大概的话就是[0:33/0:00]后面那个</p><h5 id="计时报告——dynamic-block"><a href="#计时报告——dynamic-block" class="headerlink" title="计时报告——dynamic block"></a>计时报告——dynamic block</h5><p>C-c C-x C-r 建一个详细的表<br>（C-u）C-c C-x C-u 更新光标所在表（所有表）<br>详细不展开了。</p><h2 id="agenda"><a href="#agenda" class="headerlink" title="agenda"></a>agenda</h2><h4 id="C-c-a——"><a href="#C-c-a——" class="headerlink" title="C-c a——"></a>C-c a——</h4><p>t 全局todo列表 T 自己选关键字<br>m 匹配tag和属性的标题<br>a 日历式列表（本周<br>L 当前文件时间轴视图<br>s 关键字/正则选中的条目列表</p><h4 id="agenda下的命令"><a href="#agenda下的命令" class="headerlink" title="agenda下的命令"></a>agenda下的命令</h4><p>n 下一行 p 上一行<br>spc 在另一个窗口显示条目所在的位置<br>tab 类似 不选中（高亮）条目<br>ret 直接跳转到位置</p><p>o 删除其他窗口，比C-x o C-x 1块<br>. 跳到今天<br>j 跳到某一天<br>A = C-c a<br>r/g 更新agenda<br>t 更改todo状态</p><p>T show tags<br>： set tags<br>, 权重那边的</p><p>C-k 直接删除条目<br>C-c C-s 直接规划条目 C-d同理</p><p>I（大写i） 直接条目计时<br>O stop /X cancel<br>J 跳到正在计时的窗口</p><p>####v view模式直接选择需要的视图(或者不记得某个键位了) 记得todo模式不支持视图<br>m 月 d/y/w同理<br>d/w 切换日周视图 b/f前一个后一个调整用<br>a 档案模式<br>R clockreport mode 意义不明<br>l log-mode（可能是最有用的一个）<br>c 据说是展示show overlapping（重叠）的clock 可是我这边怎么看都跟log-mode一样<br>总之见机行事（自己认下英文啦，明明提示都在那，和文档大概不是一个版本的，自己看吧）</p><p>行了，这样大概就不怎么需要再查文档了……遇到问题直接查英文文档问题应该也不大了。<br>大概看了下有点多，慢慢来吧（当初emacs不是也那么多嘛……用得多了就是肌肉记忆了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gtd相关的一些内容&lt;br&gt;
    
    </summary>
    
    
      <category term="Emacs" scheme="http://oodtoodt.github.io/categories/Emacs/"/>
    
    
      <category term="Org" scheme="http://oodtoodt.github.io/tags/Org/"/>
    
  </entry>
  
  <entry>
    <title>Souls_其二</title>
    <link href="http://oodtoodt.github.io/2018/02/14/%E6%97%A5%E8%AE%B0/Souls-%E5%85%B6%E4%BA%8C/Souls-%E5%85%B6%E4%BA%8C/"/>
    <id>http://oodtoodt.github.io/2018/02/14/%E6%97%A5%E8%AE%B0/Souls-%E5%85%B6%E4%BA%8C/Souls-%E5%85%B6%E4%BA%8C/</id>
    <published>2018-02-14T09:22:30.000Z</published>
    <updated>2018-02-14T10:18:34.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">大哥，大哥。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19aujjEaOMQHiOem0Ibhxo/XQ1hOlx5T3dnTAf4ZieiJksW1qHQePYVMF1sME6AItnrBHiyCQHPr7NqsecIg8lkPQ4ahHbt1DdeRez1MMjj9bAZDVVGq56iQfyQxAqzSS3eW0bhm1pMetFzavvDqeNzldFnK+WJjutJ1+YP7ly9EbHZGf4HxSgSyjJN9lv7WlGwYYOuqoXzeUFA60buyol8/0GR1Iqcs8eriVCKPCQN/XTv0Bcy3+zFURQ91ozjDSKU7FDjDlAkneNCKxBhNSYy2Ilmg2cElDfdaQE4A6XwjXjtqZdHa/IpEqy2JIp8/GqhWyLysYhT+0IBNnGbtVr4PhVdKS37qJCaJU9pr9oQ1DNxdszHWvKkNh3tggRVA5mIKKTmf8AWFVZ0h3aJnGmBz1ivBUFY0Rjc6dqX4S7ffLxmPsqfflsleK4BRuRsWNgR2iYoeHoItzXGB7UO5axVSkyoXDzehYT87ULIiEDqfq7/7E1VQwCteujkh7rrOuTXg0sGkGp1QtQlPF4/M44y0viMSOLCvLM6JW7X8x3bB6K3kglS2U778Rr7k6/AFlr2c7qFQm/8Q6FhkIc8uPDa84BedZ4h1v2hAjVstLO5LoS31hAlV0XNguMGSQGPxhplpr2ptLSdjHBPw8K1QMuFroe6B+S4v7md6LZlN6RFu1XQIi0NB8zuGvTCrKRmspY5cv/KL9V6yDwnKWgkCEmMBkV8SfXrcAYbKIn42f0fPN6sXIIB5ODuj1qry8olD/jf21Zy3k3ucsMvQtxpgRBXB9K28cmGZe8/eB0+qJCmjqSYR2S8Zqd3POGsGtDbb/yqVu58hGbKPGJEAefPuVMRVtUwY6sVlI4ms8IF5H5lCETHwpEMptktamgeeXletxniDu5EAHdt8d9uzM9zeugyZN6F/E9jJ9EzkMAcdENWY5K/rNr/+W5U/be7NyQLCN5UCJrgi/brjB2w88uxa5d/Uq7SMOERazH/j2yCmKC2euk4FHlfBo7b+wfWsZ8ty5gSEojmGQSybRh9Zt33U82N4Vi0ysQ3N8Z39XbLG2HzG/AMtMmqNXqNRNunRZI1rCbtoGdg1L1Ao/eVXyL/kWVWgCibuMvRdAZFYfuAg9XxwyvvFgt7vOG84wqRaOAYSjMbTRuJ4PraHHHPnwB2E9wKwdqIz027jDM9Ns+Wp1uESQDR/G4LpkqPMfx/hU/GTpZMktxohXOmt8UAWdpBPuYnO09KKMGiOBmbvQo/xY9WW9Nysa8PmNePvmVwPI9xuxxykSB9FrLcCOuh2zMOIeZUqIfKUd8ebmIAzDmIbQ8EElRRi2TnpgoIvINWyi1x8S2RwB1NN1tDDZ/5G1Y3npWB30TpEnypDaBMookxDOyXGLlRufkTV3gb1WzhcwRhJCp0rMPjYrIwuZa0eWpglDnDURGDzcd4vSsEV+hmAcezXwkA0nGrl4q7xGVR2GQEcC0yTh8l40Xc51ZY8wunMmRe9QQxIFkP8Lmue1R7HMd6RFz41+IbjAa8vBunnPp4t5BpRbZ3rAGciGt0JPUCkxbBlUhWUTnZP1DiAfqyZJeVKWcsiDBeGu6J5IOSaNpJ0wtHNEJTnZOEpTDvTJYDkbtnElY5mHIWCrc4tvhTGp3+aW7hBdW2IZUx9Hp9AUmiaTADCVO5q7TuRAYrqCyCoVXn8/MRfQRYGLr9vX9bLTg40dgfjr0m4vL49fGIg5V91UzKazYKfZlpcxLQ413EhEqdCUzZzGSHznbODz2eltoQXPbjeLCBCP/Ezrbns0SDua2mphd9X77zBt4vR+5nKRZNX6L3oHxUXpUp27F4J4zHSfHIGtxIN03xFNus6Kc2LPN5iZtkCGcFkDSdFjEqunyKUgpY4wossu/Njdh+EC28DT+UA7OU3y0gFeFxRe0iFfwjrHTt4CNaOGLl8uI7FvZMoWRwtsm0HVyTzM8ANy/dbSOsXrSZtPowJAlUEMPaCg7Tiv/yykHJCtf/xS7rvBBFtWVCD48+paUiv/vy3SnFWGzwWhxHKGyveL9YlG87r3J4H3HM2PtRhjnMwZDq3imL8JRBD+pDi+6nvi+be0Nl07DLUiJ/8kRxNTGTTYNcdQgteTLMoT79Al0zCAMqlnRHYRt37k7M1Udc3NFUsBwHVI2zE5U1R+BmhQ019CBxMOxCbQROuK55zzWDReQeVxyhdMTumHTEYiG95G71SxQVxiAE4SU5M8VQKaZHY/7XoIIyh+ny3jKQW4bZrWNfbLxIRCWUDz7zp9rqMmhuMPXsC8BOwU9lXV077RE9rPXW5d5zs+aSkbi3OXmc4PvlwIqwI2rmCa0v4z/c5cDX2MujlU35floXK+UbxRJD1W8AajqbIrjSaK60FfqErBgd+b7EsLx8DV6RvCH37eD6eMPxpI/+ztzAjGi6EmnJ88COsWwaDJ3e7gYoF5cb36PorBj2EctOek3EGpbHcGEvBD/Qkflc8tG4n8EGy0hv41d4mRaTuKYApBrOkmtEb1N/CafLiNwUsuCcwSHupNNe2S9/9Xx/szcezSD+7q0n6XQ55Ff7VnUfp6a52fk1czY69MNXc/2e5Gk970iByRV0fy6UBoVvg0tGLCGtlkpL95l1Eo32JzAgjL78LtFm+jMRXRdB8xRt4SlWwlIZoSxoYM66gU0E/a3VZe/NIPeBEh4z+V5mLGAD/nc6EOE3+71B0DKKktwU3FL0cL/k/jbsGdI/Y2qoNaEUzHqDdOaGf4gPvc8QAcwsZaK6u2MsELrqqy9NMX4CXcHby3zQzzl78Mubrcuc/+tggl+Mup61YroU99xUS7HMMmCzgMLgbCkg490k0Pc1YSf4OaYjf9j+AMddBEty/1Z12ePtqqs6JCCZGdHUadw8eqCx9dbYIC9s8G0+bB9mTe5SkH7KRtNmnFQ2Oy3ufMJEBGpdICziei9fmDARtt2O24Js3caWSAJiEyZmpx1YvdGVQgC/5/9ct9OK5uXegCcE2Bb368PwNvXb76ohOI66ktG/wW5xergDzo+oyKGV15LJ8eTjIsqEckC40eia4S8MFhjPduAPR1lGrFkkVx9/+rEoMfGEu7ltMKpe8Fg3jkT5aAp3QcMjVHfY97KHbnh+bmt/TzOGcwUFi86nWQsTAMX+K5ByCDa7TjvmjwlVWIq1s03XlVA72iiAaia9RO/DV1WBQuIviMHFJXw3tYaEb1abdlrFLSqJdjuy8xNWqJZ75Zn3k5R+kX0Q0rvtZat6DjSlYjVdsndruMNsOPMfMvqBDpjKfQ2TRbbogqxuEXOi7YU3hZ15c8aiTqF/vzG+7M3TB3CtXB7jIMre9OfJXnbCyVtDNq3WZUw5vErdpPzsL82SdaxvET6Kk2XvlVktFuD3mOrMtylWk2CR51sYYnKj/ieK12gUk3zKLQzgSs18/JsxSkqLnN37eT9PafRa6Z6mOyHA6w9jSiNLPQYZcb4zHXrGXKJUzCLw4iPhOfBPMTJzhRZXgMhsl4KSx2O4PPx27zIizEc51m0+z0xCrf7v/FGQ6ilLpLtnttxfQNyMClzzmMQTkWu33gSMVbIpKx7Y+18p8lRGqCbQgZy4lCU2tGE0RK5eHbfebaIWj/7NDYc4u+3lSIgAWXutBEi5mf14+vT8Uj8dAIWOLeCYs1YVFdNKtD28/YPjnwtCOsa+ZsUzlZvxE1Ml8zuUbiSP2vPaYhdEtaYC+GLmGqyPVYv8+M33rv1O1YfRNUe08y5wctzP7jiwUoDxdQ2ABwROBch1YXyh5aThCWEvGf3LJ6q5O2UqpyYlVD7/Bp4Yn9KZNn1ggyH6BFvAZYF+ijJ2fNLR5YO+JThXD5GX9hD6vfsdMZANkuaSC7HLvxuTqb1yEAY5YMeStZw26jF3+FPJzyp2YPiafPlf24OLKhBaZBilk2f2YSYLFtnqxLihEpGfdHeZ8YN2oPH4lcHaRVJFdtmUojKYu8b+9tEeTnkTgZ9muunP6ajr8Ckf062GcG6435mE/luhW6aHPv/crLKq3aA8EOajlQmwjS+rq8sYP3J0oFvPDMF9MrairiJVZmJDtKY39DYTWGhjjGFIm4W+xcV9MVaBUjr9nwBKLqj8hnq4sDiatswAU5qHNWGvngNQ1OhQmfIvupM5s0BPmpa+vpjWP+CrlV+0FbDfijdjRZDr371YDArHScxa8ZewsMziWGdOnv4l3yymJR4YmRt4HYZtPFd9GIkhplVdSKktTL31JjXuVzjosv7K2nI4/U5pf59ZcSqAL2qNv/aJLnqI9lMSV2pPF3tQQ782y1xEzKvu2kmysBsz521UPYq55Pwh3fWCGeFz7RZUvEqOiOuso4XumzyopihfD1hXIATh+CoWVikm09QODG0wh7fv9e53T5I6eTSl6Ms+LPmED0dnnQxJN0HexKEgBJJYWfKYbmbx+7vLO0K7xpkjem6loQP+QUnGnPP+HlTnNxFxJ8l+arrqR1hgcLL4jIXSmexCU818U9rl/nGpuWaYNHvulJBUZLf8AW2XkZvblID0wK6V/yCLFn2ouk14YYhvUFZOZpicxpjuHWc5FIIuiDLdbYNHvSlz2pMs3jzWsaZboUJHozfj4YaEpQTjUbc0/VTAQ9ScRCWG7kvgpSCk9wtucEN76FSwnF9cmoZLhK52VYFVbWz/E4IivHpSLnoumvZhPzsW6nLJEztOj37SP3K9A89qaxmUYR4vr505cB4yU/DjzO68zhAydOq+XO93bbmmqZGcJVuW13QfMrjADtiSd2P5g+ox42bTa+0xA6iKOFdkl6BmL4/pNoMySUDY3HAkQc/coTxxRNNbbWJZzMOz1bYCW3lLqmWJhOH2nqmlxKaehExGAf7JCn8IKCH41QAqNyGYA4sFT0HMD1zPXGNqFTLYIBerqvLvV14kpnq9liscd87vb3x5X9sYNN3er2kC8DeognII/MVmKvSGbuCfyL4EJ/p6hjK1aS6HVswr62ud2wWzw7UBfeZ9sQig3BZ9HTzWTc23dE/2+HwZJi2otV68c3iLn1DgtHsXzqhXfyEEdESCO/IvU8/jPLqsxCzzUevhTVsnVjnNuCXFCy1eHYNu5Sf1zpTyjagkNU/pVd90UmOqCMrFHt/cb8vRr0Qi8y4WoSt7ZpFyqoMvYdYvKkj2/gu3zaUdBYiPr+bSLJNwopemaB78XLhTL9Mu1z80TKgpTKwDzALXCR2ICqA5ChnfJgr78YC+bezvRPZ0atJYIr/BFyVkuYuaNAoZqq6zcklzGFw14P+P0+SIw2tB+V9ORdCtgy2Xi/+NNXCXgWNNmtFT0pgc6Zm/ref/t9rMqygj8xSql2Islhly7QGueX4u4OB1yC2X7YuYJWjmm1vAy3gOlm3Ylh4vcWBOFbE2rlQcgRu2yjd+FMuu3pX9npQ11xNcUUYeZ+BN2A9bosQ4GXKjeXhg8ymc1a/gce805lgjdkPlbenG79ST1yhJvNG93sZPeYz+44fJxEFyasVv4i/1i8Ux+B2B8lKC09DX/diPez90FhyL7o82oyXn4GOBhId/UJ7DRKAo5CboTpJe3yq2PuXQbd2bTztNYB4l0jl2Dyu7jUH1LqB7ElfTnkn2UY8TcZFVee+ITKp4Xp76IgowwMvgbgIE6aeZYp1aQ2vcabta/yoTnueMwAQVhr6PhhFexC10nUoKOV1WaBIn94WGqLLpSIyscHIRRuXsASWz6D8SMTAfXqS2sJmrJC9y6JJrgYBbhSajzOQXzpQY/614DHd05LYBNisC4/ybrbtHWOrfOsmpXXApiILrNeQi6MGIFoeMIJhjDUG0uZvEgOetbI2fwzbXOK5052FcBNXFXnWSnA0J0m75+m0Ar37bnxl6S79gxPVj397QdDvFiJF0zB2OvDQcBnRjtDyoJT1Avmzr3wuRWYZb945jsynSRL222ZCXdzeE2OylJ17lUrWgA4HSZbzunOcLzsAd2pIuuXAPx2HFUlElxmmcevHNueV2GUegmtP/2K2qosTvZRPurLZNDz9xUqblckRZRyuTTv16h4u1aR/oRZwMyhNLnPkhwKH066GQElsZF6t7z1GGykTb7QWss5bQu1mIvWaZf5r/i4FiQcj11tuCrd89bugKJWOztGmMBtYfTfFDYKrAw5BzT65v1M5Iq+D4P77P4s7YUR+7hhztv9W1rGbeav/CwI6E1u2Y2w8AWKDQ/ZIkKsNkq/IWHrya6WZyClprrz4KmX4r5GOSYGWv3ysIlrbgkLKK2f6EtCZjYF7TFgM9XwdDVkcdPzBMdRhAUTd8i3CmHvujD1Wuv5lny91lHjkbpCYXjiRbrJVAepzWFZ6Msb7u5mgiuzembDGQ7EvvPeOQG5MnmNrVe5bLK5CotQw1mHa03PUuYoBbCgmd8L2Iv/FAR+Lemjfr5mlSBnMiCp5u4Zyu/+8r6PEBcDO34DHtcy67TsvNYi13shPompNnCQ2SZCzYkwYXDmAvR7lnVz9nJpKrpHSJcwLA721x/x+TUigmu03wZP1Xo9Y+I3cXTEEG5uikbxv+sP3z1nTv1LylDuXnyLdLIn07NDxHi78VBisY3ZXZfwGruqivlEtHBxKWh5zvlUjRMUsIL+phh1QxrEO+IL7zB4kIt7yrDLtT/wcSlWK7F7Fvs6kLtJI7wu1wF21C1peSDt7IjX4AKqnW73jS3r9frAExDvtL+mCwDPCVD51sAq3wwfTl+QhoXQ1gPcaQYLCXN8hMQ8+xLEHIixuwtagsAAjSEENkjTUhhzxVV+t6HEWca3guThIA7J46Ec3GM/aucybbXMNuU0CKsCOtaY5a8SmgBEX2fwwzv0HZcDMJMEap0mfQVPmmJpQt3AEMl1fEVZBE4HklFavFs4/UGFGUn8dIlN7avQXQtCwK2ZrEh3WzzwbLhflAV4GEHPU9zp7/fmzZj/PUEBY1SaJmrOgVVZKYI1MpFaUvOux5hGXAyQHB3dePFlqIb3S0mLOQndaEDEG7CIny2uMWjHyzZtcvQGYD1eWHPcCAw/yyF87csYYu/J7gvQlnIIl0xX6kgnAyd/QNQM8jPIY9Xk3WaA3TELfD4AKOnYyqDbAhOfuVF6gzouQYHpT7Jwu8kVzQNfwiJNjQBJJhzJIzwwNyhYPPSmUPDmFg91vewyj8IaM/poKvvVV035gcP2iLASysrgzKHuKeMwEin0wDHwb/TzQqUzU6gCcLQMEk57Os+Ud+khr4FHiw9qQa043zAaytdTt2dv/70SNU5LsOVfnjPT+Pbr8hqyF3R04hk3c7W/U+cF+3FfvMb6Q203Fe+0qekyoQQzoMseYJSv0qrz/bsOTwps8aF7EkYkjo+h3HK3WL+edEiVz09IyOkUMrLnCW6lprDw/abRowdpxgChxahVXBb3HFml3Lc6Akk7oOSgOM2QnB9wy0wOx2vEKmNw1/6L6m07FKpVhhELaTN+oVMlltbz1ytIJgmAXm1hXnECjBOXEd0rrAYkFdBrq0TGCMb/a33JIduM3PI9O8/co93fnJnJ51M4VgxeVK/jAhHZJLd+u+SrBHRE00+4akN4YZB6TpS7J/kRilZiQVDDZjaY4SLWgvO3A0jnZKkM3O2KOw78gsjIkJsKRnl46SdoKo4R7ux+JHtTMwBIN1VMddJVG5nofy42o0yKxaOdbSsq/nq14vO82qRoN0TuQcmO0b+Zlp0V9rZ8+VgHjEhJGwLZGdW1xvRNPVbg8lra+noUGSKUWoo2WRcys6+fgNK4F+XNMOErN0tMK++iiLCk+Y0PHuRQZqUXLP/MD2fo0xoX0N52/pnp7wo0pPdZBEV9twHoM/697sjeFQ/1OvuN3Z7suXJsBzT8IMMY5Nek+EDq4e9hngcc5fbV2MBTXHKAc81nz+A6I30sUJZytyA8VTfosdX01YGHZGY3i5V6cbhO2j0YO3rYCJAWm1eRxg5We/RTnQypkHjaP+/ihQgerViTGJaTnDj1RxD46gabcor/bSu056sjRHcd5coO7e+Bd31FvcvP1KTOMAirttMHXPlW1riHQxf4wVMPrhMul4xgGt8niBrJ2c4WDoG+GwH2WAvqeAltVTI/TC50ESPQV+rjJM9lbdLZQSp3pGUWUc0ZjDdNCc1Arqcxp9zEvqPqdxKl3tw0+xY06dIsKl64bttmAArYAyMQTAQ9xe453HOAdNqmGzoStovEpMuIlBcJwRdi2a+f1HRAQ00iMtub90S2LA4S0mc7F1z9IYiwPD1WP7uUi170OD4MRM3/t846yM2seF+5YMSb74Q7jcVUsCg04Q7aT9rCavPHJ0yOoX9ZD2u0q52GXjRUOC/gdmTTL0mQxl4MvAok34TSxzmILIUwQRyIWv1OI1+u70/l7kTM0zGQnpIdB6jZYFDRcVw8lKe5LGAeqJLGZM+G9X1FR+35jj0t33htqw5p2+mmAuVbgEu7xdU1f/CqJN8rcOYcZPya7USSgmTxY9E3qXev0rIjrd+0j1JTxXESbbSE+Rha58MXqWz8xN1wYH4BYfcxY4h8tFeaK4dlt9/GNK3FSVCjgw45ukZIXMAx84e+yh1vWRO1dwdDJsArcJbjaT2k2ko4wG7Kkx8n0SgDTW/2XNf7tvmTvVRFhcS1rVF+I1piYHkdkk1iQUnLFUETQhbuDOWUZ1k3NuIVAjntmha094U1tgUTTrunLdSYk8KTKPTkWcnmDE5EOqStKTCiA9pfRVpioSlqHZTgo87znKtheqgkbWdHltNc2o25SMytn0TUUPHVIWAnzniLTzvldYpz4A6YP/Y9SGAsp70GiyRaFAcdLPblEHedgZHW7Jmi7b0HZtBKB1UbXn3eCyY8nPqpNSh+GuqKYczp4QK6CU5em7lkVxL/YibbuOsszYeN0RF9QCYhathwbgidnsNhLlUT5Ne/TOo3WPIYKSI6lIDoSJfvcvKlXLMQFopUPHA2bsOgBfo8pIIb6tANS5DigDfh0mB7aZI3TGHB3tNOPiavyhbw1CK50HomTcWDZtN7mlzTSSFn+Di8O5U8ScK5JwcIl+uTnHp9LaRTrdkcbFE1NlZ0VolxZ0a0rJOxm1yJyPfuFzkpy130wBXKZVBBR+xecGUMFg2rnmKfapBhodlwLkGghjiB9Y1rGdjghX1+D6UXPcZ8+foJTX2irgi2BwQNEaPCBlSwtMs6UhBcAvf6PLq3uYyeXMWGsPaGudKoqDKpeZB/QPlotQISUsqqc7A4oHcnmhx6C8j1WI2Fd72K2+gz9SzMgmMezzJvsSaChRo8/QpxKqs+14yXGiFssSsw/FyGJbGSfaV30m2BTKeelfzLhn5hyNSQUQ3AxJiffQtaHkJE2GUyLT5QAjrvCGov0cY7wKxRjuoX9eQPiu38zSQH29lSjLIiBhz8BxvC5Uco0OqQ9a5X/7ioA0juGNcNeVAFthhXjAPwlDtbRbF3bEjAxKANiycDM+CttPPWZvcU7dWd+E6E0znGliVfylB9KSADbh0xAnrbpEf42ssBScs+leKIKWgdTVbWbSR83SAKozv7qorxx8pTeDYvZK2L0W0RCPgefhueRZpliKSf7P8fIarPJAw9vQfEvCkLXO9NYpOot0/pJgcpb8iCD9n3x94q3ML070xFYIIVq+l1qtAfOQe+2o+cm9zBZyKvBC2MqCa/h8S3cOIW9nyFsxJWKBFhYAA+ZJrfmLLTmuha0t0577GMdR3Na5uTEdD9qVmlfH1ABIPXv98GcsDfiptRVDnCj/ZXoR2Oq87JbTGbEPE6K935Vdd7y7ZEejlo99bUmqOFGsCJt1cRtZ78Eux9mOZv1g8DG4j5E6Pvs1MindTgN4REKQq8KKTkvbBfSg23yl689Hkt20CVVoa0P2Bk4f2PznlSWePOPd1/oeLluWoxqQNXOExH41rzKkf6qebNA1HrN1x60Ix/FdAVBNPshJUNgkA8NlsXQgpM6dPJl+eg45UgTgpYc0o535ke9j7wM72OgVduLSAufxwsa1WxvpSFrLvjARTkvCLpzCyqgbEhSUcQWt69hQ16+zL2fBehW7JzFifTMs0J9ZxdAUWvOvLuK6TjwX0N9hkLrXamw2DzxPEJrSPV7I69iuiFtGbxexaqK74gLYZvBS5uDf8v4pDWmKj1xL+/7/dcFxUX+PTjbwTsY+JJ0eZx1iJjaz7c5NDELfYdxlcR5YNZ9X7D0Y5fT1HY4B9dCt9NbmoGBEvsOm1p8Xn9ULvdhD1OC5Xn1USoOI+l9PiJj3EAInWGfDZTTVhh45aucec5WVGebTfGFVGNlCx4cVZjUupiqv2WyAn3ag+SmboKlm4BURqXO713yGLjlZDSjLEAjgaNrVJqBpJHb7ijRJeoJOCCQ6HE5LNkMp6F4MeRYPZBWe6iCNeidqr4oeOWKcUO/ehCQegyIQxqsEw+vsqI5VkGPAb8dAkIUwFJruM1Ome9NFijB8NryXrXrNRocv83EwSTKsgYrAa59ybnJb3DYnB/MR1LFc+J/7MbRC8j84F9t9A3/fXKY0tBJjaBBJj8DPzL83nTCLSKkfodsvJTbraYXTcJNyVrOW44ewoVbRByEoqUbv2PuoC7FIQE8k6j5LPXPrb/2XDREH6thFNNfH+mcwbB/d/bmRkQHlQVoMafahTpJHXNaxszGyEwk2YdjPavGFqXRP/DAVmp1MR+0sWALXa1nM5+7bgrz8O2cAwnCbWoQ8Yta0d335FAxUBDA5G69xguvcIWTaYpuGuKvG94DZvn6rGToRAL0DIohc0nQcPM7Ci61XLEUE0oZPW4dseGriOvcIVxd7cyySDlEP0OFlCpeerkYZbFvv8IJ37YMqgC6f+uceMvApYPWwpU9Y0n8E3dqklVV1ZnzKiTnAi9L3hjZXHXQX/RDDRVsZhaBkuh53/lXiZbrFC32kVJH7ce9/ZEdYRiwYnUJb1JauSG3DbIfHnbTQnZydovS6m19iempYa+IioyUq+18T8NJNnigyQTQ6anON4jBwrK98MwKjUv8DY8AzYIPAMCjQcWBHk2NJQbxaVCgOYdBap6sjy5kqXzE2wsXT/XDcig9COi+yiLHVdpBUrrT5B9WcKWgPujO/hkFGkokSumu1QS+ZWtfpfKCM3dUS8/P8x/VJNcscbiwt/Y360GuktcqYzOi0q04qHCroqaLldsV/T1KCiirKkgsNAUsGAYeyWAF9Cvq0o1D9gDdq/CghzvrLRoqF943PSMtrI/1n0iO+dOK1+gq3oQ0ua1LcotpcLvSu/7rKUsNhdf6DReV+xLsb52Ms/mu/0xT79s2+MW5Q1dWlJvfc/y40xPSs1SIGqlNFbgV3hwDFNgwkEinnzcgJ4JhXEGce4aLXNEzkm1LPeE2PwO2tOlXxtg6D6QZwM8fEi1CGC4YGTof1gtIyYLCuQMBkTRR24MWLSov937bNQ1K31z6rLhqWlB0gK7o7IahZst0xIDPS9hWwzbcoXrLxoUp1COMSBKYWEJ+JaNdETU/4gSTC6r2uEW0SIkA+k9sr1PhAj3xM+mY8hxp3fikqdhiC+OsoxJbm+zS4hbVfQv5EZJUPzuV4WeVN3SkdixsG8+ue8PPgESzCEMobSGQhfUuBvTNcxZj7CzTQNkpT/+OlkcAdxGROlntTlfYsUcm99aZYg/p0iz2JzkRB4jnkHlY95q/WBPjFIbxwICnNkUtAf7UlX/HtDWjzQMgBwJkJVnPOfhCzC0BGZBfQqesDcNu/4ct351zsGA9B2OIBXlr96DWqAyBymviNYEEhO/j9CUbhAocF+BEU/gSN7uRlxnYqzb+c4EL17G4tj7TYBaYP4b11XDYw68XcL8UqK0iNM4j0XsfE7LWYNR1wznUYm/ApY6gT5WGSqHXzDdXQl6NerTqFh1Qmc6mE3/zQHHgT8TH2gjg4QPScxNMhelFzwq4U0cfpF2MX7UdUrGhyXlSAZDC+0K6lOkJ194GWKSHK90X0bQNKu/b80f3psAP5UueZUbO2Y7+WTG35WHT/6doGMpcyv0EJoooVFuuiLByelOx7juv0wlLg4xGPRo1x1OhcDP+Xx17vsWD27jnyY64bgFcwU8zYLEI79t+tl0UcHvtXWts7UL/9ecKOBpQGZ5N2BdI4U6GYEgwiRtPNMoT1bSXGXxKQts/gH9CfaRGl8NboVVEBI9n589zQ57R38BbS9DyJ0Ed65lUKWuLN3j4aT9wkkWHi6rHrgH60MrskPNVYGu+vCNvcbxfd1QfC97SFykcLEYC1jTkSf86jOynH1BwCtlyjxKVox9M7hyQbY+FAzhsmaw/LX/ZxNI0+TG6orW5+c9ibF3NIQ5jk0IQLPjejQ1F7CabLjjH+ckJPAIjzBAQ1AlgMMoMSooGP7XVpIhWktjpsTkOxOgOUKAO/fzFMT1llqCZZZ0GVKnAiu/Kl3Uq7RfI4GNDiR0oGCxQC019mtrV+9YpRzx1kp+IAVsaywCvVE813TIYeGKnJEIycvfJBob0sL+OmPgfgXFBdrGQkbqXDynNc8EPVo01pd6yXcKj+R/pFOn2wvj05dB6W8FubYljhR7Gw6s1+5VIC4KHWatEY7Q4IY1tjEoawJdPR7V0ODtevbO4IdvaD5/zG4TxdHz8DT6SFV5xoPM92eDqR0wDCNeUo3PivSKPBpWZxD9LeK0nY883YUxbHjhwNfAfJihVgc5wCTWMDL/14KWY875GqHwU5v9YCafzNUX23vDxKwg0clvj7lOrYPZ6x17K7BONKu8eN1at/TjqlTPyHeFr/joBNTWsXaXIX7BVmrhlVEfHcdX8gGonqJeH3YLngYM+KHgH+GcpcyOrL55NHC6St5Z3Sm8XUciSLmY62rOF4bcxDTxeP9W/ioI96qdBdsVrBSQL8PWqMKEbnoVzJZEYs6PwDmkq4Fak1pskj+rNJhPlFch7R+VrkoWO9LC+gBsyGXWvDs0marhwWzD0fMyNIBgMH9UY84U2bVm7xFU+iwRe4vrwdreyHlThrio9Bj0EOaWDIfczpoQDxQNZ6/ZOTClB+D+h2JOTdj0Vj6UGfEWvdQ0TxSP9UoV9qcTxSp2LyLmkgym3qUX80HbZgp7XuVIjKL7/Lcvm93Zv6NKwTh1C6gnyXJ3BLQ22wrdhmzr2Itg5cKoIKhno/pXHRrC6TEcl8CUgQYfjxv6tru5Ehi/mF9S1PuUER4f+lJqFcOcIEyqqCPcI73Z1tLmCS0SJYhkrm0y7sn3ZVp8iOfQmVccFHxPNo7+skojxjJaSywRhoqDSueo1C+MZjWuB7JnUyDjk289/CB5o1t1xrWSzcJ02q2LoRUYpDkW+IKEVaI0mEjR6Tau7oAA1dT4lHLtNRtS80ldkyBQNwJ2qIKfYbnuNHGdoRXMT2kcbY7ClhFCa3VK2GS7UccwHy5pG2COTvQTi0DZ54s0fH3Um1V7hbqAHgG+urDjgU8URXdgW6dWA2bmZhvGuT4vq+4tpphfHa3/cCome4mz894QEK632zjqB36GDatqut0MGTB9Kj24l/xmDaJpIKd9z5H/zn0NK9QGm1lpn2XKAL+DacDh5R7FetsdMv64wyDR7qoULmrZ43r3tPXDIlSDBRT9cznlZw67jQomDLS34QQP8llCkbwd//yIx9kXMgOCTrZcM41Bwpn4u+T8yT7dlj3xzXwVPK3hGMwkhAdy4Pz9DCy6K90wpnky/k+jDy60l0YUzmVCVUvGzfXPK9bhs9Nnv0d7mrG2xCrnzMXN/OTxsmKS9t7u/tsPnDiCLPzzuvbs3kuqc0VeAfZFqvqpIZVKzm5vf1Old6erqgF4GAzwPIeTwwT0PE3bLja/WoY4SENr1AO2T97qZKLo9ilgxC5dw4KyPX7fDp93jSwpfFwvw+Nk4vnOITe5jRmbPammDtdFw5jm5yKQpUFh7VJUYu/cgz2dkI9yItD/EdwM8sKygPjRBiTHDdGUGmlbeHA/0G8rvKVrQ5md6YwILUhxSn33gwSu1CRT4eJDhYqyBMEiBfIOW8l40yqI6RufQ9o4O3EX2p1K2EIsMtOW444PjAJQGpnZzNr+b78EaAPS1cYiSzGCXgG45ucbXmOXfHDil3AwU9ykw89YYBARv12Q3EXKlb6gVrYH/IPMcTMz0IyCkMyjf9eY/OyVHvS3paOJzhlqz5v45JH+3llTf10KM+PUUKfUDrUCOJMwPtm3V3or1o8vzYv5P7LO636ftTwpx0AuVczw2kCFfEPC0DIpN5fwyShSKQ4oerhhBjsByoAnS1etwM3K7cPThVeqyBLb+PneNJLP5cJCyVGaGoG/WXW3//qlGBHx5O3Jy3+g8D5YEI9lv7AOx0G2ZjNrxGbnjvklv8sXl54W+LKvkS7JH/9fmnX/yDopo6ISMpRlnuWtQUVdC8Eljwmux0aI1jR27Dn/9zdmNNCR0piNJS5IDsKdTqxvQLLWzkphDG+jo2OPjTu56Yz7oPJufLjkwFfsGjjvYz3WcWUQVuJxEBDE1gO3W+LsPZqsEm64BKe9u+iC7yPW/gbKG0Il9v/5zs5eJkdscWIECaR7OFRENLPQLG8VkorqVoyb+Pcjj9z/6YpP6sRDsnCXB/WyFyZdtqRxh0zZR9jW5+/Aon9kOwh07uKWjB862p9G9yEtQCQcmvD0C36nWM1j0sRcNTCTHdSivjXAQKsZAtNE3wt2NokxIVEOET2kuPYEfUBOi2d6jEuykOrWCqSsmhsdIvIXugWnieQQKoMD8abEQjmYFU7rj27gFfjBXHl8ZD2pWkiYI7eP+2Hx2WiAZQDQHUMZhnPXSmEPX7OQhA/truSmvIc+0wSh+7JHCFSpDE+nF5d8qCqgHnaHMXYgfwzUDCD3Jbc9asR5VQ9IiTm4ZvKQSFqBEu/4g0GRwE5gOQ0xeqLgzXSTgv5t7h4FqTXCIwtyt4rBTGlteZwrAI8ip0b89yqX5UOTZqH7EFIJfsJmYFyKNWlCktMvzbUcM0eFCIiXCcGzaCFkX1Dy1dsnjZIu6+rI7cBVodOk/87Ytin82pBw== </div>]]></content>
    
    <summary type="html">
    
      你以为是px来自省了？其实是我魂来总结哒！
    
    </summary>
    
    
      <category term="journal" scheme="http://oodtoodt.github.io/categories/journal/"/>
    
    
      <category term="Souls" scheme="http://oodtoodt.github.io/tags/Souls/"/>
    
  </entry>
  
</feed>
